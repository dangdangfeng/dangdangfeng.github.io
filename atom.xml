<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流城</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dangdangfeng.github.io/"/>
  <updated>2016-08-30T16:37:51.000Z</updated>
  <id>https://dangdangfeng.github.io/</id>
  
  <author>
    <name>吴白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优秀的iOS开发站点</title>
    <link href="https://dangdangfeng.github.io/2016/08/31/%E4%BC%98%E7%A7%80%E7%9A%84iOS%E5%BC%80%E5%8F%91%E7%AB%99%E7%82%B9/"/>
    <id>https://dangdangfeng.github.io/2016/08/31/优秀的iOS开发站点/</id>
    <published>2016-08-30T16:37:08.000Z</published>
    <updated>2016-08-30T16:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-8ecc5b178b74528a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>工欲善其事必先利其器，每一次的惊叹背后都有不为人知的努力。分享和共赢，是开源的精神所在。感谢那些开诚布公，乐于助人的程序员们。从优秀到卓越，我们需要不停地向他人学习。</p>
</blockquote>
<ul>
<li>国内优秀的iOS网站</li>
<li>国外优秀的iOS网站</li>
</ul>
<h4 id="常用的国内网站"><a href="#常用的国内网站" class="headerlink" title="常用的国内网站"></a>常用的国内网站</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-2364ba42664a3d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>社区网站：</strong></p>
<ul>
<li><a href="http://www.jianshu.com" target="_blank" rel="external">简书</a></li>
<li><a href="http://gold.xitu.io/welcome/ios" target="_blank" rel="external">稀土掘金</a></li>
<li><a href="https://segmentfault.com" target="_blank" rel="external">SegmentFault</a></li>
<li><a href="http://www.cnblogs.com/cate/ios/" target="_blank" rel="external">博客园</a></li>
</ul>
<hr>
<ul>
<li><a href="http://www.cocoachina.com" target="_blank" rel="external">cocoachina</a></li>
<li><a href="http://www.iteye.com" target="_blank" rel="external">ITeye</a></li>
<li><a href="http://www.csdn.net" target="_blank" rel="external">CSDN</a></li>
<li><a href="http://www.51cto.com" target="_blank" rel="external">51CTO</a></li>
<li><a href="https://www.infoq.com" target="_blank" rel="external">infoq</a></li>
<li><a href="http://toutiao.io/subjects/12199" target="_blank" rel="external">开发者头条</a></li>
</ul>
<hr>
<ul>
<li><a href="http://www.oschina.net" target="_blank" rel="external">开源中国</a></li>
<li><a href="http://code4app.qiniudn.com" target="_blank" rel="external">Code4App</a></li>
</ul>
<hr>
<ul>
<li><a href="http://www.imooc.com" target="_blank" rel="external">慕课网</a></li>
<li><a href="http://www.maiziedu.com" target="_blank" rel="external">麦子学院</a></li>
<li><a href="http://www.jikexueyuan.com" target="_blank" rel="external">极客学院</a></li>
</ul>
<p><strong>UI设计：</strong></p>
<p><a href="http://www.ui4app.com" target="_blank" rel="external">UI4App</a></p>
<blockquote>
<p>当然还有很多有用的网站，如果您知道并愿意分享，可以在评论里提供。</p>
</blockquote>
<h4 id="常用的国外网站"><a href="#常用的国外网站" class="headerlink" title="常用的国外网站"></a>常用的国外网站</h4><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank" rel="external"> Apple Learning Objective C </a>：Apple官方文档</li>
<li><a href="https://github.com" target="_blank" rel="external">github</a>：每天必看的吧</li>
<li><a href="http://stackoverflow.com" target="_blank" rel="external">stackoverflow</a>：估计是最大的技术问答网站了</li>
<li><a href="https://www.developerfeed.com/category/ios/ios-tutorials/" target="_blank" rel="external">developerfeed</a>：开发者论坛</li>
<li><a href="https://www.objc.io" target="_blank" rel="external">objc.io</a>：经典网站，不用解释</li>
<li><a href="http://www.cocoacontrols.com" target="_blank" rel="external">cocoacontrols</a>：优秀开源组件</li>
<li><a href="http://cocoa.tumblr.com" target="_blank" rel="external">cocoa</a>：iOS开发源码和深度观察</li>
<li><a href="http://maniacdev.com/open-source-iphone-app-store-apps" target="_blank" rel="external">maniacdev.com</a>：开源ios应用及其源代码</li>
<li><a href="https://sourceforge.net" target="_blank" rel="external">sourceforge</a>：源码</li>
</ul>
<hr>
<ul>
<li><a href="http://iphonedevsdk.com/forum" target="_blank" rel="external">iphonedevsdk</a>：苹果开发论坛之一</li>
<li><a href="https://devforums.apple.com" target="_blank" rel="external">devforums.apple.com</a>：苹果官方开发者</li>
<li><a href="https://developer.apple.com/library/ios/navigation/index.html?section=Resource+Types&amp;topic=Sample+Code" target="_blank" rel="external">Sample+Code</a>：苹果官方的小示例项目论坛</li>
</ul>
<hr>
<ul>
<li><a href="http://subjc.com" target="_blank" rel="external">Subjective-C</a>：以解析和重构创新模式和著名应用的UI而闻名</li>
<li><a href="http://mobile.tutsplus.com/category/tutorials/iphone/" target="_blank" rel="external">tutsplus</a>：一些不错的实例教程</li>
<li><a href="http://nshipster.com" target="_blank" rel="external">NSHipster</a>：探讨了编程风格，以及最前沿的类的使用和实现</li>
<li><a href="http://www.raywenderlich.com" target="_blank" rel="external">raywenderlich</a>：每个iOS都应该看看</li>
</ul>
<hr>
<ul>
<li><a href="http://oleb.net" target="_blank" rel="external">oleb</a>：个人博客，在持续更新</li>
<li><a href="http://petersteinberger.com" target="_blank" rel="external">petersteinberger</a>：个人网站</li>
<li><a href="http://floriankugler.com/archive/" target="_blank" rel="external">floriankugler</a>：更到15年</li>
<li><a href="https://www.mikeash.com/pyblog/" target="_blank" rel="external">NSBlog</a>：包含了关于Objective-C和其他主题的深度问题</li>
</ul>
<hr>
<ul>
<li><a href="http://iosdevweekly.com" target="_blank" rel="external">iOS Dev Weekly</a>：每天更新的iOS推送资源</li>
<li><a href="http://ios-goodies.com" target="_blank" rel="external">iOS Goodies</a>：iOS资讯站</li>
<li><a href="http://www.appcoda.com" target="_blank" rel="external">AppCoda</a>：产于香港，重点在用于执行的最新的API和结构上</li>
<li><a href="http://merowing.info" target="_blank" rel="external">Krzysztof Zab?ocki</a>：提供关于代码结构、工具和Xcode的技巧</li>
<li><a href="http://iosdevtips.co" target="_blank" rel="external">iOS Development tips</a>：一些关于使用Xcode和API的细致的提示</li>
</ul>
<hr>
<ul>
<li><a href="https://teamtreehouse.com/techdegree" target="_blank" rel="external">Team Tree House </a>：人人都可以编程的学习网站</li>
<li><a href="http://www.technobuffalo.com" target="_blank" rel="external">technobuffalo</a>：手机媒体网站</li>
<li><a href="https://designthencode.com" target="_blank" rel="external">Design then Code </a>：最好的iOS界面设计和应用指导和教程</li>
<li><a href="http://www.daleisphere.com" target="_blank" rel="external"> iPhone App Development Where to Start </a>：博客</li>
</ul>
<p><strong>UI设计：</strong></p>
<ul>
<li><a href="http://www.iosinspires.me/" target="_blank" rel="external">iosinspires</a>：优秀的iOS平台上应用的设计，icon及相关资源</li>
<li><a href="http://www.patternsofdesign.co.uk/" target="_blank" rel="external">patternsofdesign</a>：专注于分享iOS应用UI界面的细节，按照设计元素进行分类，按照iOS常用功能对各类UI进行分类展示。</li>
<li><a href="http://pttrns.com/" target="_blank" rel="external">iOS UI Patterns</a>：整理/罗列了许多精彩的iOS 应用界面截图，并且按照分类将这些截图分类，比如Activity，Login，About，Calendar，Seeting，Share等各种类型的不同应用的实现效果</li>
<li><a href="http://www.appsites.com/" target="_blank" rel="external">appsites</a>：优秀移动应用网站设计</li>
<li><a href="http://dribbble.com/" target="_blank" rel="external">dribbble</a>：设计师交流和分享自己设计作品的社区。上面有很多非常棒的移动产品设计作品。</li>
<li><a href="http://www.tappgala.com/" target="_blank" rel="external">tappgala</a>：分享最棒的手机产品界面设计</li>
</ul>
<p><strong>iOS游戏</strong></p>
<ul>
<li><a href="http://maniacdev.com/open-source-ios-game-list-source-code-to-games-in-the-app-store" target="_blank" rel="external">open-source-ios-game</a>：iOS游戏及其源代码</li>
<li><a href="http://mobile.tutsplus.com/tutorials/iphone/learn-ios-game-development-by-example-10-projects-to-get-you-started/" target="_blank" rel="external">iOS游戏开发可以参考的10个实例</a>：（源代码都在github上）</li>
<li><a href="http://www.learn-cocos2d.com/blog/" target="_blank" rel="external">Kobold2d引擎</a>：cocos2d引擎的变种，主要和ios,cocos2d,kobold2d开发有关</li>
<li><a href="https://developers.facebook.com/docs/tutorials/ios-sdk-games/" target="_blank" rel="external">facebook的游戏教程</a></li>
<li><a href="http://www.idevgames.com/articles" target="_blank" rel="external">idevgames</a>：游戏相关的教程</li>
</ul>
<p>暂时统计了这么多，还有好多优秀的网站等待我们挖掘，当然有好的网站也希望可以多互相分享，此处持续添加中······。</p>
<p>总体感觉，国外的网站并不一定比国内的好用，比如objc.io已经有了国内版。外国网站对于英语也是一种挑战，不过技术就是如此，想更上一层，总要比他人更努力一些。</p>
<p>PS：读文章固然可以增长我们的见识，但别人的总归是别人的，只有内化成自己的，才不至于白费光阴。写博客，开源组件，都是很好的锻炼。要对得起您耗费的时间。时间不会辜负尊重它的人的，与君共勉！</p>
<h4 id="无法访问国外网站怎么办？"><a href="#无法访问国外网站怎么办？" class="headerlink" title="无法访问国外网站怎么办？"></a>无法访问国外网站怎么办？</h4><ul>
<li><a href="https://github.com/racaljk/hosts" target="_blank" rel="external">hosts</a>：最新可用的google hosts文件</li>
</ul>
<h5 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h5><p>请出门左拐，购买付费！世界变得无比简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-8ecc5b178b74528a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
    
      <category term="helper" scheme="https://dangdangfeng.github.io/tags/helper/"/>
    
  </entry>
  
  <entry>
    <title>如何幽雅的谈论Hybrid App</title>
    <link href="https://dangdangfeng.github.io/2016/08/30/%E5%A6%82%E4%BD%95%E5%B9%BD%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BAHybrid-App/"/>
    <id>https://dangdangfeng.github.io/2016/08/30/如何幽雅的谈论Hybrid-App/</id>
    <published>2016-08-30T15:40:19.000Z</published>
    <updated>2016-08-30T15:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>重要的并不是我们提供的信息量有多大，而是我们能否给他们提供真正需要的信息。             -《瞬间之美》</p>
</blockquote>
<p>本文涉及如下方面：</p>
<ul>
<li>什么是Hybrid架构(可略读)</li>
<li>Hybrid与Native的关系</li>
<li>设计上的考虑</li>
<li>一句话说明白</li>
<li>技术实现</li>
<li>Cordova</li>
</ul>
<hr>
<h4 id="Hybrid架构"><a href="#Hybrid架构" class="headerlink" title="Hybrid架构"></a>Hybrid架构</h4><blockquote>
<p>Hybrid App：Hybrid App is a mobile application that is coded in both browser-supported language and computer language. They are available through application distribution platforms such as the Apple App Store, Google Play etc. Usually, they are downloaded from the platform to a target device, such as iPhone, Android phone or Windows Phone. The subscribers need to install to run them.</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-3b19957dce0c01d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。Hybrid开发效率高、跨平台、低层本的特点，Hybrid从业务开发上讲，没有版本问题，对于BUG能及时修复。但Hybrid也是有缺点的，Hybrid体验比不上Native，同样的功能在性能上存在巨大差距。Web界面上JS对HTML Node的操作需要消耗大量的CPU资源，手机CPU的性能还不能与PC相提并论，就算在智能手机之间，硬件水准也参差不齐，一个可以在iPhone 6上流畅运行的界面，跑到三星上很可能就卡住不动了。所以我们经常可以发现一些富交互页面上的操作无法达到令人满意的流畅度，而流畅度也正是用户评价一款App优劣的最直观因素。所以混合式编程比较适用于需要快速试错、快速占领市场的团队，当然，也不是绝对。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-2d23bdaa9e7a426a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Hybrid App按网页语言与程序语言的混合，通常分为三种类型：多View混合型，单View混合型，Web主体型。</p>
<p>多View混合型即Native View和Web View独立展示，交替出现。这种应用混合逻辑相对简单。即在需要的时候，将WebView当成一个独立的View（Activity）运行起来，在WebView内完成相关的展示操作。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。</p>
<p>单View混合型即在同一个View内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单View混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。</p>
<p>Web主体型即移动应用的主体是Web View，主要以网页语言编写，穿插Native功能的Hybrid App开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。Web主体型的移动应用用户体验的好坏，主要取决于底层中间件的交互与跨平台的能力。国外的appMobi、PhoneGap和国内的WeX5、AppCan和Rexsee都属于Web主体型移动应用中间件。其中Rexsee不支持跨平台开发。appMobi和PhoneGap除基础的底层能力更多是通过<strong>插件（Plugins）</strong>扩展的机制实现Hybrid。AppCan除了插件机制，还提供了大量的单View混合型的接口来完善和弥补Web主体型Hybrid App体验差的问题，接近Native App的体验。而WeX5则在揉合PhoneGap和Bootstrap等主流技术的基础上，对性能进一步做了深度优化，不但完全具备Native App对本地资源的调用能力，性能体验也不输原生；WeX5所开发出来的app具备完全的跨端运行能力，可以无需任何修改直接运行在各种前端环境上。</p>
<p>多主体共存型（灵活型）是一种新型的开发模式，即支持Web主体型的应用，又支持以Native主体的应用，也支持两者混合的开发模式。比如kerkee框架 ，它具有跨平台、用户体验好、性能高、扩展性好、灵活性强、易维护、规范化、具有Debug环境、彻底解决跨域问题等特点。用户体验与Native App媲美。功能方面，开发者可随意扩展接口。</p>
<h4 id="Hybrid与Native的关系"><a href="#Hybrid与Native的关系" class="headerlink" title="Hybrid与Native的关系"></a>Hybrid与Native的关系</h4><p>在Hybrid架构设计中Native提供的是一宿主环境，实现合理的逻辑架构需要考虑：交互设计，资源访问，Hybrid开发调试，通讯设计、并发设计、异常处理、日志监控以及安全模块等问题，前端要做的事情就是封装Native提供的各种能力。</p>
<p>处理交互设计时需要考虑前端与Native配合处理，如H5与Native的互相跳转逻辑；<br>资源访问机制需要做到既能以file的方式访问Native内部资源，又能使用url的方式访问线上资源，处理好跳转的逻辑；需要提供前端资源增量替换机制，以摆脱APP迭代发版问题，避免用户升级APP，这里将涉及到静态资源在APP中的存放策略，更新策略的设计，以及服务器端的支持等。当然，有现成框架和解决方案的支持，但这些确实是不可忽略的问题。</p>
<p>Hybrid的交互是通过Native调用前端页面的JS方法，或者前端页面通过JS调用Native提供的接口实现的，两者交互的桥梁是Webview，iOS可以使用javascripbrige来实现（现成框架），在UIWebView的shouldStartLoadWithRequest方法里面捕获url的变化，解析出需要的参数，然后传给一个统一的处理方法。app自身可以自定义url schema，并且把自定义的url注册在调度中心。JS与Native通信可以创建这类URL被Native捕获处理，即schema跳转逻辑。APP安装后会在手机上注册一个schema，比如淘宝是taobao://，Native会有一个进程监控Webview发出的所有schema://请求，然后分发到“控制器”。hybridapi处理程序，Native控制器处理时会需要param提供的参数（encode过），根据实际需要处理业务逻辑问题。</p>
<h4 id="设计上的考虑"><a href="#设计上的考虑" class="headerlink" title="设计上的考虑"></a>设计上的考虑</h4><p>无论在Android还是iOS平台上，都有各自的一套交互习惯，包括视觉风格，界面切换，操作习惯等，与Web习惯完全不同。以iOS界面切换为例，系统风格是新界面自右向左推入，后退时界面自左向右推出，而旧界面保持状态。Web开发的默认习惯则是刷新页面，无论新载入页面或是后退，都会对页面进行刷新。因此使用Web模式开发多界面功能就面临这样的交互习惯差异，造成体验上的损失。当然Web方式也可模拟Native的交互方式，但这样的模拟首先提高了开发成本，有悖于最初的高效原则，从效果上看，也很难达到Native的流畅性。</p>
<h4 id="一句话说明白"><a href="#一句话说明白" class="headerlink" title="一句话说明白"></a>一句话说明白</h4><p>如果用一句话来讲明白这个问题，就是Hybrid混合式编程可以在Native原生应用的基础上通过一些Hybrid框架实现本地和JS的交互处理。在不影响性能的情况下，实现应用的动态化。</p>
<h4 id="技术实现原理"><a href="#技术实现原理" class="headerlink" title="技术实现原理"></a>技术实现原理</h4><p>Hybrid技术将静态资源存于Native，目录结构可以如下面划分，当然不是绝对的，基本要求是将对应版本的Hybrid插件下载到本地，存放方便就好。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-17f9fb8918c3d88c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在正式的开发中，还要考虑增量机制，因为不同的版本会对应着不同的业务逻辑，真实的增量机制需要服务器端的配合，版本映射表是每次大版本APP发布时由服务器端生成。当APP启动时，APP会读取版本信息，如果发现本地版本号比线上的小，便会下载对应的zip文件，然后解压之后并且替换整个原有的文件，本次增量结束，因为所有的版本文件不会重复，APP回滚时可用回到任意想去的版本，也可以对任意版本做BUG修复。</p>
<p>以上，我们得知，Hybrid和Native交互可以通过两种方式：Url Schema和JavaScriptCore等地交互。H5与Native交互的桥梁为Webview，“联系”的方式以url schema的方式，在用户安装app后，app可以自定义url schema，并且把自定义的url注册在调度中心。</p>
<pre><code>demoschema://hybridapi?callback=hybrid_1446276509894&amp;param=%7B%22data1%22%3A1%2C%22data2%22%3A2%7D
</code></pre><p>App调用H5:将一组API绑定在webView的window对象上，App通过iOS原生方法调用window对象中的js方法。<br>H5与App通信：App实现对Webview URL的观察者模式，H5 通过改变URL的哈希值，通过解析哈希值的变化执行相应的操作。</p>
<p>另一种是JavaScriptCore，具体的可以看之前写的文章<a href="http://www.jianshu.com/p/bbfa8dee967e" target="_blank" rel="external">JavaScriptCore框架</a>。</p>
<pre><code>context[@&quot;makeUIColor&quot;] = ^(NSDictionary *rgbColor){
float red = [rgbColor[@&quot;red&quot;] floatValue];
float green = [rgbColor[@&quot;green&quot;] floatValue];
float blue = [rgbColor[@&quot;blue&quot;] floatValue];
return [UIColor colorWithRed:(red / 255.0)
                   green:(green / 255.0)
                    blue:(blue / 255.0)
                   alpha:1];
};
JSValue *color = [context evaluateScript:@&quot;makeUIColor({red: 50, green: 150, blue: 250})&quot;];
NSLog(@&quot;color:%@&quot;,[color toObject]);
</code></pre><p>通过这种方式就可以在JavaScript中调用Objective-C。</p>
<p>当然，除此之外也可以用JSBridge技术实现。<br>JS中：</p>
<pre><code> button.onclick = function(e) {
    e.preventDefault();
    var data = &apos;Hello from JS button&apos;;
    log(&apos;JS sending message&apos;, data);
    window.external.test1(data, &apos;haha&apos;);
}
</code></pre><p>通过JSBridge,执行本地类中的test1方法。此处只是一个引子，详细的会在另一篇文章中单独引出。</p>
<p>至于H5和Native的跳转问题，可以采用统跳协议来完成。这又是另外一个问题了。当然也可以在JS里定义跳转地址，通过JS交互来处理。</p>
<h4 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h4><p>写了那么久，感觉现在才进入主题。</p>
<p>Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。Cordova还提供了一组统一的JavaScript类库，以及为这些类库所用的设备相关的原生后台代码。</p>
<p>测试使用可以到Github上下载<a href="https://github.com/apache/cordova-ios" target="_blank" rel="external">源码</a>,也可以使用命令：</p>
<pre><code>cordova create hello com.example.hello HelloWorld
cd hello
cordova platform add ios
</code></pre><p>这样就创建了hello文件夹下的测试目录(com.example.hello 为应用程序的id名，与Xcode中类似，可以在 config.xml 中修改，如果不指定的话默认为 io.cordova.hellocordova)。</p>
<blockquote>
<p>目录文件说明：<br>config.xml ：cordova的配置文件<br>hooks/ ：存放自定义cordova命令的脚本文件。<br>platforms/ ：各个平台原生工程代码，会在build时被覆盖勿修改<br>plugins/ ：插件目录（主要是提供各个平台的原生API）<br>www/ ：用H5编写的源代码目录，build时会被放入各个平台的assets\www目录。<br>www/index.html ：App入口html文件</p>
</blockquote>
<p>在Xcode编译运行的话，使用的是 Staging 下面的html页面。</p>
<p>命令安装需要安装cordova命令</p>
<pre><code>brew install node //该命令执行后，自动装好node和npm。
brew upgrade node //更新node(可不执行)
</code></pre><p>为了解决校验码不正确问题。npm 使用国内镜像的方法 （三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p>
<pre><code>1.通过config命令
npm config set registry http://registry.cnpmjs.org npm info underscore （如果上面配置正确这个命令会有字符串response）
2.命令行指定
npm --registry http://registry.cnpmjs.org info underscore 
3.编辑 ~/.npmrc 加入下面内容
registry = http://registry.cnpmjs.org
</code></pre><p>之后：</p>
<pre><code>sudo npm install -g cordova
</code></pre><p>打开platform/ios里的HelloWorld.xcodeproj即可测试。</p>
<p>下面就是源码分析了，因为要对照着源码来说，大家可以到<a href="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse" target="_blank" rel="external">这里</a>(<a href="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse)，参考我写的详细的源码分析。通过这里，写一个混合式App应该不是问题了。" target="_blank" rel="external">https://github.com/dangdangfeng/Cordova-Source-Code-Analyse)，参考我写的详细的源码分析。通过这里，写一个混合式App应该不是问题了。</a></p>
<p>最后，祝大家看的愉快！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;重要的并不是我们提供的信息量有多大，而是我们能否给他们提供真正需要的信息。             -《瞬间之美》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文涉及如下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是Hybrid架构(可略读)&lt;/li&gt;

    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的谈论源码</title>
    <link href="https://dangdangfeng.github.io/2016/08/30/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BA%E6%BA%90%E7%A0%81/"/>
    <id>https://dangdangfeng.github.io/2016/08/30/如何优雅的谈论源码/</id>
    <published>2016-08-30T15:38:48.000Z</published>
    <updated>2016-08-30T15:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要涉及一下几点：</p>
<ul>
<li>SDWebImage 原理</li>
<li>SDWebImage 使用</li>
<li>SDWebImage 源码分析</li>
<li>一些思考</li>
</ul>
<hr>
<h4 id="SDWebImage-加载图片原理"><a href="#SDWebImage-加载图片原理" class="headerlink" title="SDWebImage 加载图片原理"></a>SDWebImage 加载图片原理</h4><p><a href="https://github.com/dangdangfeng/SDWebImage-Source-Analyse" target="_blank" rel="external">具体源码分析</a>见GIT。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-6971e44291c18bb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目前标注的类"></p>
<p>通过标注的类，看懂应该没问题了。</p>
<p>SDWebImage是一个图片缓存的框架。相较于AFNetworking集成的UIImageView+AFNetworking.h，对于图片的缓存实际应用的是NSURLCache自带的cache机制。而NSURLCache每次都要把缓存的raw  data 再转化为UIImage，就带来了数据处理和内存方面的更多操作。SDWebImage的缓存由SDImageCache类来实现，这是一个单例类，该类负责处理内存缓存及一个可选的磁盘缓存，其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。此外还提供了若干属性和接口来配置和操作缓存对象。包含以下功能：</p>
<p>1.提供UIImageView的一个分类，以支持网络图片的加载与缓存管理</p>
<p>2.一个异步的图片加载器</p>
<p>3.一个异步的内存+磁盘图片缓存</p>
<p>4.支持GIF图片</p>
<p>5.支持WebP图片</p>
<p>6.后台图片解压缩处理</p>
<p>7.确保同一个URL的图片不被下载多次</p>
<p>8.确保虚假的URL不会被反复加载</p>
<p>9.确保下载及缓存时，主线程不被阻塞</p>
<p><strong>SDWebImage底层实现原理：</strong></p>
<p>SDWebImage有沙盒缓存机制，主要由三块组成</p>
<p>1.内存图片缓存</p>
<p>2.内存操作缓存</p>
<p>3.磁盘沙盒缓存</p>
<p>SDWebImage的大部分工作是由缓存对象SDImageCache和异步下载器管理对象SDWebImageManager来完成的。SDWebImage的图片下载是由SDWebImageDownloader这个类来实现的，它是一个异步下载管理器，下载过程中增加了对图片加载做了优化的处理。而真正实现图片下载的是自定义的一个Operation操作，将该操作加入到下载管理器的操作队列downloadQueue中，Operation操作依赖系统提供的NSURLConnection类实现图片的下载。</p>
<p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类来完成的。该类负责处理内存缓存及一个可选的磁盘缓存。内存缓存的处理是使用NSCache对象来实现的。NSCache是一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类，用搜索文件系统的方式做管理，文件替换方式是以时间为单位。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</p>
<p>磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Cache文件夹。另外，SDImageCache还定义了一个串行队列，来异步存储图片。</p>
<p>当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。使用Decoder 是因为UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，<br>所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。<br>为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。是典型的空间换时间的做法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-8c5e61bb0b11d4e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>SDWebImage的原理</strong></p>
<p>1.使用 </p>
<pre><code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options; 
</code></pre><p>会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</p>
<p>2.进入  SDWebImageManager</p>
<pre><code>-downloadWithURL:options:progress:completed:
</code></pre><p>交给 SDImageCache 从缓存查找图片是否已经下载。</p>
<p>3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，取缓存，没有从<code>- (UIImage <em>)diskImageForKey:(NSString </em>)key</code>去磁盘缓存中去查找，根据 URLKey 在硬盘缓存目录下尝试读取图片文件。在磁盘缓存中找到后，同时更新置内存缓存中（如果空闲内存过小，会先清空内存缓存），有回调则调用doneBlock回调。</p>
<p>4.找到了就从SDWebImageQueryCompletedBlock到 UIImageView+WebCache 等前端展示图片。</p>
<p>5.如果从硬盘缓存目录读取不到图片，说明不存在该图片，需要下载图片，共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 图片下载由 NSURLSession 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。</p>
<p>6.<code>URLSession:didReceiveData:</code> 中利用 ImageIO 做了按图片下载进度加载效果。数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</p>
<p>7.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</p>
<p>8.在主线程 SDWebImageDownloaderCompletedBlock里处理解码完成后的操作。回调给需要的地方展示图片。</p>
<p>9.从SDWebImageDownloaderProgressBlock 回调给 SDWebImageManager 告知图片下载信息。</p>
<p>10.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</p>
<p>11.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。</p>
<p>12.SDWebImage 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache方便使用。 SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-bf7c86e7bd12b9c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="SDWebImage-使用"><a href="#SDWebImage-使用" class="headerlink" title="SDWebImage 使用"></a>SDWebImage 使用</h4><p><strong>常用到的对象：</strong></p>
<p>1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调。</p>
<p>2、SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。<br>向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader） 。<br>实现SDImageCache和SDWebImageDownloader的回调。</p>
<p>3、SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）<br>实现图片和内存清理工作。</p>
<p>4、SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式）</p>
<p>5、SDWebImageDecoder，异步对图像进行了一次解压</p>
<p>使用：</p>
<pre><code>[self.imageView sd_setImageWithURL:self.imageURL
                      placeholderImage:nil
                               options:SDWebImageProgressiveDownload
                              progress:^(NSInteger receivedSize, NSInteger expectedSize) {
                                  ...
                              }
                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {
                                 ...
                             }];
</code></pre><p>调用setImageWithURL:方法的时候，SDWebImage自动做很多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法：</p>
<pre><code>//这个方法是下载imagePath2的时候响应
SDWebImageManager *manager = [SDWebImageManager sharedManager];

[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize) {

    NSLog(@&quot;显示当前进度&quot;);

} completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {

    NSLog(@&quot;下载完成&quot;);
}];
</code></pre><p><strong>基本代码：</strong></p>
<p>使用SDWebImageManager类：可以进行一些异步加载的工作。</p>
<pre><code>SDWebImageManager *manager = [SDWebImageManager sharedManager];
UIImage *cachedImage = [manager imageWithURL:url]; // 将需要缓存的图片加载进来
if (cachedImage) {
  // 如果Cache命中，则直接利用缓存的图片进行有关操作
  // Use the cached image immediatly
} else {
  // 如果Cache没有命中，则去下载指定网络位置的图片，并且给出一个委托方法
  // Start an async download
 [manager downloadWithURL:url delegate:self];
}
</code></pre><p>当然你的类要实现SDWebImageManagerDelegate协议，并且要实现协议的webImageManager:didFinishWithImage:方法。</p>
<pre><code>// 当下载完成后，调用回调方法，使下载的图片显示
- (void)webImageManager:(SDWebImageManager *)imageManager didFinishWithImage:(UIImage *)image {
// Do something with the downloaded image
}
</code></pre><p><strong>独立的异步图像下载</strong></p>
<p>可能会单独用到异步图片下载，则一定要用downloaderWithURL:delegate:来建立一个SDWebImageDownloader实例。</p>
<pre><code>downloader = [SDWebImageDownloader downloaderWithURL:url delegate:self];
</code></pre><p>这样SDWebImageDownloaderDelegate协议的方法imageDownloader:didFinishWithImage:被调用时下载会立即开始并完成。</p>
<p><strong>独立的异步图像缓存</strong></p>
<p>SDImageCache类提供一个创建空缓存的实例，并用方法imageForKey:来寻找当前缓存。</p>
<pre><code>UIImage *myCachedImage = [[SDImageCache sharedImageCache] imageFromKey:myCacheKey];
</code></pre><p>存储一个图像到缓存是使用方法storeImage: forKey:</p>
<pre><code>[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];
</code></pre><p>默认情况下，图像将被存储在内存缓存和磁盘缓存中。如果仅仅是想内存缓存中，要使用storeImage:forKey:toDisk:方法的第三个参数带一负值<br>来替代。</p>
<h4 id="SDWebImage-源码分析示例"><a href="#SDWebImage-源码分析示例" class="headerlink" title="SDWebImage 源码分析示例"></a>SDWebImage 源码分析示例</h4><p>SDWebImageDownloader类</p>
<p>SDWebImageDownloaderOptions定义：</p>
<pre><code>typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) {
SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,
SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,

// 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache
SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,

// 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block
SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,

// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消
SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,

// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie
SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,

// 允许不受信任的SSL证书。主要用于测试目的。
SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,

// 将图片下载放到高优先级队列中
SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,
};
</code></pre><p>下载顺序：</p>
<pre><code>typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) {
// 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序
SDWebImageDownloaderFIFOExecutionOrder,
// 以栈的方式，按照后进先出的顺序下载。
SDWebImageDownloaderLIFOExecutionOrder
};
</code></pre><p>每个下载操作都定义了回调操作，如下载进度回调，下载完成回调，头部过滤等，这些回调操作是以block形式来呈现；每个下载操作的下载进度回调和下载完成回调，这两个回调稍后将保存在下载管理器的URLCallbacks字典中，key为URL，value为一个数组，数组里面又存放一个保存了下载进度回调和完成回调代码块的字典。这个字典数组同时也保证了同一张图片只会被下载一次。</p>
<pre><code>// 下载进度
typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);
// 下载完成
typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);
// Header过滤
typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);
</code></pre><p>为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性。</p>
<pre><code>- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback {
...
// 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作
dispatch_barrier_sync(self.barrierQueue, ^{
...
// 2. 处理同一URL的同步下载请求的单个下载
});
}
</code></pre><p>下载请求的管理都是放在downloadImageWithURL:options:progress:completed:方法里面来处理的，该方法调用了上面所提到的addProgressCallback:andCompletedBlock:forURL:createCallback:方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入downloadQueue操作队列中，最后方法返回新创建的操作。</p>
<pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock {
...
[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{
...
}
</code></pre><p>下载操作的超时时间可以通过downloadTimeout属性来设置，默认值为15秒。</p>
<p>SDWebImage定义了一个协议，即 SDWebImageOperation 作为图片下载操作的基础协议。它只声明了一个cancel方法，用于取消操作。每个图片的下载都是一个Operation操作。SDWebImage自定义了一个Operation类，即 SDWebImageDownloaderOperation ，它继承自NSOperation，并采用了SDWebImageOperation协议。除了继承而来的方法，该类只向外暴露了一个方法，initWithRequest:options:progress:completed:cancelled:。对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLSession。具体看代码<a href="https://github.com/dangdangfeng/SDWebImage-Source-Analyse" target="_blank" rel="external">源码分析</a>.</p>
<pre><code>- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data
</code></pre><p>方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个CGImageSourceRef对象以做处理。在首次获取到数据时(width+height==0)会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用CGImageSourceRef对象创建一个图片对象，经过缩放、解压缩操作后生成一个UIImage对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>
<p>缩放操作可以查看SDWebImageCompat文件中的SDScaledImageForKey函数；解压缩操作可以查看SDWebImageDecoder文件+decodedImageWithImage方法。在下载完成或下载失败后，需要停止当前线程的run loop，清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。</p>
<p>最重要是自己分析，看过的会忘，消化了才是自己的。学而不思则罔,思而不学则殆。每个人要了解自己的优缺点。有思考才有所得！</p>
<h4 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h4><p>我们应该把精力和时间投入在更值得学习的东西上。如果纯看代码而没有碰到这个场景就算看懂了也没法理解，学习的目的是为了实践，而不要为了原理而分析原理，这样就本末倒置了。对于广大程序员而言，做码农，通过低水平重复的劳动来创造价值的道路是永远不可能一劳永逸的，恰恰相反，是永劳一逸的！生产只能够惠及当下！事物的发展在于思考，可能每个人走的路径不一样，寻找到最适合自己的，坚持走下去。只要能肯定每天都是进步的，快慢又有什么关系呢。这是一个浮躁的社会，这个社会催生了无数可能，也许不是每个人都能做一辈子的程序员，但不要辜负你的时光。你之所以成为你，是因为你的时间，你的经历在哪里，你就在哪里。共勉！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要涉及一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDWebImage 原理&lt;/li&gt;
&lt;li&gt;SDWebImage 使用&lt;/li&gt;
&lt;li&gt;SDWebImage 源码分析&lt;/li&gt;
&lt;li&gt;一些思考&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;SDWebImage-加
    
    </summary>
    
    
      <category term="source" scheme="https://dangdangfeng.github.io/tags/source/"/>
    
  </entry>
  
  <entry>
    <title>从代码看一个程序员的笔力</title>
    <link href="https://dangdangfeng.github.io/2014/08/31/%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8B%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AC%94%E5%8A%9B/"/>
    <id>https://dangdangfeng.github.io/2014/08/31/从代码看一个程序员的笔力/</id>
    <published>2014-08-30T16:38:23.000Z</published>
    <updated>2016-08-30T16:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>从代码的整洁度上就可以看出一个程序员的实力，规范其实就是让你养成一种良好习惯的标杆，在此面前我们应该顺从（本篇以OC为例）。</p>
<ol>
<li><p>单页代码最好控制在800行以内，每个方法最好不要超过100行，过多建议对代码进行重构</p>
</li>
<li><p>相同的逻辑方法定义避免在多个地方出现，尽量将公用的类、方法抽取出来</p>
</li>
<li><p>删除未被使用的代码，不要大片注释未被使用的代码，确定代码不会使用，请及时删除</p>
</li>
<li><p>对其他项目中copy过来的代码，根据具体需要更新代码风格，及时删除未被使用的代码</p>
</li>
<li><p>项目中所有Group或者文件名称（图片名字等），不要使用汉字命名，尽量使用英文命名，国内特有名词可以使用拼音。</p>
</li>
<li><p>项目中所有Group都需要在项目目录中存在一个真实的目录，Group中的文件与真实目录中文件一一对应。</p>
</li>
<li><p>请在项目中写必要代码的注释</p>
</li>
<li><p>请多使用 #pragma mark - Mark Name 对方法进行分组 。如:</p>
<pre><code>#pragma mark - **********View lifeCycle******
</code></pre></li>
<li><p>所有类名称以项目工程开头命名，如：“JS”（简书）。针对不同视图控制器，在末尾添加后缀，如： UIButton 后缀添加“Button”或大家皆知的简写，NSArray的变量命名为xxxArray等。</p>
</li>
<li><p>类、方法、属性等命名，做到见名知意，采用驼峰式命名规则。</p>
</li>
<li><p>根据资源类型或者所属业务逻辑对项目资源进行分组，使得整个项目结构清晰明了；整个项目保持一种代码书写风格。</p>
</li>
<li><p>避免在程序中直接出现常数，使用超过一次的应以宏定义的形式来替代。常数的宏定义应与它实际使用时的类型相一致。如以3.0来定义浮点类型，用3表示整型。 常量的命名应当能够表达出它的用途，并且用大写字母表示。例如：</p>
<pre><code>#define PI 3.1415926
</code></pre></li>
<li><p>当使用条件语句编码时，不要嵌套if语句，多个返回语句也是OK。</p>
<pre><code>- (void)testMethod {
   if (![testSome boolValue]) {// 不合适就返回，下面做处理
   return;
  }
 //Do something important
}
</code></pre></li>
<li><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<pre><code>NSError *error;
if (![self trySomethingWithError:&amp;error]) {
  // Handle Error
}
</code></pre></li>
<li><p>当参数过长时，每个参数占用一行，以冒号对齐。如：</p>
<pre><code>- (void)aboutFisrtNumber:(NSString *)oneStr
          withNextNumber:(NSString *)twoStr
          withLastNumber:(NSString *)threeStr{
// do something
}
</code></pre></li>
<li><p>一行很长的代码应该分成两行代码，下一行用两个空格隔开</p>
<pre><code>self.productsRequest = [[JSProductsRequest alloc] 
  initWithProductIdentifiers:productIdentifiers];
</code></pre></li>
<li><p>删除多余的空行，所有方法与方法之间空1行，所有代码块之间空1行。变量声明后需要空1行，如果需要分类区别，各类别之间空1行。条件、循环，选择语句，整个语句结束，需要空1行。最后一个括弧之前不空行。注释与代码之间不空行。</p>
<pre><code>#pragma 与方法之间空1行
</code></pre></li>
<li><p>每行代码最多不得超过100个字</p>
</li>
<li><p>如果类声明中包含多个protocol，每个protocol占用一行，缩进2个字符如:</p>
<pre><code>@interface BootViewController : UITableViewController&lt;&lt;/p&gt;
UITableViewDelegate,
UITableViewDataSource,
UITextFieldDelegate,
UITextViewDelegate
&gt;{
// code
}
</code></pre></li>
<li><p>图片命名：采用单词全拼，或者大家公认无岐义的缩写(比如：nav，bg，btn等)；采用“模块+功能”命名法，模块分为公共模块、私有模块。公共模块主要包括统一的背景，导航条，标签，公共的按钮背景，公共的默认图等等；私有模块主要根据app的业务；功能模块划分，比如用户中心，消息中心等。建议背景图采用以bg作前缀，按钮背景采用btn作前缀。</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-798d683d4df650ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从代码的整洁度上就可以看出一个程序员的实力，规范其实就是让你养成一种良好习惯的标杆，在此面前我们应该顺从（本篇以OC为例）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单页代码最好控制在800行以内，每个方法最好不要超过100行，过多建议对代码进行重构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
    
    </summary>
    
    
      <category term="method" scheme="https://dangdangfeng.github.io/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的谈论OC</title>
    <link href="https://dangdangfeng.github.io/2014/08/30/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BAOC/"/>
    <id>https://dangdangfeng.github.io/2014/08/30/如何优雅的谈论OC/</id>
    <published>2014-08-30T15:35:30.000Z</published>
    <updated>2016-08-30T15:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p>
<ul>
<li>OC的面向对象</li>
<li>运行时Runtime</li>
<li>运行循环RunLoop</li>
<li>事件响应链</li>
<li>引用计数</li>
<li>生命周期</li>
<li>与其他语言的区别</li>
</ul>
<hr>
<p>Objective-C 简称OC（下面以此代称），是在C语言的基础上，增加了一层最小的面向对象语言。是一种静态输入的语言，即“必须先声明数据中每个变量（或者容器）的数据类型”。但它是一个动态语言，代码中的某一部分可以在app运行的时候被扩展和修改（比如，在被编译之后）。OC完全兼容C语言，在代码中，可以混用c，甚至是c++代码。</p>
<h3 id="面向对象三原则（封装，继承，多态）"><a href="#面向对象三原则（封装，继承，多态）" class="headerlink" title="面向对象三原则（封装，继承，多态）"></a>面向对象三原则（封装，继承，多态）</h3><p>面向对象具有四个基本特征：抽象，封装，继承和多态。</p>
<p>C语言是面向过程的语言(关注的是函数)，OC,C++,JAVA,C#,PHP,Swift是面向对象的，面向过程关注的是解决问题涉及的步骤，而面向对象关注的是设计能够实现解决问题所需功能的类。抽象是面向对象的思想基础。</p>
<p>抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。抽象是一种思想，封装继承和多态是这种思想的实现。</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>封装是把过程和数据包围起来（即函数和数据结构，函数是行为，数据结构是描述），有限制的对数据的访问。面向对象基于这个基本概念开始的（<em>因为面向对象更注重的是类</em>），即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。但是封装会导致并行效率问题，因为执行部分和数据部分被绑定在一起，制约了并行程度。面向对象思想将函数和数据绑在一起，扩大了代码重用时的粒度。而且封装下的拆箱装箱过程中也会导致内存的浪费。</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>继承是一种层次模型，允许和鼓励类的<em>重用</em>，并提供了一种明确表述<em>共性</em>的方法。新类继承了原始类的特性，新类称为原始类的派生类（子类和父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。继承性很好的解决了软件的可重用性问题。但是，不恰当地使用继承导致的最大的一个缺陷特征就是高耦合（即“牵一发而动全身”，是设计类时<em>层次</em>没分清导致的）。解决方案是用组合替代继承。将模块拆开，然后通过定义好的接口进行交互，一般来说可以选择Delegate模式来交互。使用继承其实是如何给一类对象划分层次的问题。在正确的继承方式中，父类应当扮演的是底层的角色，子类是上层的业务。父类只是给子类提供服务，并不涉及子类的业务逻辑；层级关系明显，功能划分清晰；父类的所有变化，都需要在子类中体现，此时耦合已经成为需求。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括<em>参数化多态性和包含多态性</em>。很好的解决了应用程序函数同名问题，多态一般都要跟继承结合起来说，其本质是子类通过覆盖或重载父类的方法，来使得对同一类对象同一方法的调用产生不同的结果。覆盖是对接口方法的实现，继承中也可能会在子类覆盖父类中的方法。重载，是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样）； 但继承会引入多态使用混乱的境况并产生耦合，更好的方法是使用接口。通过IOP将子类与可能被子类引入的不相关逻辑剥离开来，提高了子类的可重用性，降低了迁移时可能的耦合。接口规范了子类哪些必须实现，哪些可选实现。那些不在接口定义的方法列表里的父类方法，事实上就是不建议覆重的方法。如果引入多态之后导致对象角色不够单纯，那就不应当引入多态，如果引入多态之后依旧是单纯角色，那就可以引入多态；如果要覆重的方法是角色业务的其中一个组成部分，那么就最好不要用多态的方案，用IOP，因为在外界调用的时候其实并不需要通过多态来满足定制化的需求。</p>
<h3 id="动态性（Runtime）"><a href="#动态性（Runtime）" class="headerlink" title="动态性（Runtime）"></a>动态性（Runtime）</h3><p>Objective-C 是面相运行时的语言，它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。使用Runtime可以按需要把消息重定向给合适的对象，交换方法的实现等等。</p>
<p>Runtime简称运行时，其中最主要的是消息机制，是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。。OC的函数调用称为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</p>
<p>如：</p>
<pre><code>[obj makeText];
＝＝》
objc_msgSend(obj,@selector(makeText));
</code></pre><p>编译器执行上述转换。在objc_msgSend函数中，首先通过obj的isa指针找到obj对应的class。每个对象内部都默认有一个isa指针指向这个对象所使用的类。isa是对象中的隐藏指针，指向创建这个对象的类。在Class中先去cache中通过SEL查找对应函数method（cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若cache中未找到,再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</p>
<h4 id="动态性的三方面"><a href="#动态性的三方面" class="headerlink" title="动态性的三方面"></a>动态性的三方面</h4><p>OC的动态特性表现为了三个方面：动态类型、动态绑定、动态加载。之所以叫做动态，是因为必须到运行时(runtime)才会做一些事情。</p>
<p>动态类型，就是id类型。动态类型是跟静态类型相对的。内置的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来（即前面说的静态输入）。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(runtime)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>
<p>动态语言和静态语言的一个区别是静态语言提前编译好文件，即所有的逻辑已在编译时确定，运行时直接加载编译后的文件；而动态语言是在运行时才确定实现。典型的静态语言是C＋＋，动态语言包括OC，JAVA，C#等；因为静态语言提前编译好了执行文件，也就是通常所说的静态语言效率较高的原因。</p>
<p>动态绑定(dynamic binding)需要用到@selector/SEL。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。</p>
<p>动态加载就是根据需求动态地加载资源，在运行时加载新类。在运行时创建一个新类,只需要3步:</p>
<p>1、为 class pair分配存储空间 ,使用 objc_allocateClassPair函数</p>
<p>2、增加需要的方法使用class_addMethod函数,增加实例变量用class_addIvar</p>
<p>3 、用objc_registerClassPair函数注册这个类,以便它能被别人使用。</p>
<h5 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h5><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP类似函数指针，指向具体的Method实现。</p>
<p>用 method_exchangeImplementations 来交换2个方法中的IMP，<br>用 class_replaceMethod 来修改类，<br>用 method_setImplementation 来直接设置某个方法的IMP，归根结底，都是偷换了selector的IMP。</p>
<h3 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h3><p>RunLoop是一让线程能随时处理事件但不退出的机制。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。一个runloop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。</p>
<p>RunLoop的四个作用为:使程序一直运行接受用户输入;决定程序在何时应该处理哪些Event;调用解耦;节省CPU时间。</p>
<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）。</p>
<p>主线程的runloop默认是启动的。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>NSRunLoop是一种更加高明的消息处理模式，在对消息处理过程进行了更好的抽象和封装，不用处理一些很琐碎很低层次的具体消息的处理，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使你的线程在有工作的时候工作，没有工作的时候休眠，可以大大节省系统资源。</p>
<p>对其它线程来说，runloop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。在任何一个Cocoa程序的线程中，都可以通过：</p>
<pre><code>NSRunLoop   *runloop = [NSRunLoop currentRunLoop];
</code></pre><p>获取到当前线程的runloop。</p>
<p>Cocoa中的NSRunLoop类并不是线程安全的<br>我们不能在一个线程中去操作另外一个线程的runloop对象，那很可能会造成意想不到的后果。但是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的runloop完全可以混合使用。Cocoa中的NSRunLoop类可以通过实例方法：</p>
<pre><code>- (CFRunLoopRef)getCFRunLoop;
</code></pre><p>获取对应的CFRunLoopRef类，来达到线程安全的目的。</p>
<p>Runloop的管理并不完全是自动的。我们仍必须设计线程代码以在适当的时候启动runloop并正确响应输入事件，当然前提是线程中需要用到runloop。而且，我们还需要使用while/for语句来驱动runloop能够循环运行，下面的代码就成功驱动了一个run loop：</p>
<pre><code>BOOL isRunning = NO;
do {
 isRunning = [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDatedistantFuture]];
} while (isRunning);
</code></pre><p>Runloop同时也负责autorelease pool的创建和释放<br>在使用手动的内存管理方式的项目中，会经常用到很多自动释放的对象，如果这些对象不能够被即时释放掉，会造成内存占用量急剧增大。Runloop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。</p>
<p><strong>系统默认注册了5个Mode:</strong></p>
<p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>
<p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>
<p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
<p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>
<p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>
<p><strong>轮播图中的NSTimer问题</strong><br>创建定时器：</p>
<pre><code>1：NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(changeImage) userInfo:nil repeats:YES];
</code></pre><p>此方法创建的定时器，必须加到NSRunLoop中。</p>
<pre><code>NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; 
[runLoop addTimer:timer forMode: NSRunLoopCommonModes];
</code></pre><p> forMode的参数有两种类型可供选择：<code> NSDefaultRunLoopMode ， NSRunLoopCommonModes</code>，第一个参数为默认参数，当下面有textView，textfield等控件时，拖拽控件，此时轮播器会停止轮播，是因为NSRunLoop的原因，NSRunLoop为一个死循环，实时监测有无事件响应，如果当前线程就是主线程，也就是UI线程时，某些UI事件，比如UIScrollView的拖动操作，会将Run Loop切换成NSEventTrackingRunLoopMode模式，在这个过程中，默认的NSDefaultRunLoopMode模式中注册的事件是不会被执行的。NSRunLoopCommonModes 能够在多线程中起作用，这个模式等效于NSDefaultRunLoopMode和NSEventTrackingRunLoopMode的结合，这也是将modes换为NSRunLoopCommonModes便可解决的原因。</p>
<pre><code>2： self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(changeImage) userInfo:nil repeats:YES];
</code></pre><p>此种创建定时器的方式，默认加到了runloop，且默认为第二个参数。</p>
<p><strong>main函数的运行</strong></p>
<p>在main.m中：</p>
<pre><code>int main(int argc, char *argv[])
{
   @autoreleasepool {
     return UIApplicationMain(argc, argv, nil, NSStringFromClass([appDelegate class]));
  }
}
</code></pre><p>UIApplicationMain() 函数会为main thread 设置一个NSRunLoop 对象，这就解释了app应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p>仅当在为你的程序创建辅助线程的时候，你才需要显式运行一个runloop。Runloop是程序主线程基础设施的关键部分,所以，Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runloop。IOS程序中UIApplication的run方法（或Mac OS X中的NSApplication）作为程序启动步骤的一部分，它在程序正常启动的时候就会启动程序的主循环。如果你使用xcode提供的模板创建你的程序，那你永远不需要自己去显式的调用这些例程。</p>
<p>对于辅助线程，你需要判断一个runloop是否是必须的。如果是必须的，那么你要自己配置并启动它。你不需要在任何情况下都去启动一个线程的runloop。比如，你使用线程来处理一个预先定义的长时间运行的任务时，你应该避免启动runloop。Runloop在你要和线程有更多的交互时才需要，比如以下情况：</p>
<p>1.使用端口或自定义输入源来和其他线程通信;</p>
<p>2.使用线程的定时器;</p>
<p>3.Cocoa中使用任何performSelector…的方法;</p>
<p>4.使线程周期性工作;</p>
<h3 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h3><p>对于IOS设备用户来说，操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：</p>
<p>1、触屏事件（Touch Event）</p>
<p>2、运动事件（Motion Event）</p>
<p>3、远端控制事件（Remote-Control Event）</p>
<p>事件的传递和响应分两个链：</p>
<p>传递链：由系统向离用户最近的view传递。</p>
<blockquote>
<p>UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view</p>
</blockquote>
<p>响应链：由离用户最近的view向系统传递。</p>
<blockquote>
<p>initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application</p>
</blockquote>
<p>响应者链（Responder Chain）:由多个响应者对象连接起来的链条，作用是能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</p>
<p>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。</p>
<p>UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。</p>
<p><strong>响应者链有以下特点：</strong></p>
<p>1、响应者链通常是由视图（UIView）构成的；</p>
<p>2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
<p>3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
<p>4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点；</p>
<p>5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
<p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用<code>hitTest:withEvent:</code>方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用<code>hitTest:withEvent:</code>，此方法会在其视图层级结构中的每个视图上调用<code>pointInside:withEvent:</code>（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果<code>pointInside:withEvent:</code>返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。</p>
<p><code>hitTest:withEvent:</code>方法的处理流程如下:</p>
<p>首先调用当前视图的<code>pointInside:withEvent:</code>方法判断触摸点是否在当前视图内；若返回NO,则<code>hitTest:withEvent:</code>返回nil;若返回YES,则向当前视图的所有子视图(subviews)发送<code>hitTest:withEvent:</code>消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则<code>hitTest:withEvent:</code>方法返回此对象，处理结束；如所有子视图都返回非，则<code>hitTest:withEvent:</code>方法返回自身(self)。</p>
<h3 id="引用计数器（ARC-和-MRC）"><a href="#引用计数器（ARC-和-MRC）" class="headerlink" title="引用计数器（ARC 和 MRC）"></a>引用计数器（ARC 和 MRC）</h3><p>ARC:自动引用计数器(Automatic Reference Counting)</p>
<p>MRC:手动引用计算器（由于现在几乎不用了，不做过多解说）</p>
<p>Objective-c中提供了两种内存管理机制MRC（MannulReference Counting）和ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。Xcode 4.1及其以前版本没有ARC。</p>
<p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain,release和autorelease。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease调用）的变量进行管理，当内存紧张时回收内存。<br>（1） retain，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;<br>（2） release，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;<br>（3） autorelease，该方法是将该对象内存的管理放到autoreleasepool中。</p>
<p>在ARC中与内存管理有关的标识符，可以分为变量标识符和属性标识符，对于变量默认为<code>__strong</code>，而对于属性默认为<code>unsafe_unretained</code>。也存在autoreleasepool。</p>
<p>其中assign/retain/copy与MRC下property的标识符意义相同，strong类似与retain,assign类似于<code>unsafe_unretained</code>，<code>strong/weak/unsafe_unretained</code>与ARC下变量标识符意义相同，只是一个用于属性的标识，一个用于变量的标识(带两个下划短线__)。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>app应用程序有5种状态：</strong></p>
<p>Not running未运行：程序没启动。</p>
<p>Inactive未激活：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</p>
<p>Active激活：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。</p>
<p>Backgroud后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<p>Suspended挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
<p>iOS的入口在main.m文件的main函数，根据UIApplicationMain函数，程序将进入AppDelegate.m，这个文件是xcode新建工程时自动生成的。AppDelegate.m文件，关乎着应用程序的生命周期。</p>
<p>1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。</p>
<p>2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。</p>
<p>3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。</p>
<p>4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。</p>
<p>5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。</p>
<p>6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。</p>
<p>初次启动：</p>
<p>iOS_didFinishLaunchingWithOptions</p>
<p>iOS_applicationDidBecomeActive</p>
<p>按下home键：</p>
<p>iOS_applicationWillResignActive</p>
<p>iOS_applicationDidEnterBackground</p>
<p>点击程序图标进入：</p>
<p>iOS_applicationWillEnterForeground</p>
<p>iOS_applicationDidBecomeActive</p>
<p>当应用程序进入后台时,应该保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死。释放尽可能释放的内存。</p>
<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
</code></pre><p>方法有大概5秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。</p>
<p>如果还需要长时间的运行任务，可以在该方法中调用</p>
<pre><code>[application beginBackgroundTaskWithExpirationHandler:^{ 

NSLog(@&quot;begin Background Task With Expiration Handler&quot;); 

}];
</code></pre><p>程序终止</p>
<p>程序只要符合以下情况之一，只要进入后台或挂起状态就会终止：</p>
<p>①iOS4.0以前的系统</p>
<p>②app是基于iOS4.0之前系统开发的。</p>
<p>③设备不支持多任务</p>
<p>④在Info.plist文件中，程序包含了 UIApplicationExitsOnSuspend 键。</p>
<p>系统常常是为其他app启动时由于内存不足而回收内存最后需要终止应用程序，但有时也会是由于app很长时间才响应而终止。如果app当时运行在后台并且没有暂停，系统会在应用程序终止之前调用app的代理的方法 <code>- (void)applicationWillTerminate:(UIApplication *)application</code>，这样可以让你可以做一些清理工作。你可以保存一些数据或app的状态。这个方法也有5秒钟的限制。超时后方法会返回程序从内存中清除。用户可以手工关闭应用程序。</p>
<h3 id="和其他动态语言的区别"><a href="#和其他动态语言的区别" class="headerlink" title="和其他动态语言的区别"></a>和其他动态语言的区别</h3><p>OC中方法的实现只能写在<code>@implementation··@end</code>中，对象方法的声明只能写在<code>@interface···@end</code>中间；对象方法都以-号开头，类方法都以+号开头；函数属于整个文件，可以写在文件中的任何位置，包括<code>@interface··@end</code>中，但写在<code>@interface···@end</code>会无法识别；</p>
<p>对象方法只能由对象来调用，类方法只能由类来调用，不能当做函数一样调用，对象方法归类\\对象所有；类方法调用不依赖于对象；类方法内部不能直接通过成员变量名访问对象的成员变量。OC只支持单继承，没有接口，但可以用delegate代替。</p>
<p>Objective-C与其他语言最大的区别是其运行时的动态性，它能让你在运行时为类添加方法或者去除方法以及使用反射。极大的方便了程序的扩展。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-103f66199e930d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OC的面向对象&lt;/li&gt;
&lt;li&gt;运行时Runtime&lt;/li&gt;
&lt;li&gt;运行循环RunLoop&lt;/li&gt;
&lt;li&gt;事件响应链&lt;/li&gt;
&lt;li&gt;引用计数&lt;/li&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;li&gt;与其他语言的区别&lt;/li&gt;
&lt;/u
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>iOS socket all in here</title>
    <link href="https://dangdangfeng.github.io/2014/05/31/iOS-socket-all-in-here/"/>
    <id>https://dangdangfeng.github.io/2014/05/31/iOS-socket-all-in-here/</id>
    <published>2014-05-30T16:49:55.000Z</published>
    <updated>2016-08-30T16:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接,UDP连接同理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-6b9392fad31b711d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket使用"></p>
<h4 id="socket使用的库函数"><a href="#socket使用的库函数" class="headerlink" title="socket使用的库函数"></a>socket使用的库函数</h4><p>1.创建套接字</p>
<pre><code>Socket(af,type,protocol)//建立地址和套接字的联系

bind(sockid, local addr, addrlen)//服务器端侦听客户端的请求

listen( Sockid ,quenlen)//建立服务器/客户端的连接 (面向连接TCP）
</code></pre><p>2.客户端请求连接</p>
<pre><code>Connect(sockid, destaddr, addrlen)//服务器端等待从编号为Sockid的Socket上接收客户连接请求

newsockid=accept(Sockid，Clientaddr, paddrlen)//发送/接收数据
</code></pre><p>3.面向连接：</p>
<pre><code>send(sockid, buff, bufflen) 
recv( )
</code></pre><p>4.面向无连接：</p>
<pre><code>sendto(sockid,buff,…,addrlen) 
recvfrom( )
</code></pre><p>5.释放套接字</p>
<pre><code>close(socked)
</code></pre><p>在iOS中以NSStream(流)来发送和接收数据,可以设置流的代理，对流状态的变化做出相应的动作(连接建立，接收到数据，连接关闭）。</p>
<p>NSStream：数据流的父类，用于定义抽象特性，例如：打开、关闭代理，NSStream继承自CFStream(CoreFoundation)<br>NSInputStream：NSStream的子类，用于读取输入<br>NSOutputStream：NSSTream的子类，用于写输出。</p>
<p>服务端先不提，客户端代码大概如下：</p>
<pre><code>//需要导入&lt;arpa/inet.h&gt;，&lt;netdb.h&gt;
- (void)test
{
NSString * host =@&quot;123.33.33.1&quot;;
NSNumber * port = @1233;

// 创建 socket
int socketFileDescriptor = socket(AF_INET, SOCK_STREAM, 0);
if (-1 == socketFileDescriptor) {
    NSLog(@&quot;创建失败&quot;);
    return;
}

// 获取 IP 地址 
struct hostent * remoteHostEnt = gethostbyname([host UTF8String]);
if (NULL == remoteHostEnt) {
    close(socketFileDescriptor);
     NSLog(@&quot;%@&quot;,@&quot;无法解析服务器的主机名&quot;);
    return;
}

struct in_addr * remoteInAddr = (struct in_addr *)remoteHostEnt-&gt;h_addr_list[0];

// 设置 socket 参数
struct sockaddr_in socketParameters;
socketParameters.sin_family = AF_INET;
socketParameters.sin_addr = *remoteInAddr;
socketParameters.sin_port = htons([port intValue]);

// 连接 socket
int ret = connect(socketFileDescriptor, (struct sockaddr *) &amp;socketParameters, sizeof(socketParameters));
if (-1 == ret) {
    close(socketFileDescriptor);
    NSLog(@&quot;连接失败&quot;);
    return;
}

NSLog(@&quot;连接成功&quot;);
}
</code></pre><p>大概就是这样，因为是C语言的，所以看起来不是很方便，一般开发中都会使用比较简单的方法，如下。</p>
<h4 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h4><p>iOS的socket实现是特别简单的，可以使用用github的开源类库<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">cocoaasyncsocket</a>简化开发，cocoaasyncsocket是支持tcp和ump的。代码大概如下：</p>
<pre><code>- (IBAction)connectToServer:(id)sender {
// 1.与服务器通过三次握手建立连接
NSString *host = @&quot;133.33.33.1&quot;;
int port = 1212;

//创建一个socket对象
_socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];

//连接
NSError *error = nil;
[_socket connectToHost:host onPort:port error:&amp;error];

if (error) {
    NSLog(@&quot;%@&quot;,error);
}
}


#pragma mark -socket的代理
#pragma mark 连接成功
-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port{
NSLog(@&quot;%s&quot;,__func__);
}


#pragma mark 断开连接
-(void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err{
if (err) {
    NSLog(@&quot;连接失败&quot;);
}else{
    NSLog(@&quot;正常断开&quot;);
}
}


#pragma mark 数据发送成功
-(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag{
NSLog(@&quot;%s&quot;,__func__);

//发送完数据手动读取，-1不设置超时
[sock readDataWithTimeout:-1 tag:tag];
}

#pragma mark 读取数据
-(void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag{
NSString *receiverStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
NSLog(@&quot;%s %@&quot;,__func__,receiverStr);
}
</code></pre><p>下面是原理补充，有兴趣的朋友可以细看。</p>
<hr>
<h4 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h4><p>网络七层协议由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。</p>
<p>HTTP协议对应于应用层，TCP协议对应于传输层，IP协议对应于网络层，HTTP协议是基于TCP连接的,三者本质上没有可比性。 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。<strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，是它的一组接口</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-1ceffddc43357839.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络七层协议"></p>
<h4 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h4><p>TCP/IP五层模型的协议分为：应用层、传输层、网络层、数据链路层和物理层。中继器、集线器、还有我们通常说的双绞线也工作在物理层；网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）在数据链路层；路由器、三层交换机在网络层；传输层主要是四层交换机、也有工作在四层的路由器。</p>
<p>TCP/IP协议中的应用层处理七层模型中的第五层、第六层和第七层的功能。TCP/IP协议中的传输层并不能总是保证在传输层可靠地传输数据包，而七层模型可以做到。TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-df46648a7fadfa42.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应关系"></p>
<blockquote>
<p>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。<br>TCP是一种流模式的协议，UDP是一种数据报模式的协议。</p>
</blockquote>
<p>在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层协议（HTTP、FTP、TELNET等），也可以自己定义应用层协议。</p>
<p>WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。<strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-fe177ff611c71d76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket的位置"></p>
<h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>建立起一个TCP连接需要经过“三次握手”：<br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>三次握手(Three-way Handshake)即建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换TCP 窗口大小信息。<strong>在socket编程中，客户端执行connect()时,将触发三次握手</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-a3120a20b9393a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p>
<p>TCP连接的拆除需要发送四个包，因此称为四次握手(four-way handshake)。在socket编程中，任何一方执行close()操作即可产生握手（有地方称为“挥手”）操作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-26cc9a86da3d9a68.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接的拆除"></p>
<p>之所以有“三次握手”和“四次握手”的区别，是因为连接时当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h4 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h4><p>HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>
<p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p><strong>HTTPS</strong>（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，是HTTP的安全版。 在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息。</p>
<p>https协议需要到ca申请证书；http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；http的连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-0601aab8deb7df8d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS"></p>
<h4 id="Socket连接与HTTP连接的不同"><a href="#Socket连接与HTTP连接的不同" class="headerlink" title="Socket连接与HTTP连接的不同"></a>Socket连接与HTTP连接的不同</h4><p><strong>通常情况下Socket连接就是TCP连接</strong>，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。&lt;/p&gt;
&lt;p&gt;多个TCP连接或多个应用程序进程可能需要通过同
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>优秀的团队该不该使用敏捷开发</title>
    <link href="https://dangdangfeng.github.io/2014/03/31/%E4%BC%98%E7%A7%80%E7%9A%84%E5%9B%A2%E9%98%9F%E8%AF%A5%E4%B8%8D%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>https://dangdangfeng.github.io/2014/03/31/优秀的团队该不该使用敏捷开发/</id>
    <published>2014-03-30T16:51:30.000Z</published>
    <updated>2016-08-30T16:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在CMM（能力成熟度模型Capability Maturity Model的缩写，是一种侧重于软件开发过程的管理及工程能力的提高与评估的开发模型）神话崩溃以后，敏捷开发逐渐引起了人们的关注，并被寄予厚望。下面我们就来谈一谈敏捷开发相关的一些知识。</p>
<h4 id="敏捷开发的起源"><a href="#敏捷开发的起源" class="headerlink" title="敏捷开发的起源"></a>敏捷开发的起源</h4><p>我们大部分人都学过瀑布开发模型，它是以文档为驱动的。因为在瀑布的整个开发过程中，开发人员根据需求文档进行开发，一切以文档为依据。敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法，是一种软件开发的流程，它会指导我们用规定的环节去一步一步完成项目的开发；而这种开发方式的主要驱动核心是人，注重的是人与人之间，面对面的交流；它只写有必要的文档，或尽量少写文档；采用的是迭代式开发。</p>
<p>敏捷开发提倡将一个完整的软件版本划分为多个迭代，每个迭代实现不同的特性。重大的、优先级高的特性优先实现，风险高的特性优先实现。在项目的早期就将软件的原型开发出来，并基于这个原型在后续的迭代不断完善。迭代开发的好处是：尽早编码，尽早暴露项目的技术风险。尽早使客户见到可运行的软件，并提出优化意见。可以分阶段提早向不同的客户交付可用的版本。</p>
<p>在每个迭代中，架构师负责将所有的特性分解成多个Story Card。每个Story可以视为一个独立的特性。每个Story应该可以在最多1个星期内完成开发，交付提前测试（Pre-Test）。当一个迭代中的所有Story开发完毕以后，测试组再进行完整的测试。在整个测试过程中（pre-test，test），基于Daily build，测试组永远都是每天从配置库上取下最新编译的版本进行测试，开发人员也随时修改测试人员提交的问题单，并合入配置库。</p>
<p>敏捷开发的一个特点是开放式办公，充分沟通，包括测试人员也和开发人员一起办公。基于Story Card的开发方式，团队会在开放式办公区域放置一块白板，上面粘贴着所有的Story Card，按当前的开发状态贴在4个区域中，分别是：未开发，开发中，预测试中，测试中。Story Card的开发人员和测试人员根据开发进度在Story Wall上移动Story Card，更新Story Card的状态。这种方式可以对项目开发进度有一个非常直观的了解。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-004aa1c1a3ae64b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Story Card"></p>
<h4 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h4><p>个体和交互 胜过 过程和工具<br>可以工作的软件 胜过 面面俱到的文档<br>客户合作 胜过 合同谈判<br>响应变化 胜过 遵循计划<br>虽然右项也有价值，但是我们认为左项具有更大的价值。</p>
<h4 id="敏捷开发的方式"><a href="#敏捷开发的方式" class="headerlink" title="敏捷开发的方式"></a>敏捷开发的方式</h4><p>敏捷开发作为一种指导思想或开发方式，Scrum和XP（Extreme Programming：极限编程）是敏捷开发的具体方式。Scrum和XP的区别是，Scrum偏重于过程，XP则偏重于实践，但是实际中，两者是结合一起应用的。</p>
<p><strong>Scrum方式</strong><br>Scrum的英文意思是橄榄球运动的一个专业术语，表示“争球”的动作；把一个开发流程的名字取名为Scrum，大家像打橄榄球一样迅速、富有战斗激情，运用该流程，你就能看到你团队高效的工作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-df04202048ac2aef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Scrum流程"></p>
<p>Scrum整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的建议长度是2到4周(互联网产品研发可以使用1周的Sprint)。在Scrum中，使用Product Backlog来管理产品的需求，Product backlog是一个按照商业价值排序的需求列表，Scrum团队总是先开发对客户具有较高价值的需求。在Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求进行开发。挑选的需求在Sprint计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为Sprint backlog。在每个迭代结束时，Scrum团队将递交潜在可交付的产品增量。Scrum 采用迭代、增量的方法来优化可预见性并控制风险。</p>
<p><strong>Scrum开发流程中的三大角色</strong></p>
<p><strong>产品负责人（Product Owner）</strong><br>主要负责确定产品的功能和达到要求的标准，指定软件的发布日期和交付的内容，同时有权力接受或拒绝开发团队的工作成果。</p>
<p><strong>流程管理员（Scrum Master）</strong><br>主要负责整个Scrum流程在项目中的顺利实施和进行，以及清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发。</p>
<p><strong>开发团队（Scrum Team）</strong><br>主要负责软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右，每个成员可能负责不同的技术方面，但要求每成员必须要有很强的自我管理能力，同时具有一定的表达能力；成员可以采用任何工作方式，只要能达到Sprint的目标。</p>
<p><strong>进行Scrum开发的流程</strong><br>1、我们首先需要确定一个Product Backlog（按优先顺序排列的一个产品需求列表），这个是由Product Owner 负责的；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-29a29687130c198c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Product Backlog"></p>
<p>2、Scrum Team根据Product Backlog列表，做工作量的预估和安排；</p>
<p>3、有了Product Backlog列表，我们需要通过 Sprint Planning Meeting（Sprint计划会议） 来从中挑选出一个Story作为本次迭代完成的目标，这个目标的时间周期是1~4个星期，然后把这个Story进行细化，形成一个Sprint Backlog；</p>
<p>4、Sprint Backlog是由Scrum Team去完成的，每个成员根据Sprint Backlog再细化成更小的任务（细到每个任务的工作量在2天内能完成）；<br><img src="http://upload-images.jianshu.io/upload_images/1170656-07a127f8cb0397f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务看板"><br>5、在Scrum Team完成计划会议上选出的Sprint Backlog过程中，需要进行 Daily Scrum Meeting（每日站立会议），每次会议控制在15分钟左右，每个人都必须发言，并且要向所有成员当面汇报你昨天完成了什么，并且向所有成员承诺你今天要完成什么，同时遇到不能解决的问题也可以提出，每个人回答完成后，要走到黑板前更新自己的 Sprint burn down（Sprint燃尽图）；<br><img src="http://upload-images.jianshu.io/upload_images/1170656-011cfb12ddf531b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每日站立会议"><br>6、做到每日集成，也就是每天都要有一个可以成功编译、并且可以演示的版本；很多人可能还没有用过自动化的每日集成，其实TFS就有这个功能，它可以支持每次有成员进行签入操作的时候，在服务器上自动获取最新版本，然后在服务器中编译，如果通过则马上再执行单元测试代码，如果也全部通过，则将该版本发布，这时一次正式的签入操作才保存到TFS中，中间有任何失败，都会用邮件通知项目管理人员；</p>
<p>7、当一个Story完成，也就是Sprint Backlog被完成，也就表示一次Sprint完成，这时，我们要进行 Srpint Review Meeting（演示会议），也称为评审会议，产品负责人和客户都要参加（最好本公司老板也参加），每一个Scrum Team的成员都要向他们演示自己完成的软件产品（这个会议非常重要，一定不能取消）；</p>
<p>8、最后就是 Sprint Retrospective Meeting（回顾会议），也称为总结会议，以轮流发言方式进行，每个人都要发言，总结并讨论改进的地方，放入下一轮Sprint的产品需求中；</p>
<h4 id="XP方式"><a href="#XP方式" class="headerlink" title="XP方式"></a>XP方式</h4><p>极限编程是一个轻量级的、灵巧的软件开发方法；同时它也是一个非常严谨和周密的方法。它的基础和价值观是交流、朴素、反馈和勇气；即，任何一个软件项目都可以从四个方面入手进行改善：加强交流；从简单做起；寻求反馈；勇于实事求是。XP是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-5c12b2fe0fe4e713.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="XP实践"><br><strong>XP的十三种核心实践</strong><br>团队协作(Whole Team)<br>规划策略(The Planning Game)；<br>结对编程(Pair programming)<br>测试驱动开发(Testing-Driven Development)<br>重构(Refactoring)<br>简单设计(Simple Design)<br>代码集体所有权(Collective Code Ownership)<br>持续集成(Continuous Integration)<br>客户测试(Customer Tests)<br>小型发布（Small Release）<br>每周40小时工作制（40-hour Week）<br>编码规范（Code Standards）<br>系统隐喻（System Metaphor）</p>
<p>关于规划策略：计划是持续的、循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。</p>
<p>关于测试驱动开发：编写单元测试是一个验证行为，更是一个设计行为。同样，它更是一种编写文档的行为。编写单元测试避免了相当数量的反馈循环，尤其是功功能能验证方面的反馈循环。程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。</p>
<p>关于隐喻：隐喻同体系结构是同义词，隐喻用于描述项目的全貌，Story用于描述个别具体的特征。隐喻是将整个系统联系在一起的全局视图；它是系统的未来影像，是它使得所有单独模块的位置和外观变得明显直观。如果模块的外观与整个隐喻不符，那么你就知道该模块是错误的</p>
<p>XP的一个成功因素是重视客户的反馈——开发的目的就是为了满足客户的需要。XP方法使开发人员始终都能自信地面对客户需求的变化。XP强调团队合作，经理、客户和开发人员都是开发团队中的一员。团队通过相互之间的充分交流和合作，使用XP这种简单但有效的方式，努力开发出高质量的软件。XP的设计简单而高效；程序员们通过测试获得客户反馈，并根据变化修改代码和设计，他们总是争取尽可能早地将软件交付给客户。XP程序员能够勇于面对需求和技术上的变化。</p>
<h4 id="什么是优秀团队"><a href="#什么是优秀团队" class="headerlink" title="什么是优秀团队"></a>什么是优秀团队</h4><p>有家公司的一个团队的一个项目用的是”敏捷开发方法”，而当时公司的理念恰恰是：开放、协作性强、扁平化团队，以用户为中心；和团队使用的敏捷方法理念正好相同，结果毫无悬疑的拿到了优秀团队奖。即使开发的项目并不是很成功，但公司需要一个团队来做榜样，来激励其他团队，而那里正好有这么一个团队。</p>
<p>如果做不了优秀的团队，那么就做一个典型的团队，公司需要这么一个做示范的话题。优秀的团队并不是拘泥于某种开发方式的，而是最适合某种方式的。希望您也能在一个优秀的团队。</p>
<p>孰好孰坏，因人而异了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在CMM（能力成熟度模型Capability Maturity Model的缩写，是一种侧重于软件开发过程的管理及工程能力的提高与评估的开发模型）神话崩溃以后，敏捷开发逐渐引起了人们的关注，并被寄予厚望。下面我们就来谈一谈敏捷开发相关的一些知识。&lt;/p&gt;
&lt;h4 id=&quot;敏
    
    </summary>
    
    
      <category term="skill" scheme="https://dangdangfeng.github.io/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>如何编写稳定流畅的iOS移动端应用</title>
    <link href="https://dangdangfeng.github.io/2013/12/01/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E7%A8%B3%E5%AE%9A%E6%B5%81%E7%95%85%E7%9A%84iOS%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    <id>https://dangdangfeng.github.io/2013/12/01/如何编写稳定流畅的iOS移动端应用/</id>
    <published>2013-11-30T16:53:32.000Z</published>
    <updated>2016-08-30T16:54:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不忘初心"><a href="#不忘初心" class="headerlink" title="不忘初心"></a>不忘初心</h4><p>在过去几年间，移动应用以雷霆之势席卷全球。我们在工作和休闲时间中使用互联网的方式，已经随着移动应用的前进脚步发生了变革。在开发应用的时候，人们也开始考虑“移动优先”的做法。我们正在面对全新一代的移动设备，诸如可穿戴设备或众多移动配件——正是它们构成了“万物互联”的世界。我们将面对全新的用户界面，通过它们数据展示及指令接收处理。同时，我们还将看到，越来越多的公司将真正地践行“移动优先”的思路。而在未来数年中，这一切都将影响我们设计、开发和测试软件的方式。</p>
<p>把一个客户端做得稳定、无奔溃、流畅，是写客户端朋友的梦想，但是，我们面临的结果往往是不如人意的。天下武功，唯快不破。很多公司都信奉这个教条。恨不得把app开发周期压缩到最低,这就导致了开发中隐藏了很多问题。有点经验的工程师草率的优化一下,更糟的情况是那些没有经验的工程师甚至不会对app进行任何优化，这将会使情况变的更糟。</p>
<p>十年前,移动设备的硬件资源是非常有限的.甚至连浮点数都是被禁止的.因为浮点数能导致计算的速度变慢。科技发展如此迅速的今天,硬件很大程度上可以弥补软件的短板。但是硬件的进步终究无法掩饰软件的不足，这也是写这篇文章的初心。</p>
<h4 id="移动端关注要点"><a href="#移动端关注要点" class="headerlink" title="移动端关注要点"></a>移动端关注要点</h4><p>在程序开发中，测试是必不可少的。移动端测试按大的类型划分可以分为白盒测试和黑盒测试。</p>
<p>白盒测试一般是由开发人员使用编码的方式进行。测试者需要接触程序的内部代码；而黑盒测试可以在不知道程序内部结构和代码的情况下进行。</p>
<p>下面是主要的测试流程了：<br>冒烟测试：在软件测试中，冒烟测试是指快速验证APP的主要功能（例如：微信的登陆、退出、发消息等功能） 。如果没有发现问题，再进行更加深入的测试工作；如果发现有问题，就说明APP有重大缺陷。</p>
<p>功能测试：功能测试也叫行为测试，需要根据测试用例来验证应用预期的功能有没有实现。</p>
<p>自由探索式测试：尝试边界条件、输入特殊符号、异常网络环境、突然中断程序等操作 。功能测试的目的是验证正常的功能有没有实现，而自由探索测试的目的就是为了试试应用在极端的操作下会不会出现问题。探索式测试就是要找到能让应用出错的操作。</p>
<p>回归测试：对之前使用我们的服务测试过的应用，将案例复测一遍。</p>
<p><strong>移动端关注的一些指标</strong><br>运行多少小时不崩溃；<br>多次打开页面，控制崩溃率；<br>界面优化，如何才能让用户不急躁、不烦躁；<br>服务器没有返回数据，是否会导致奔溃；<br>网络不好，数据来的太慢，界面是否不流畅；<br>从数据库读的数据太慢如何解决等。</p>
<p>移动端界面应该有自己的逻辑，需要网络数据的地方，应该有默认值，这样在网络数据没有返回的情况下，让用户有数据可以看到。收到的网络数据应该是通过某种方式刷新到界面，而不是等到数据返回才刷新页面。当没有网络数据的时候，界面应该可以自成一体，走的通流程，不强依赖网络数据。</p>
<p>在弱网模式下调试是我们必备的功力，因为我们要考虑用户的实施环境通常都不会很好。把经常使用的数据，存到缓存，提高APP的运行效率、界面流程度。同时，我们需要具备收集奔溃日志的功能，这样才能更好的减少崩溃，提高用户体验。</p>
<h4 id="界面卡顿产生的原因和解决方案"><a href="#界面卡顿产生的原因和解决方案" class="headerlink" title="界面卡顿产生的原因和解决方案"></a>界面卡顿产生的原因和解决方案</h4><p>iOS界面处理是在主线程下进行的，系统图形服务通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次刷新信号到来时显示到屏幕上。显示器通常以固定频率进行刷新，如果在一个刷新时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。</p>
<p>CPU 造成的资源消耗有以下几种：</p>
<ul>
<li>对象创建</li>
<li>对象调整</li>
<li>对象销毁</li>
<li>布局计算</li>
<li>Autolayout</li>
<li>文本计算</li>
<li>文本渲染</li>
<li>图片的绘制和解码</li>
</ul>
<p>GPU 资源消耗有下面几种情况：</p>
<ul>
<li>纹理的渲染</li>
<li>视图的混合 (Composing)</li>
<li>图形的生成等</li>
</ul>
<p>具体可以参考<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">这篇文章</a></p>
<h4 id="用-Instruments-来检验你的app"><a href="#用-Instruments-来检验你的app" class="headerlink" title="用 Instruments 来检验你的app"></a>用 Instruments 来检验你的app</h4><p><strong>时间事件查看器-Time Profiler</strong><br>在xcode的菜单中选择 product-&gt;Profile<br>我们会看到下面的界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-11be1e08fd9ed911.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Instruments"><br>点击Time Profiler进入。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-40bdb36ac65cdc9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Time Profiler"><br>下面我们来深究如下的控制面板：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-d6755d42a68acf4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制面板"></p>
<p>以下介绍下配置选项：</p>
<ol>
<li>Separate by Thread: 每个线程应该分开考虑。只有这样你才能揪出那些大量占用CPU的”重”线程。</li>
<li>Invert Call Tree: 从上倒下跟踪堆栈,这意味着你看到的表中的方法,将已从第0帧开始取样,这通常你是想要的,只有这样你才能看到CPU中话费时间最深的方法.也就是说FuncA{FunB{FunC}} 勾选此项后堆栈以C-&gt;B-A 把调用层级最深的C显示在最外面。</li>
<li>Hide System Libraries: 勾选此项你会显示你app的代码,这是非常有用的. 因为通常你只关心cpu花在自己代码上的时间不是系统上的。</li>
<li>Flatten Recursion: 递归函数, 每个堆栈跟踪一个条目。</li>
<li>Top Functions: 一个函数花费的时间直接在该函数中的总和，以及在函数调用该函数所花费的时间的总时间。因此，如果函数A调用B，那么A的时间报告在A花费的时间加上B.花费的时间,这非常真有用，因为它可以让你每次下到调用堆栈时挑最大的时间数字，归零在你最耗时的方法。</li>
</ol>
<p>找到Detail面板里最耗时的进程，点击进去可以看到代码，观察是否有异，如此便可逐步优化应用的运行效果了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-709a8715b9a6c191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改"></p>
<p>修改好后,在仪器重新运行该应用程序Product—Profile（或⌘I-记住，这些快捷键真的会为您节省一些时间）。<br><strong>分配工具</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-c1f214001adad7e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分配工具"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-e1619715fecd3f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击进入"></p>
<p>这个时候你会发现两个曲目。一个叫(分配)Allocations，以及一个被称为VM Tracker(虚拟机跟踪)。</p>
<p>内存泄漏有两种泄漏。第一个是真正的内存泄漏，一个对象尚未被释放，但是不再被引用的了。因此，存储器不能被重新使用。第二类泄漏是比较麻烦一些。这就是所谓的“无界内存增长”。这发生在内存继续分配，并永远不会有机会被释放。如果永远这样下去你的程序占用的内存会无限大,当超过一定内存的话 会被系统的看门狗给kill掉。</p>
<p>内存警告是ios处理app最好的方式，尤其是在内存越来越吃紧的时候,你需要清除一些内存。内存一直增长其实也不一定是你的代码出了问题,也有可能是UIKit 系统框架本身导致的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-a22007e5806c3b75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="尝试"><br>自己动手观察下，一切自然明了。</p>
<p><strong>内存泄露</strong><br>这一类泄漏是前面提到的 - 当一个对象不再被引用时出现的那种,检测泄漏可以理解为一个很复杂的事情，但泄漏的工具记得已分配的所有对象，通过定期扫描每个对象以确定是否有任何不能从任何其他对象访问的。</p>
<p>关闭仪器，回到Xcode和选择Product-&gt;Profile</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-46943f0933d55df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存泄露"></p>
<p>点击进入，运行：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-f69162d70c7f254a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行"></p>
<p>自己动手尝试下，找到右边面板里，如果有黑色标识的方法，进入看看。学习就是多尝试。</p>
<p>篇幅有限，更多的内容我们下次再聊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;不忘初心&quot;&gt;&lt;a href=&quot;#不忘初心&quot; class=&quot;headerlink&quot; title=&quot;不忘初心&quot;&gt;&lt;/a&gt;不忘初心&lt;/h4&gt;&lt;p&gt;在过去几年间，移动应用以雷霆之势席卷全球。我们在工作和休闲时间中使用互联网的方式，已经随着移动应用的前进脚步发生了变革。在开
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>从0开始看一个项目</title>
    <link href="https://dangdangfeng.github.io/2013/10/01/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9C%8B%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/"/>
    <id>https://dangdangfeng.github.io/2013/10/01/从0开始看一个项目/</id>
    <published>2013-10-01T02:40:37.000Z</published>
    <updated>2016-08-30T16:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在着手一个项目前<strong>先读文档</strong>（如果有文档的话）。尽管读了文档你不一定知道每一个代码的细节，但是如果你了解那个问题的话，你一定知道怎么写可以写出一个满足文档的内容。这个时候大脑里面就可以有个框架，先猜一猜，然后看代码，事半功倍。找不到好的文档，就看他的<strong>测试用例</strong>，也是有一样的功效的。因为测试都是从文档出发编写的，而不是从代码出发编写的。找不到文档和测试用例？那就直接Gank吧。</p>
<p><strong>读代码要层次化、带着问题去阅读</strong>。首先整体了解这个软件是干什么？解决什么问题？包含哪些大的模块，各个模块的作用是什么，各个模块的调用关系怎么样？然后对于每一个模块，这个模块是干什么的？为什么要有这个模块？这个模块怎么实现的？最后细化到每一个包，每一个类，每一个函数方法。从上到下，一一击破每一个问题，认真去<strong>思考</strong>他这样设计、写代码的好处，因为好的软件都会满足这种从抽象-&gt;具体的原则的。</p>
<p>在开始读具体代码前<strong>定位好所有要读的文件</strong>，知道他们的位置和名字，设计良好的工程光看工程的目录结构和文件名就能知道个大概功能了。事实上阅读代码的难易程度70%取决于代码书写的规范程度，写乱掉的代码，大师也读不懂。之后根据你对目录结构的理解确定文件阅读的顺序（我反正都是从main函数开始读的）。你最好对<strong>设计模式</strong>有一定了解，否则你读面向对象的code时会经常无法理解code为啥要弄得这么层层嵌套。阅读代码一个最重要的提升水平的地方就是理解好的代码如何合理使用设计模式。基本的阅读起点都会选择main函数或者类的构造函数。然后把自己想象成cpu执行程序那样去阅读你的代码。遇到需要跳转函数时，不要急于跳转，以了解函数功能和输入输出为目标，读代码最忌讳的是不抓结构抓细节，只见树木不见森林，<strong>比起某个函数具体功能来说对结构的全局把握更重要</strong>。功能了解清楚后继续跳回来（这里就可以区分代码写的优不优秀，优秀的代码光看函数名字就知道功能，连跳转都不用）。结构弄清楚了，知道程序怎么跑了，source code的精华你已经读了60%了，之后根据需要再对具体函数深入分析，到这里整个代码已经被你扒光了，没什么神秘了。</p>
<p>阅读代码有两种模式：<strong>top-down</strong> 和 <strong>bottom-up</strong>。Top-down 模式，就是先设定一个 use case，比如说打开一个文件。然后静态跟着代码看，或者用 debugger 跟着看。每次出现函数调用的时候，把函数的执行层次纪录下来。大致如下：</p>
<pre><code>func1( )
   func2(  )
       func(  )
   func3(  )
</code></pre><p>这种图表很随意，你可以根据自己的需要增加信息，可以把重要的「实际参数」一直标下来，画函数调用图，然后标注每个函数在干什么。不过这个图无法清楚地表明一个变量的轨迹，需要另外的图来标示变量的变化轨迹。要是想提高阅读代码的速度，归根结底要多读多写。熟悉程序的基本构成单元（例如循环、分支）的常见写法，各种lib, api的调用方式。这样阅读深层次代码不用再回头查形式参数到底指什么。这个图的基本作用是防止在阅读深层次代码时忘记总体执行层次。Top-down 模式进行到一定层次，往往会发现虽然图画了出来，但还是无法了解程序在干什么。这时需要转入 bottom-up 模式，一直深入到最底层，给能了解作用的底层函数一个一个的写文档。当然这时的文档是完全底层的观点。bottom-up的阅读方法，有时候会一头扎进去，出不来了。这种方式适合读一些比较优秀的开源项目的代码，也会很好地提高内功。然后就是不断在两个模式之间转换，不断的细化两种模式的理解。</p>
<p>最后，对于OC工程可以去GitHub找<a href="https://github.com/RuiAAPeres/UIViewController-Swizzled" target="_blank" rel="external">UIViewController-Swizzled</a>这个库，拉下来放到项目里，他有什么用呢？他可以把每个页面的类名打出来。而且有层次结构，也就是说你只需要打开项目点点点，就知道这个App运行的顺序了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-299eea93eaaceba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在着手一个项目前&lt;strong&gt;先读文档&lt;/strong&gt;（如果有文档的话）。尽管读了文档你不一定知道每一个代码的细节，但是如果你了解那个问题的话，你一定知道怎么写可以写出一个满足文档的内容。这个时候大脑里面就可以有个框架，先猜一猜，然后看代码，事半功倍。找不到好的文档，就
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS图像处理之UI,CG和CI</title>
    <link href="https://dangdangfeng.github.io/2013/08/31/iOS%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8BUI-CG%E5%92%8CCI/"/>
    <id>https://dangdangfeng.github.io/2013/08/31/iOS图像处理之UI-CG和CI/</id>
    <published>2013-08-30T16:35:38.000Z</published>
    <updated>2016-08-30T16:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UIImage-CGImage和CGImageRef释疑"><a href="#UIImage-CGImage和CGImageRef释疑" class="headerlink" title="UIImage,CGImage和CGImageRef释疑"></a>UIImage,CGImage和CGImageRef释疑</h4><p>UIImage虽然可以加载、显示各种格式的位图，甚至可以同时加载图片，接下来依次播放多张图片形成动画。但UIImage不能对图片进行缩放、旋转，不能”挖取”源图片的指定区域等，这些功能可借助Quartz 2D的CGImageRef来实现。UIImage与CGImageRef之间可以相互转换，CGImageRef并不是面向对象的API，也不是类，只是一个指针类型，Quartz 2D对CGImageRef的定义为：</p>
<pre><code>typedef struct CGImage *CGImageRef;
</code></pre><p>CGImage和CGImageRef是用来重绘图形的类，它们在应用时是按照图像的像素矩阵来绘制图片的，它们可以用来处理bitmap。</p>
<pre><code>//CGImageRef转换成UIImage
CGContextRef context = UIGraphicsGetCurrentContext();
CGImageRef ic = CGBitmapContextCreateImage(context);
UIImage* image = [UIImage imageWithCGImage: ic];

//UIImage转换成CGImageRef
UIImage *loadImage=[UIImage imageNamed:@&quot;c.png&quot;];
CGImageRef cgimage=loadImage.CGImage;
</code></pre><p>系统会维护一个CGContextRef的栈，而UIGraphicsGetCurrentContext()会取栈顶的CGContextRef，正确的做法是只在drawRect里调用UIGraphicsGetCurrentContext()，因为在drawRect之前，系统会往栈里面压入一个valid的CGContextRef，除非自己去维护一个CGContextRef，否则不应该在其他地方取CGContextRef。</p>
<h4 id="UIColor，CGColor，CIColor区别和联系"><a href="#UIColor，CGColor，CIColor区别和联系" class="headerlink" title="UIColor，CGColor，CIColor区别和联系"></a>UIColor，CGColor，CIColor区别和联系</h4><p>UIColor是UIKit中存储颜色信息的一个重要的类，一个UIColor对象包含了颜色和透明度的值，它的颜色空间已经针对iOS进行了优化。UIColor包含了一些类方法用于创建一些最常见的颜色，如白色，黑色，红色，透明色等，这些颜色的色彩空间也不尽相同（白色和黑色是kCGColorSpaceDeviceGray，红色的色彩空间是kCGColorSpaceDeviceRGB）。UIColor有两个重要的属性：一个是CGColor，一个是CIColor(5.0之后添加)。</p>
<p>CGColor主要用于CoreGaphics框架之中，CGColor其实是个结构体，而我们通常在使用的CGColor的时候使用的是它的引用类型CGColorRef。CGColor主要由CGColorSapce和Color Components两个部分组成，同样的颜色组成，如果颜色空间不同的话，解析出来的结果可能会有所不同。这就像我们在处理图片数据的时候，如果把RGBA格式当成BGRA格式处理的结果可想而知。在Quartz 2D中CGColor常用来设置context的填充颜色，设置透明度等。</p>
<p>CIColor主要用于和Core Image框架中其他类交互，比如CIFilter，CIContext以及CIImage。CIColor中颜色值的范围是0.0-1.0之间，0.0代表该颜色分量为最小值，1.0代表改颜色分量为最大值。其中alpha值的范围也是0.0到1.0之间，0.0代表全透明，1.0代表完全不透明，CIColor的颜色分量通常都是没有乘以alpha值。可以使用initWithCGColor:函数，通过CGColor创建一个CIColor。其中传入的CGColorRef对象可以使任何任何颜色空间，但是Core Image框架会在传入filter kernel之前把所有的颜色空间转换到Core Image工作颜色空间。Core Image工作颜色空间使用三个颜色分量加上一个alpha分量组成(其实就是kCGColorSpaceDeviceRGB)。</p>
<p>UIColor的CGColor总是有效的，不管它是通过CGColor，CIColor，还是其他方法创建的，CGColor属性都总是有效的；但是CIColor属性就不总是有效的，只有当UIColor是通过CIColor创建的时候，它才是有效的，否则访问该属性将会抛出异常。</p>
<pre><code>// test init uicolor with CGColor
UIColor *color = [UIColor colorWithCGColor:[UIColor whiteColor].CGColor];

// CGColor property is always valid
NSLog(@&quot;CGColor from UIColor %@&quot;, color.CGColor);

// don&apos;t use CIColor property 
// This property throws an exception if the color object was not initialized with a Core Image color. 
NSLog(@&quot;CIColor from UIColor %@&quot;, color.CIColor);   // crush
</code></pre><p>当UIColor使用CGColor初始化的时候，所有CGColorRef包含的信息，都会被原封不动的保留，其中就包括Color space，而且通过下面的小例子我们还可以看到如果使用CGColor初始化UIColor的时候，UIColor其实是直接保留了一份这个CGColorRef对象。</p>
<pre><code>// test kCGColorSpaceDeviceCMYK
CGColorSpaceRef cmykSpace = CGColorSpaceCreateDeviceCMYK();
CGFloat cmykValue[] = {1, 1, 0, 0, 1};      // blue
CGColorRef colorCMYK = CGColorCreate(cmykSpace, cmykValue);
CGColorSpaceRelease(cmykSpace);
NSLog(@&quot;colorCMYK: %@&quot;, colorCMYK);

// color with CGColor, uicolor will just retain it
UIColor *color = [UIColor colorWithCGColor:colorCMYK];
NSLog(@&quot;CGColor from UIColor: %@&quot;, color.CGColor);
</code></pre><p>当使用CIColor来初始化一个UIColor的时候，再去访问UIColor的CGColor属性的时候，我们会发现<strong>CGColor的color Space和设置CIColor的color space的是不完全一样的</strong>，在这个过程中CIColor会为我们做一个转换。使用kCGColorSpaceDeviceGray，kCGColorSpaceDeviceRGB，kCGColorSpaceDeviceCMYK三种颜色空间来初始化一个CIColor的时候，再去使用该CIColor去初始化一个UIColor，然后在去访问其CIColor属，CGColor属性，查看颜色空间并打印颜色信息。</p>
<p>1) 使用kCGColorSpaceDeviceGray初始化CIColor</p>
<pre><code>// test kCGColorSpaceDeviceGray
NSLog(@&quot;CGColor white color:%@&quot;, [UIColor whiteColor].CGColor);

CIColor *ciColor = [CIColor colorWithCGColor:[UIColor whiteColor].CGColor];
NSLog(@&quot;cicolor: %@&quot;, ciColor);
NSLog(@&quot;cicolor colorspace: %@&quot;, ciColor.colorSpace);

color = [UIColor colorWithCIColor:ciColor];
NSLog(@&quot;color %@&quot;, color);

// Core Image converts all color spaces to the Core Image working color 
// space before it passes the color space to the filter kernel.
// kCGColorSpaceDeviceGray ---&gt; kCGColorSpaceDeviceRGB
NSLog(@&quot;cicolor from UIColor: %@&quot;, color.CIColor);
NSLog(@&quot;cicolor&apos;s colorspace: %@&quot;, color.CIColor.colorSpace);
NSLog(@&quot;color&apos;s CGColor: %@&quot;, color.CGColor);
</code></pre><p>通过运行程序，我们看出来，如果使用一个kCGColorSpaceDeviceGray的颜色空间的CGColor来初始化CIColor的时候，我们可以看到CIColor的色彩空间一直是kCGColorSpaceDeviceGray，通过访问UIColor的CIColor属性，我们可以看到其颜色空间仍然是kCGColorSpaceDeviceGray，但是当访问UIColor的CGColor属性的时候，通过打印可以发现其色彩空间已经转变成了kCGColorSpaceDeviceRGB空间了，而颜色值也正确的从原来的颜色空间转换到了新的颜色空间。</p>
<p>2) 使用kCGColorSpaceDeviceRGB初始化CIColor</p>
<pre><code>//test kCGColorSpaceDeviceRGB
NSLog(@&quot;CGColor red color:%@&quot;, [UIColor redColor].CGColor);

CIColor *ciColor = [CIColor colorWithCGColor:[UIColor redColor].CGColor];
NSLog(@&quot;cicolor: %@&quot;, ciColor);
NSLog(@&quot;cicolor colorspace: %@&quot;, ciColor.colorSpace);

UIColor *color = [UIColor colorWithCIColor:ciColor];
NSLog(@&quot;color %@&quot;, color);

NSLog(@&quot;cicolor from UIColor: %@&quot;, color.CIColor);
NSLog(@&quot;cicolor&apos;s colorspace: %@&quot;, color.CIColor.colorSpace);
NSLog(@&quot;color&apos;s CGColor: %@&quot;, color.CGColor);
</code></pre><p>整个过程中CIColor，以及通过UIColor的CGColor和CIColor属性访问到的值，打印出来我们可以发现它们都是kCGColorSpaceDeviceRGB空间的。</p>
<p>3) 使用kCGColorSpaceDeviceCMYK初始化CIColor</p>
<pre><code>// test kCGColorSpaceDeviceCMYK
CGColorSpaceRef cmykSpace = CGColorSpaceCreateDeviceCMYK();
NSLog(@&quot;Components number: %zu&quot;, CGColorSpaceGetNumberOfComponents(cmykSpace));
CGFloat cmykValue[] = {1, 1, 0, 0, 1};      // blue
CGColorRef colorCMYK = CGColorCreate(cmykSpace, cmykValue);
CGColorSpaceRelease(cmykSpace);
NSLog(@&quot;colorCMYK: %@&quot;, colorCMYK);

ciColor = [CIColor colorWithCGColor:colorCMYK];
NSLog(@&quot;cicolor: %@&quot;, ciColor);     // in fact，the color value of CIColor has converted to RGB Colorspace
NSLog(@&quot;cicolor colorspace: %@&quot;, ciColor.colorSpace);

color = [UIColor colorWithCIColor:ciColor];
NSLog(@&quot;UIColor with CIColor: %@&quot;, color);

NSLog(@&quot;cicolor from UIColor: %@&quot;, color.CIColor);
NSLog(@&quot;cicolor&apos;s colorspace: %@&quot;, color.CIColor.colorSpace);

// when UIColor init with CIColor, UIColor&apos;s CGColor will convert other colorspace to kCGColorSpaceDeviceRGB
NSLog(@&quot;cgcolor from UIColor: %@&quot;, color.CGColor);
</code></pre><p>当我们用一个CMYK颜色空间的CGColor来初始化CIColor的时候，CIColor的颜色空间依然是CMYK，但是颜色值已经转换成RGB的颜色值。当使用该CIColor创建一个UIColor的时候，我们再通过CIColor和CGColor属性打印信息的时候，我们会发现CIColor的色彩空间依然是CMYK，但是CGColor打印所得到的信息说明它已经被转换成RGB空间了。</p>
<p><strong>关于创建一个CGColor</strong><br>最常用的函数是CGColorCreate，该函数有两个参数：</p>
<p>1) colorspace，指定CGColor对应的颜色空间，Quartz就会retain该对象，因此调用完之后你就可以安全的释放该对象。<br>2) components，一个CGFloat的数组，该数组的元素个数是指定色彩空间包含的颜色分量数n，加上对应的alpha值。　</p>
<p>该函数该返回一个新创建的CGColorRef，当我们不再使用该对象的时候使用CGColorRelease函数释放该对象。</p>
<p><strong>获取CGColor的数据</strong><br>在我们创建的时候传入两个重要的参数进去，当我们获取到了CGColorRef以后当然就可以拿到对应的ColorSpace以及Components。</p>
<p>1) 获取ColorSpace<br>通过CGColorGetColorSpace函数我们可以获取到当前CGColorRef对应的ColorSpace，该函数只接受一个参数就是你要获取ColorSpace的CGColorRef。</p>
<pre><code>CGColorRef cgColor = [UIColor redColor].CGColor;
CGColorSpaceRef colorSpace = CGColorGetColorSpace(cgColor);
NSLog(@&quot;color space: %@&quot;, colorSpace);
</code></pre><p>2) 获取Color Components<br>要获取到CGColorRef对应的颜色值，我们需要用到CGColorGetNumberOfComponents和CGColorGetComponents两个函数。我们先来看看两个函数的函数原型：</p>
<pre><code>size_t CGColorGetNumberOfComponents (
CGColorRef color
);

const CGFloat * CGColorGetComponents (
CGColorRef color
);
</code></pre><p>第一个函数是获得CGColorRef的中包含的颜色组成部分的个数，第二个函数就是获取实际的颜色组成部分的数组。</p>
<pre><code>NSUInteger num = CGColorGetNumberOfComponents(cgColor);
const CGFloat *colorComponents = CGColorGetComponents(cgColor);
for (int i = 0; i &lt; num; ++i) {
NSLog(@&quot;color components %d: %f&quot;, i, colorComponents[i]);
}
</code></pre><p><strong>判断两个颜色是否相等</strong><br>不管UIColor使用CIColor，CGColor还是其他方式初始化的，其CGColor属性都是可用的。CoreGraphics中提供一个方法可以判断两个CGColor是否相等，因此我们可以通过判断两个UIColor是否相等。</p>
<pre><code>// judge two CGColor is equal
if (CGColorEqualToColor([UIColor whiteColor].CGColor, [UIColor colorWithRed:1 green:1 blue:1 alpha:1].CGColor)) {
NSLog(@&quot;The two CGColor is equal!&quot;);
}
else {
NSLog(@&quot;The two CGColor is not equal!&quot;);
}

if (CGColorEqualToColor([UIColor colorWithRed:1 green:1 blue:1 alpha:1].CGColor, [UIColor colorWithRed:1 green:1 blue:1 alpha:1].CGColor)) {
NSLog(@&quot;The two CGColor is equal!&quot;);
}
else {
NSLog(@&quot;The two CGColor is not equal!&quot;);
}
</code></pre><p>例子中第一部分是判断两个白色的UIColor是否相等，虽然都是白色，但是颜色空间是不一样的。例子的第二部分简单的创建了两个RGB空间的UIColor，运行程序可以看出，这两种颜色是相同的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-f66427dbc02dea3c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;UIImage-CGImage和CGImageRef释疑&quot;&gt;&lt;a href=&quot;#UIImage-CGImage和CGImageRef释疑&quot; class=&quot;headerlink&quot; title=&quot;UIImage,CGImage和CGImageRef释疑&quot;&gt;&lt;/a&gt;UI
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>Cordova Source Code Analyse</title>
    <link href="https://dangdangfeng.github.io/2013/08/29/Cordova-Source-Code-Analyse/"/>
    <id>https://dangdangfeng.github.io/2013/08/29/Cordova-Source-Code-Analyse/</id>
    <published>2013-08-29T15:27:36.000Z</published>
    <updated>2016-08-30T15:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong><a href="http://cordova.apache.org" target="_blank" rel="external">官网</a></strong> (markdown下经常无法链接，地址在这： <a href="http://cordova.apache.org" target="_blank" rel="external">http://cordova.apache.org</a>)</p>
<h4 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h4><p><img src="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse/raw/master/Finder.png" alt=""></p>
<blockquote>
<p>目录文件说明：</p>
<p>conig.xml ：cordova的配置文件</p>
<p>hooks/ ：存放自定义cordova命令的脚本文件。</p>
<p>platforms/ ：各个平台原生工程代码，会在build时被覆盖勿修改</p>
<p>plugins/ ：插件目录（主要是提供各个平台的原生API）</p>
<p>www/ ：用H5编写的源代码目录，build时会被放入各个平台的assets\www目录。</p>
<p>www/index.html ：App入口html文件</p>
</blockquote>
<h4 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h4><p>JS端</p>
<ul>
<li>cordova_plugins.js 插件配置文件</li>
<li>exec.js 在cordova.js里复现，主要用于JS与Native的交互处理事件</li>
<li>platform.js 在cordova.js里复现，</li>
<li>cordova.js  JS端最重要的文件了。提供交互处理</li>
<li>index.html 关联 index.js,index.css UI显示</li>
</ul>
<p>Native端</p>
<ul>
<li>CDVPlugin 插件类，自定义插件继承于此</li>
<li>CDV 头文件</li>
<li>CDVAppDelegate 入口，在didFinishLaunchingWithOptions:里初始化CDVViewController</li>
<li>CDVAvaliability 宏定义</li>
<li>CDVAvailabilityDeprecated 弃用提示</li>
<li>CDVCommandDelegate 命令代理类，JS处理</li>
<li>CDVCommandDelegateImpl 代理类实现，处理JS</li>
<li>CDVCommandQueue 命令队列，对应于cordova.commandQueue队列</li>
<li>CDVConfigParser config文件解析（XML格式）</li>
<li>CDVUIWebViewEngine WebView处理机</li>
<li>CDVWebViewEngineProtocol WebView处理机代理类</li>
<li>CDVWhitelist 白名单（允許訪問任何網站）结合config.xml  <access> 元素</access></li>
<li>CDVScreenOrientaitionDelegate 屏幕方向处理</li>
<li>CDVLocalStorage 本地存储</li>
<li>CDVTimer 计时类</li>
<li>CDVUserAgentUtil 代理工具类</li>
<li>CDVURLProtocol 继承于NSURLProtocol.在 Objective-C 端使用一个 NSURLProtocol 的子类来检查每个请求</li>
<li>CDVInvokedUrlCommand js交互命令类（_callbackId;_className; _methodName;_arguments;）</li>
<li>CDVPluginResult 组件处理完后执行类</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>参见cordova.js 595-610行。</p>
<p>cordova的初始化包含JS端和Native端，这两端都是基于事件侦听的方式结合起来，JS端主要包含以下几个点：</p>
<p>onDOMContentLoaded：dom载入完成</p>
<p>onNativeReady：Native端WebUI载入完成</p>
<p>onCordovaReady：JS端相关objects都创建完成</p>
<p>onDeviceReady: Cordova 准备</p>
<p>onResume: 开始/恢复生命周期事件</p>
<p>onPause: 暂停生命周期 </p>
<p><strong>Cordova生命周期事件：</strong></p>
<p>（1）deviceready ：当Cordova加载完成会触发</p>
<p>（2）pause：当应用程序进入到后台会触发</p>
<p>（3）resumes：应用程序从后台进入到前台会触发</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
        //页面加载后添加各事件监听
        function onLoad() {
            document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false);
            document.addEventListener(&quot;resume&quot;, onResume, false);
            document.addEventListener(&quot;pause&quot;, onPause, false);
        }

        //Cordova加载完毕
        function onDeviceReady() {
            alert(&quot;Cordova加载完毕！&quot;);
        }

        //进入后台
        function onPause() {
            console.log(&quot;应用进入到后台！&quot;);
        }

        //恢复到前台
        function onResume() {
            alert(&quot;应用回到前台运行！&quot;);
        }
 &lt;/script&gt;
</code></pre><p>以上几个重要事件的先后顺序和hander侦听是通过channel组件架构，所谓的channel组件实际上就是cordova自制的保障事件侦听和触发的组件,具体代码参考cordova.js 626-820行。2百多行代码，就打造了一个JS端事件侦听的框架。</p>
<p>其中 onNativeReady是被native端调的，当native端WebUI初始化好后就会fire JS端onNativeReady事件，native有以下几个关键的初始化节点：</p>
<pre><code>AppDelegate.didFinishLaunchingWithOptions：App启动，初始化controller和view
CDVViewController.viewDidLoad：view加载，初始化WebView
CDVViewController.webviewDidFinishLoad：WebView加载，触发JS端onNativeReady
</code></pre><p>Native端存在着App-&gt;view-&gt;webview三个层次，以上三个点正好对应着这三个层次的加载。</p>
<p><img src="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse/raw/master/cordova.png" alt=""></p>
<h4 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h4><p>从源码可以看出AppDelegate继承于CDVAppDelegate;MainViewController继承于CDVViewController。MainCommandDelegate继承于CDVCommandDelegateImpl,MainCommandQueue继承于CDVCommandQueue.</p>
<p>AppDelegate是程序的入口，由此调用MainViewController,由此启动CDVViewController.</p>
<ol>
<li>AppDelegate的application:didFinishLaunchingWithOptions:进入</li>
<li>从self.viewController = [[MainViewController alloc] init]；到MainViewController.</li>
<li>CDVViewController 进入init方法</li>
<li>initWithNibName: bundle:方法调用[self __init]</li>
<li>__init方法监听通知，UIApplicationWillTerminateNotification（程序被杀死），UIApplicationWillResignActiveNotification（从活动状态进入非活动状态），UIApplicationDidBecomeActiveNotification（程序进入前台并处于活动状态），UIApplicationWillEnterForegroundNotification（进入前台，还没有处于活动状态时），UIApplicationDidEnterBackgroundNotification（进入后台）。在应用处于各种状态时就可以通过evalJs：方法与JS端交互。最终是通过CDVUIWebViewEngine下的evaluateJavaScript: completionHandler:的方法。最终还是用的UIWebView的stringByEvaluatingJavaScriptFromString:方法。从此可以看出，Native处理JS原理上还是用的UIWebView的方法。CDVViewController初始化完成。</li>
<li>此时AppDelegate调用Super,进入CDVAppDelegate的application: didFinishLaunchingWithOptions:方法。对rootViewController，主window进行设置。此时App才加载MainViewController.走MainViewController生命周期。</li>
<li>在MainViewController里其实是调用CDVViewController的。进入viewDidLoad方法，在loadSettings里加载配置文件并将index.html设为startPage。</li>
<li>createGapVeiw初始化webView,通过CDVWebViewEngineProtocol使用CDVUIWebViewEngine使用engineWebView（这是个UIWebView）处理JS。</li>
<li>registerPlugin: withClassName:初始化插件，此处的插件是CDVUIWebViewEngine。</li>
<li>将handleopenurl,intentandnavigationfilter,gesturehandler插件注入。计时结束。</li>
<li>CDVUserAgentUtil acquireLock:加锁处理，加载index.html</li>
<li>当App进入活跃状态，接收到通知进入onAppDidBecomeActive:方法，执行JS的active事件。js为</li>
</ol>
<pre><code>&lt;code&gt;try{cordova.require(&apos;cordova/exec&apos;).nativeEvalAndFetch(function(){cordova.fireDocumentEvent(&apos;active&apos;);})}catch(e){console.log(&apos;exception nativeEvalAndFetch : &apos;+e);};&lt;/code&gt;
</code></pre><p>   如此就和cordova.js发生了联系。</p>
<ol>
<li>此后WebView开始加载，并触发了CDVUIWebViewDelegate的webView: shouldStartLoadWithRequest: navigationType:方法。如果_delegate实现了webView:shouldStartLoadWithRequest:navigationType:此时会进入CDVUIWebViewNavigationDelegate。在此判断url的scheme是否为gap(处理加载页里的加载请求)。</li>
<li>CDVIntentAndNavigationFilter实现了shouldOverrideLoadWithRequest:navigationType:方法，根据navigationType返回是否请求加载。</li>
<li>允许加载后，走CDVUIWebViewDelegate的webViewDidStartLoad:方法。跳到CDVUIWebViewNavigationDelegate的webViewDidStartLoad:向enginePlugin.webView发送CDVPluginResetNotification通知。但是CDVUIWebViewEngine没有对onReset处理。其他插件根据需要处理。</li>
<li>然后走CDVUiWebViewDelegate的webViewDidFinishLoad:方法。跳转CDVUIWebViewNavigationDelegate的webViewDidFinishLoad：方法。发送CDVPageDidLoadNotification通知。此版本未处理。</li>
<li>iframe bridge 在 JS 端创建一个透明的 iframe，设置这个 ifame 的 src 为自定义的协议，而 ifame 的 src 更改时，UIWebView 会先回调其 delegate 的 webView:shouldStartLoadWithRequest:navigationType: 方法。此时又到了CDVUIWebViewDelegate的shouldStartLoadWithRequest：方法。此时的请求是gap://ready。</li>
<li>CDVViewController的supportedInterfaceOrientations监听App的屏幕显示，是否左转右转等。</li>
<li>到此，页面加载完毕。</li>
</ol>
<h4 id="JS调用Native"><a href="#JS调用Native" class="headerlink" title="JS调用Native"></a>JS调用Native</h4><p>IOS的UIWebViewDelegate提供了shouldStartLoadWithRequest方法，它能截获web端url请求，因此phonegap就是通过在web端构造一个不可见的iframe，并置其src为gap://ready，Native端截获这个请求后就会得知此时JS端有请求。这块代码可见”cordova/exec”模块：</p>
<pre><code>function pokeNative() {
// CB-5488 - Don&apos;t attempt to create iframe before document.body is available.
if (!document.body) {
    setTimeout(pokeNative);
    return;
}

// Check if they&apos;ve removed it from the DOM, and put it back if so.
if (execIframe &amp;&amp; execIframe.contentWindow) {
    execIframe.contentWindow.location = &apos;gap://ready&apos;;
} else {
    execIframe = document.createElement(&apos;iframe&apos;);
    execIframe.style.display = &apos;none&apos;;
    execIframe.src = &apos;gap://ready&apos;;
    document.body.appendChild(execIframe);
}
// Use a timer to protect against iframe being unloaded during the poke (CB-7735).
// This makes the bridge ~ 7% slower, but works around the poke getting lost
// when the iframe is removed from the DOM.
// An onunload listener could be used in the case where the iframe has just been
// created, but since unload events fire only once, it doesn&apos;t work in the normal
// case of iframe reuse (where unload will have already fired due to the attempted
// navigation of the page).
failSafeTimerId = setTimeout(function() {
    if (commandQueue.length) {
        // CB-10106 - flush the queue on bridge change
        if (!handleBridgeChange()) {
            pokeNative();
         }
    }
}, 50); // Making this &gt; 0 improves performance (marginally) in the normal case (where it doesn&apos;t fire).
}
</code></pre><p>每次在js端调用exec时，cordova会把调用信息放入commandQueue队列中，并通知native端。native端得到通知后，会调用js端的代码拿到commandQueue队列中所有调用信息，并依次调用plugin来执行请求</p>
<pre><code>function iOSExec() {

var successCallback, failCallback, service, action, actionArgs;
var callbackId = null;
if (typeof arguments[0] !== &apos;string&apos;) {
    // FORMAT ONE
    successCallback = arguments[0];
    failCallback = arguments[1];
    service = arguments[2];
    action = arguments[3];
    actionArgs = arguments[4];

    // Since we need to maintain backwards compatibility, we have to pass
    // an invalid callbackId even if no callback was provided since plugins
    // will be expecting it. The Cordova.exec() implementation allocates
    // an invalid callbackId and passes it even if no callbacks were given.
    callbackId = &apos;INVALID&apos;;
} else {
    throw new Error(&apos;The old format of this exec call has been removed (deprecated since 2.1). Change to: &apos; +
        &apos;cordova.exec(null, null, \&apos;Service\&apos;, \&apos;action\&apos;, [ arg1, arg2 ]);&apos;
    );
}

// If actionArgs is not provided, default to an empty array
actionArgs = actionArgs || [];

// Register the callbacks and add the callbackId to the positional
// arguments if given.
if (successCallback || failCallback) {
    callbackId = service + cordova.callbackId++;
    cordova.callbacks[callbackId] =
        {success:successCallback, fail:failCallback};
}

actionArgs = massageArgsJsToNative(actionArgs);

var command = [callbackId, service, action, actionArgs];

// Stringify and queue the command. We stringify to command now to
// effectively clone the command arguments in case they are mutated before
// the command is executed.
commandQueue.push(JSON.stringify(command));

// If we&apos;re in the context of a stringByEvaluatingJavaScriptFromString call,
// then the queue will be flushed when it returns; no need for a poke.
// Also, if there is already a command in the queue, then we&apos;ve already
// poked the native side, so there is no reason to do so again.
if (!isInContextOfEvalJs &amp;&amp; commandQueue.length == 1) {
    pokeNative();
}
}
</code></pre><p>Native端：shouldStartLoadWithRequest</p>
<pre><code>if ([[url scheme] isEqualToString:@&quot;gap&quot;]) {
    [vc.commandQueue fetchCommandsFromJs];
    // The delegate is called asynchronously in this case, so we don&apos;t have to use
    // flushCommandQueueWithDelayedJs (setTimeout(0)) as we do with hash changes.
    [vc.commandQueue executePending];
    return NO;
}
</code></pre><hr>
<pre><code> // 获取 JS 的请求数据
- (void)fetchCommandsFromJs
{
__weak CDVCommandQueue* weakSelf = self;
NSString* js = @&quot;cordova.require(&apos;cordova/exec&apos;).nativeFetchMessages()&quot;;

[_viewController.webViewEngine evaluateJavaScript:js
                                completionHandler:^(id obj, NSError* error) {
    if ((error == nil) &amp;&amp; [obj isKindOfClass:[NSString class]]) {
        NSString* queuedCommandsJSON = (NSString*)obj;
        CDV_EXEC_LOG(@&quot;Exec: Flushed JS-&gt;native queue (hadCommands=%d).&quot;, [queuedCommandsJSON length] &gt; 0);
        [weakSelf enqueueCommandBatch:queuedCommandsJSON];
        // this has to be called here now, because fetchCommandsFromJs is now async (previously: synchronous)
        [self executePending];
    }
}];
}

- (void)executePending
{
// Make us re-entrant-safe.
if (_startExecutionTime &gt; 0) {
    return;
}
@try {
    _startExecutionTime = [NSDate timeIntervalSinceReferenceDate];

    while ([_queue count] &gt; 0) {
        NSMutableArray* commandBatchHolder = _queue[0];
        NSMutableArray* commandBatch = nil;
        @synchronized(commandBatchHolder) {
            // If the next-up command is still being decoded, wait for it.
            if ([commandBatchHolder count] == 0) {
                break;
            }
            commandBatch = commandBatchHolder[0];
        }

        while ([commandBatch count] &gt; 0) {
            @autoreleasepool {
                // Execute the commands one-at-a-time.
                NSArray* jsonEntry = [commandBatch cdv_dequeue];
                if ([commandBatch count] == 0) {
                    [_queue removeObjectAtIndex:0];
                }
                CDVInvokedUrlCommand* command = [CDVInvokedUrlCommand commandFromJson:jsonEntry];
                CDV_EXEC_LOG(@&quot;Exec(%@): Calling %@.%@&quot;, command.callbackId, command.className, command.methodName);

                if (![self execute:command]) {
#ifdef DEBUG
                        NSString* commandJson = [jsonEntry cdv_JSONString];
                        static NSUInteger maxLogLength = 1024;
                        NSString* commandString = ([commandJson length] &gt; maxLogLength) ?
                            [NSString stringWithFormat : @&quot;%@[...]&quot;, [commandJson substringToIndex:maxLogLength]] :
                            commandJson;

                        DLog(@&quot;FAILED pluginJSON = %@&quot;, commandString);
#endif
                }
            }

            // Yield if we&apos;re taking too long.
            if (([_queue count] &gt; 0) &amp;&amp; ([NSDate timeIntervalSinceReferenceDate] - _startExecutionTime &gt; MAX_EXECUTION_TIME)) {
                [self performSelector:@selector(executePending) withObject:nil afterDelay:0];
                return;
            }
        }
    }
} @finally
{
    _startExecutionTime = 0;
}
}
</code></pre><p>在CDVCommandQueue里的execute:方法里用objc_msgSend执行JS里需要的方法。</p>
<h4 id="Native向JS返回结果"><a href="#Native向JS返回结果" class="headerlink" title="Native向JS返回结果"></a>Native向JS返回结果</h4><p>使用webView的 stringByEvaluatingJavaScriptFromString 方法 。native的plugin完成任务后，会在CDVPluginResult里执行initWithStatus:(CDVCommandStatus)statusOrdinal message:(id)theMessage；在CDVCommandDelegateImpl里执行sendPluginResult:(CDVPluginResult<em>)result callbackId:(NSString</em>)callbackId；返回结果给JS端。<br>通过上面，我们知道JS和Native是通过callbackId对应的，由此就建立了连接。</p>
<pre><code>// Objective-C 返回结果给JS端
- (void)sendPluginResult:(CDVPluginResult*)result callbackId:(NSString*)callbackId
{
CDV_EXEC_LOG(@&quot;Exec(%@): Sending result. Status=%@&quot;, callbackId, result.status);
// This occurs when there is are no win/fail callbacks for the call.
if ([@&quot;INVALID&quot; isEqualToString:callbackId]) {
    return;
}
// This occurs when the callback id is malformed.
if (![self isValidCallbackId:callbackId]) {
    NSLog(@&quot;Invalid callback id received by sendPluginResult&quot;);
    return;
}
int status = [result.status intValue];
BOOL keepCallback = [result.keepCallback boolValue];
NSString* argumentsAsJSON = [result argumentsAsJSON];
BOOL debug = NO;

#ifdef DEBUG
debug = YES;
#endif
 // 将请求的处理结果及 callbackId 通过调用 JS 方法返回给 JS 端
NSString* js = [NSString stringWithFormat:@&quot;cordova.require(&apos;cordova/exec&apos;).nativeCallback(&apos;%@&apos;,%d,%@,%d, %d)&quot;, callbackId, status, argumentsAsJSON, keepCallback, debug];

[self evalJsHelper:js];
}
</code></pre><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><p>此处我们默认已经解决了插件的下载和制作。所要做的就是处理插件。</p>
<p>将CordovaLib引入项目。</p>
<p>在配置页的 Build Settings -&gt; Other Linker Flags 中添加”-ObjC -all_load”</p>
<p>在配置页的 Build Phases 标签中添加如下两个库：</p>
<pre><code>Target Dependencies -&gt; CordovaLib

Link Binary With Libraries -&gt; libCordova.a
</code></pre><p>  <strong><a href="http://www.hangge.com/blog_uploads/201604/2016042214355230378.zip" target="_blank" rel="external">测试</a></strong></p>
<p>最主要关注的是Hybrid里的跳转逻辑，用scheme跳转解决。在CDVUIWebViewNagigationDelegate 里的shouldStartLoadWithRequest：里实现自己的跳转逻辑即可，因为在cordova里触发跳转，肯定会走这里的。如果实现了CDVWKWebViewEngine,在webView: webView: decidePolicyForNavigationAction: decisionHandler: 里也要实现.</p>
<p>其他的都是套路。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;&lt;a href=&quot;http://cordova.apache.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;/strong&gt; (markdown下经常无法链接，地址在这： &lt;a href=&quot;http://cordo
    
    </summary>
    
    
      <category term="Source" scheme="https://dangdangfeng.github.io/tags/Source/"/>
    
  </entry>
  
  <entry>
    <title>人生不可错过的5本书</title>
    <link href="https://dangdangfeng.github.io/2012/08/31/%E4%BA%BA%E7%94%9F%E4%B8%8D%E5%8F%AF%E9%94%99%E8%BF%87%E7%9A%845%E6%9C%AC%E4%B9%A6/"/>
    <id>https://dangdangfeng.github.io/2012/08/31/人生不可错过的5本书/</id>
    <published>2012-08-31T01:39:18.000Z</published>
    <updated>2016-08-30T16:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哥德尔、艾舍尔、巴赫书：集异璧之大成"><a href="#哥德尔、艾舍尔、巴赫书：集异璧之大成" class="headerlink" title="哥德尔、艾舍尔、巴赫书：集异璧之大成"></a>哥德尔、艾舍尔、巴赫书：集异璧之大成</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-be18fef26ba9f136.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="哥德尔、艾舍尔、巴赫书：集异璧之大成"></p>
<p>这是一本超过千页的大书，其翻译为中文的过程亦甚为坎坷。此中文版本采用了移译的翻译手法，将许多陌生的名词中国化了，所以初次阅读之体验可谓兴致盎然。巴赫、艾舍尔、哥德尔，三者的成果即为音乐、画作、逻辑（数理逻辑）上的三个怪圈，恰似原书的封面那样，投影不一，但其实内在的实质是一样的。巴赫的音符在重复中，一面唱出主题，一面扮演和声；艾舍尔的阶梯，一面无限上升，另一面无尽下降；哥德尔的不完备定理，一面作为数理逻辑的内容存在，一面作为评价数理逻辑的存在。《哥德尔、艾舍尔、巴赫书：集异璧之大成》是在英语世界中有极高评价的科普著作，曾获得普利策文学奖。它通过对哥德尔的数理逻辑，艾舍尔的版画和巴赫的音乐三者的综合阐述，引人入胜地介绍了数理逻辑学、可计算理论、人工智能学、语言学、遗传学、音乐、绘画的理论等方面，构思精巧、含义深刻、视野广阔、富于哲学韵味。</p>
<p>关于这本书，确实只有“奇书”两个字可以形容。</p>
<p>书籍地址：<a href="http://item.jd.com/11495462.html" target="_blank" rel="external">《哥德尔、艾舍尔、巴赫书：集异璧之大成》</a></p>
<h4 id="禅与摩托车维修艺术"><a href="#禅与摩托车维修艺术" class="headerlink" title="禅与摩托车维修艺术"></a>禅与摩托车维修艺术</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-aedc5cb86ba95320.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="禅与摩托车维修艺术"></p>
<p> Pirsig说,要把工作变为艺术,选择良质。在所有关乎技艺方面的工作，背后都有一个“道”或类似于“禅”的东西，一通百通。有时，你就得放弃已有的工匠情结，更多地要把自己的理念，思想都揉合在一个物件上，这时技术只是一个副产品罢了。本书探讨了有关摩托车修理艺术，禅，宗教，自然科学，教育，哲学，数学，个人修行。中间透露的对生命直相、生存本质的看法，优美、简洁而动人。不光研究形而上,思考人生意义的人可以读,而且从实用主义的角度看, 对技术人员(不光是软件开发人员)甚至任何有工作的人都有很大的启发作用。本书在美国及世界十余个国家已被当做新时代的经典之作，本书曾被“Time”为70年代十本最有影响力的书之一。</p>
<p>书籍地址：<a href="http://item.jd.com/10839490.html" target="_blank" rel="external">《禅与摩托车维修艺术》</a></p>
<h4 id="编程人生"><a href="#编程人生" class="headerlink" title="编程人生"></a>编程人生</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-2f2bffc58eaef600.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编程人生"></p>
<blockquote>
<p>Seibel: 不精通技术却擅长团队协调的人，能成为好的管理者吗？<br> Allen: 这不是不可能，不过他得首先承认自己并不精通技术，其次还要能分辨团队中谁擅长技术，谁不擅长技术。</p>
</blockquote>
<p>它并不是一本技术人士的八卦图书。书里面讨论的更多的是编程的习惯，对当今程序设计方法或是程序设计语言的讨论，以及这些编程大牛在成为大牛的过程中的各种经历。很多东西都值得程序员或者是有志学习计算机科学的人借鉴。这本书最大的益处就是帮助广大程序员了解大师是怎么成长过来的，学习他们的宝贵经验。大师的成长经历都隐含了一个基本规律：他们都是编程至少十几二十年以上才最终成为大师的，“十年学会编程”并不是什么天方夜谭，而是确确实实的事情！同理，任何人如果想要成为大师（或者至少是杰出的程序员），那么他首先要做的就是打好基本功。但是，算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。</p>
<p>书籍地址：[《编程人生》](<a href="http://item.jd.com/11584262.html" target="_blank" rel="external">http://item.jd.com/11584262.html</a></p>
<h4 id="别闹了，费曼先生"><a href="#别闹了，费曼先生" class="headerlink" title="别闹了，费曼先生"></a>别闹了，费曼先生</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-88f55c486ab4207e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="别闹了，费曼先生"></p>
<blockquote>
<p>一本理科生写给世界的情书。——和菜头</p>
</blockquote>
<p>费曼得过诺贝尔奖，是现代最伟大的理论物理学家之一。但他同时也可能是历史上唯一被按摩院请去画裸体画、偷偷打开放着原子弹机密文件的保险箱，在巴西桑巴乐团担任鼓手的科学家。他曾跟爱因斯坦和波尔等大师讨论物理问题，也曾在赌城跟职业赌徒研究输赢机率。这是费曼对世界和人生看法的总结，不是世界创造了费曼，而是费曼如此理解和对待世界，因此而有了这么一个非常独特的人。他满不在乎地活在这个世界上，靠追逐他的兴趣而指引生活的方向。如同他年幼时自己发明了一套三角函数符号一样，他对世界也有自己的一套符号。所以，大家都在意的事物他未必在意，大家不在意的事物他却穷追不舍。他也爱着这个世界，但是是用他的方式。所以他能在物理之外发现生活中诸多的乐趣和美来，所以不是人人都会到巴西讲学时跑去街头学敲鼓，而且获得了佳年华会的冠军乐队。所以不是人人都会去学绘画，然后还愿意让别人买去挂在妓院的墙上。如孩子一样的眼睛，如孩子一样的好奇心，因此世界以奇迹还赠他，于一生中成就别人的无数生，使得他周围人在失去他时如同整个世界都黯然失色。</p>
<p>书籍地址：<a href="http://item.jd.com/16012346.html" target="_blank" rel="external">《别闹了，费曼先生》</a></p>
<h4 id="程序员修炼之道"><a href="#程序员修炼之道" class="headerlink" title="程序员修炼之道"></a>程序员修炼之道</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-03d2d3f3a11fb52c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序员修炼之道"><br>一般来说，刚刚接触编程的人，更倾向于从具体的程序代码学习编程的理念，而不是从程序设计理论书籍去理解编程的概念。就像学习英语，在刚开始的时候，最重要的是扩大自己的阅读量和词汇量，而不是“钻研”各种奇淫技巧。所以，计算机编程的入门书籍里都包含了大量的示例代码片段，初学者通过模仿这些代码，在心里逐步建立起一个属于自己的程序设计模型。这是程序设计的第一个阶段，也就是入门阶段。在编写了一定量的代码，对编程有了一定的了解之后。逐渐的，我们开始对自己的编写的程序，以及程序设计进行反思：程序为什么要这么设计？以什么方式可以编写出更好的程序？如何在编写程序时少走不必要的弯路？这时我们最需要的，不再局限于某种语言的语法或者是xxAPI的使用方法，而是面对实际问题需要的灵活的处理方案，亦或是去理解被前辈所认可的相对正确的软件设计方法。在这时，我们处于程序员的第二个阶段，也就是自我提升阶段。</p>
<p>这本书里面涉及到了在软件开发中的方方面面：从正确的理解需求到灵活的设计实现，从估算/提升程序的运行效率到提升软件的开发效率，从程序员的自身修养到与他人交流时的tips。这本书用非常短小的篇幅，覆盖了非常大的范围。</p>
<p>书籍地址：<a href="http://item.jd.com/10393278.html" target="_blank" rel="external">《程序员修炼之道》</a></p>
<p><strong>当然了，不是每篇文章都会投到专题里的，也算是关注的福利吧！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;哥德尔、艾舍尔、巴赫书：集异璧之大成&quot;&gt;&lt;a href=&quot;#哥德尔、艾舍尔、巴赫书：集异璧之大成&quot; class=&quot;headerlink&quot; title=&quot;哥德尔、艾舍尔、巴赫书：集异璧之大成&quot;&gt;&lt;/a&gt;哥德尔、艾舍尔、巴赫书：集异璧之大成&lt;/h4&gt;&lt;p&gt;&lt;img s
    
    </summary>
    
    
      <category term="book" scheme="https://dangdangfeng.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的谈论HTTP／1.0／1.1／2.0</title>
    <link href="https://dangdangfeng.github.io/2012/08/30/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BAHTTP%EF%BC%8F1-0%EF%BC%8F1-1%EF%BC%8F2-0/"/>
    <id>https://dangdangfeng.github.io/2012/08/30/如何优雅的谈论HTTP／1-0／1-1／2-0/</id>
    <published>2012-08-30T15:30:05.000Z</published>
    <updated>2016-08-30T15:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将涉及以下方面：</p>
<ul>
<li>HTTP协议</li>
<li>HTTP1.0</li>
<li>HTTP1.1</li>
<li>HTTP2.0</li>
<li>1.0和1.1和2.0之间的区别</li>
<li>HTTPS</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP（超文本传输协议，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。是用于从WWW服务器传输超文本到本地浏览器的传输协议。默认使用80端口，HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP协议和TCP协议是不冲突的，HTTP定义在七层协议中的应用层，TCP解决的是传输层的逻辑。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性。如TCP建立连接时三次握手有1.5个RTT（round-trip time）的延迟，为了避免每次请求的都经历握手带来的延迟，应用层会选择不同策略的http长链接方案。又如TCP在建立连接的初期有慢启动（slow start）的特性，所以连接的重用总是比新建连接性能要好。</p>
<p>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。HTTP/1.0是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。HTTP/1.1是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP／2.0在HTTP 1.x的基础上，大幅度的提高了web性能，减少了网络延迟。HTTP1.0和1.1在之后很长的一段时间内会一直并存，这是由于网络基础设施更新缓慢所决定的。</p>
<h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4><p>HTTP 协议老的标准是HTTP/1.0，为了提高系统的效率，HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的图像标签后，浏览器将根据标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求。显 然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。</p>
<p>同时，带宽和延迟也是影响一个网络请求的重要因素。在网络基础建设已经使得带宽得到极大的提升的当下，大部分时候都是延迟在于响应速度。基于此会发现，http1.0被抱怨最多的就是<strong>连接无法复用</strong>，和<strong>head of line blocking</strong>这两个问题。理解这两个问题有一个十分重要的前提：客户端是依据域名来向服务器建立连接，一般PC端浏览器会针对单个域名的server同时建立6～8个连接，手机端的连接数则一般控制在4～6个。显然连接数并不是越多越好，资源开销和整体延迟都会随之增大。连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。head of line blocking会导致带宽无法被充分利用，以及后续健康请求被阻塞。</p>
<p>head of line blocking(holb)会导致健康的请求会被不健康的请求影响，而且这种体验的损耗受网络环境影响，出现随机且难以监控。为了解决holb带来的延迟，协议设计者设计了一种新的pipelining机制。pipelining只能适用于http1.1,而且由于使用苛刻，很多浏览器厂商并不支持。</p>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持持久连接（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
<p>在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。<br>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。不论request还是response的header中包含了值为close的connection，都表明当前正在使用的tcp链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的tcp链接了。</p>
<p>HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。HTTP 1.1通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。如，HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP/1.0不支持文件断点续传，<code>RANGE:bytes</code>是HTTP/1.1新增内容，HTTP/1.0每次传送文件都是从文件头开始，即0字节处开始。<code>RANGE:bytes=XXXX</code>表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！</p>
<p>由上，HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：</p>
<p>1 缓存处理</p>
<p>2 带宽优化及网络连接的使用</p>
<p>3 错误通知的管理</p>
<p>4 消息在网络中的发送</p>
<p>5 互联网地址的维护</p>
<p>6 安全性及完整性</p>
<p><strong>常用的请求方式</strong></p>
<p>GET     请求获取Request-URI所标识的资源</p>
<p>POST    在Request-URI所标识的资源后附加新的数据</p>
<p>HEAD    请求获取由Request-URI所标识的资源的响应消息报头</p>
<p>PUT     请求服务器存储一个资源，并用Request-URI作为其标识</p>
<p>DELETE  请求服务器删除Request-URI所标识的资源</p>
<p>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断</p>
<p>CONNECT 保留将来使用</p>
<p>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>
<p>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<strong>GET是用于获取数据的，POST一般用于将数据发给服务器之用</strong>。</p>
<p><strong>请求头信息示例</strong></p>
<pre><code>// 请求
GET / HTTP/1.1

Host:xxx.xxxx.com

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.10) Gecko/2016042316 Firefox/3.0.10

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-us,en;q=0.5

Accept-Encoding: gzip,deflate

Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7

Keep-Alive: 300

Connection: keep-alive

If-Modified-Since: Mon, 25 May 2016 03:19:18 GMT


//响应
HTTP/1.1 200 OK

Cache-Control: private, max-age=30

Content-Type: text/html; charset=utf-8

Content-Encoding: gzip

Expires: Mon, 25 May 2016 03:20:33 GMT

Last-Modified: Mon, 25 May 2016 03:20:03 GMT

Vary: Accept-Encoding

Server: Microsoft-IIS/7.0

X-AspNet-Version: 2.0.50727

X-Powered-By: ASP.NET

Date: Mon, 25 May 2016 03:20:02 GMT

Content-Length: 12173

消息体的内容（略）
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1170656-feec1e83208a122a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p>
<p> <strong>HTTP 1.1状态代码及其含义</strong></p>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<blockquote>
<p>状态代码  状态信息  含义<br>100  Continue  初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）<br>101  Switching Protocols  服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）<br>200  OK  一切正常，对GET和POST请求的应答文档跟在后面。<br>201  Created  服务器已经创建了文档，Location头给出了它的URL。<br>202  Accepted  已经接受请求，但处理尚未完成。<br>203  Non-Authoritative Information  文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。<br>204  No Content  没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br>205  Reset Content  没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。<br>206  Partial Content  客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。<br>300  Multiple Choices  客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。<br>301  Moved Permanently  客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。<br>302  Found  类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。<br>出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。<br>注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求<a href="http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。" target="_blank" rel="external">http://host/~user（缺少了后面的斜杠），有的服务器返回301，有的则返回302。</a><br>严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 </p>
<p>303  See Other  类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。<br>304  Not Modified  客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br>305  Use Proxy  客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。<br>307  Temporary Redirect  和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时 才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）<br>400  Bad Request  请求出现语法错误。<br>401  Unauthorized  客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。<br>403  Forbidden  资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。<br>404  Not Found  无法找到指定位置的资源。这也是一个常用的应答。<br>405  Method Not Allowed  请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）<br>406  Not Acceptable  指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。<br>407  Proxy Authentication Required  类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）<br>408  Request Timeout  在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）<br>409  Conflict  通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）<br>410  Gone  所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新）<br>411  Length Required  服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）<br>412  Precondition Failed  请求头中指定的一些前提条件失败（HTTP 1.1新）。<br>413  Request Entity Too Large  目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。<br>414  Request URI Too Long  URI太长（HTTP 1.1新）。<br>416  Requested Range Not Satisfiable  服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）<br>500  Internal Server Error  服务器遇到了意料不到的情况，不能完成客户的请求。<br>501  Not Implemented  服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。<br>502  Bad Gateway  服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。<br>503  Service Unavailable  服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。<br>504  Gateway Timeout  由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）<br>505  HTTP Version Not Supported  服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</p>
</blockquote>
<h5 id="移动app上的困难"><a href="#移动app上的困难" class="headerlink" title="移动app上的困难"></a>移动app上的困难</h5><p>一段时间内的连接复用对PC端浏览器的体验帮助很大，因为大部分的请求在集中在一小段时间以内。但对移动app来说，成效不大，app端的请求比较分散且时间跨度相对较大。所以移动端app一般会从应用层寻求其它解决方案，长连接方案或者伪长连接方案：</p>
<p>方案一：基于tcp的长链接</p>
<p>现在越来越多的移动端app都会建立一条自己的长链接通道，通道的实现是基于tcp协议。基于tcp的socket编程技术难度相对复杂很多，而且需要自己制定协议，但带来的回报也很大。信息的上报和推送变得更及时，在请求量爆发的时间点还能减轻服务器压力（http短连接模式会频繁的创建和销毁连接）。不止是IM app有这样的通道，像淘宝这类电商类app都有自己的专属长连接通道了。现在业界也有不少成熟的方案可供选择了，google的protobuf就是其中之一。</p>
<p>方案二：http long-polling（推送）</p>
<p>客户端在初始状态就会发送一个polling（轮寻）请求到服务器，服务器并不会马上返回业务数据，而是等待有新的业务数据产生的时候再返回。所以连接会一直被保持，一旦结束马上又会发起一个新的polling请求，如此反复，所以一直会有一个连接被保持。服务器有新的内容产生的时候，并不需要等待客户端建立一个新的连接。做法虽然简单，但有些难题需要攻克才能实现稳定可靠的业务框架：<br>和传统的http短链接相比，长连接会在用户增长的时候极大的增加服务器压力，<br>移动端网络环境复杂，像wifi和4g的网络切换，进电梯导致网络临时断掉等，这些场景都需要考虑怎么重建健康的连接通道。这种polling的方式稳定性并不好，需要做好数据可靠性的保证，比如重发和ack机制（ACK是一个对数据包的确认，当正确收到数据包后，接收端会发送一个ACk给发送端，里面会说明对那个数据包进行确认，每个数据包里都会有一个序列号，如果收到的数据包有误，或错序，还会申请重发，NAK是一个否定的回答，ACK是确定回答，这样保证数据的正确传输）。</p>
<p>polling的response有可能会被中间代理cache住，要处理好业务数据的过期机制。long-polling方式还有一些缺点是无法克服的，比如每次新的请求都会带上重复的header信息，还有数据通道是单向的，主动权掌握在server这边，客户端有新的业务请求的时候无法及时传送。</p>
<p>方案三：http streaming</p>
<p>同long-polling不同的是，server并不会结束初始的streaming请求，而是持续的通过这个通道返回最新的业务数据。显然这个数据通道也是单向的。streaming是通过在server response的头部里增加”Transfer Encoding: chunked”来告诉客户端后续还会有新的数据到来。除了和long－polling相同的难点之外，streaming还有几个缺陷：有些代理服务器会等待服务器的response结束之后才会将结果推送到请求客户端。对于streaming这种永远不会结束的方式来说，客户端就会一直处于等待response的过程中。业务数据无法按照请求来做分割，所以客户端每收到一块数据都需要自己做协议解析，也就是说要做自己的协议定制。streaming不会产生重复的header数据。</p>
<p>方案四：web socket</p>
<p>WebSocket和传统的tcp socket连接相似，也是基于tcp协议，提供双向的数据通道。WebSocket优势在于提供了message的概念，比基于字节流的tcp socket使用更简单，同时又提供了传统的http所缺少的长连接功能。不过WebSocket相对较新，2010年才起草，并不是所有的浏览器都提供了支持。各大浏览器厂商最新的版本都提供了支持。</p>
<h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><p>使用<a href="https://http2.akamai.com/demo" target="_blank" rel="external">HTTP2.o测试</a>(<a href="https://http2.akamai.com/demo)便可看出HTTP2.0比之前的协议在性能上有很大的提升。下面总结了HTTP2.0协议的几个特性。" target="_blank" rel="external">https://http2.akamai.com/demo)便可看出HTTP2.0比之前的协议在性能上有很大的提升。下面总结了HTTP2.0协议的几个特性。</a></p>
<p><strong>多路复用 (Multiplexing)</strong></p>
<p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，<a href="http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而" target="_blank" rel="external">http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而</a> HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p>
<p><strong>二进制分帧</strong></p>
<p>HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。</p>
<p>HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<p>这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。<br>￼</p>
<p><strong>首部压缩（Header Compression）</strong></p>
<p>HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。<br>￼</p>
<p><strong>服务端推送（Server Push）</strong></p>
<p>服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。现在的HTTPS都是用的TLS协议，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词。</p>
<p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p>
<p>1.浏览器将自己支持的一套加密规则发送给网站。</p>
<p>2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
<p>3.获得网站证书之后浏览器要做以下工作：<br>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。<br>c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p>
<p>4.网站接收浏览器发来的数据之后要做以下的操作：<br>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>b) 使用密码加密一段握手消息，发送给浏览器。</p>
<p>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p>
<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>
<p>TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。默认HTTP的端口号为80，HTTPS的端口号为443。</p>
<p>最后，如果您有兴趣想对这方面有更加深入的了解，可以买本《HTTP权威指南》放在案边，时不时的翻翻，既能镇宅，又能深化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将涉及以下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议&lt;/li&gt;
&lt;li&gt;HTTP1.0&lt;/li&gt;
&lt;li&gt;HTTP1.1&lt;/li&gt;
&lt;li&gt;HTTP2.0&lt;/li&gt;
&lt;li&gt;1.0和1.1和2.0之间的区别&lt;/li&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;/ul&gt;
&lt;h3
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>谈谈C的性能特点</title>
    <link href="https://dangdangfeng.github.io/2010/08/31/%E8%B0%88%E8%B0%88C%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9/"/>
    <id>https://dangdangfeng.github.io/2010/08/31/谈谈C的性能特点/</id>
    <published>2010-08-30T16:48:11.000Z</published>
    <updated>2016-08-30T16:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>C语言是一种命令式语言（又称强制式语言，通过指明一系列可执行的运算及运算的次序来描述计算过程的语言），生于1972年的贝尔实验室。平时我们用的大多数语言（比如，C,C++,Java,C#,Python等）都是命令式语言，与它相对的是函数式语言(functional language)，如Haskell,Lisp。函数式语言更像数学，命令式语言更接近人的思维。</p>
<h4 id="C语言的特性"><a href="#C语言的特性" class="headerlink" title="C语言的特性"></a>C语言的特性</h4><p>C语言的典型特征是编译型语言(compiled language)（相对于解释型语言来说）、命令式的、人工管理内存 。对于编译型语言，程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接运行编译的结果就行了，<strong>因此效率高</strong>。 以此相对，解释型语言程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次，因此<strong>效率比较低</strong>。由此，当涉及到速度，内存，低层次特性(low-level features)如：移动stack pointer等常会使用C语言。</p>
<p>从内存的角度思考C语言，相对于其他语言，<strong>汇编语言直接操作内存；C、C++访问内存；Java,C#,Scheme/LISP,ML使用的是内存自动管理机制</strong>。 C语言通过堆(heap)和栈（stack）访问的内存，C函数将会分配到棧中，函数在被调用时进棧(pushed on to stack)， 函数在返回时出棧(popefd off the stack)，函数能访问当前棧顶部以下的所有内存；堆是一块儿用于动态内存分配的内存区域，可以把它想像称为一个巨大的数组 ，通过指针(pointer)来访问，如果操作系统允许，整个程序都能访问堆。C语言人工内存管理目的是允许程序能够分配内存用于当前的使用 ；当程序执行完后，能够释放内存，用于重新分配 ，C语言的标准类库中有malloc和free两个函数支持内存管理 。从内存的层面，C语言虽然使用起来更复杂些，但在可操作性上更好一些，毕竟自动内存管理，内存的释放不是立即的。</p>
<p>C语言比起其他的高级语言来说，更接近计算机，也就是说，它介于高级语言和汇编语言之间，通常来说比其他高级语言执行效率更高一点。当然，C语言的函数化特点（即所有C程序都是由函数构成）和灵活的语法也是吸引程序设计者的地方。</p>
<h4 id="C语言的优势"><a href="#C语言的优势" class="headerlink" title="C语言的优势"></a>C语言的优势</h4><p>C语言一共只有32个关键字，9种控制语句，程序书写形式自由，区分大小写。把高级语言的基本结构和语句与低级语言的实用性结合起来。C语言允许直接访问物理地址，可以直接对硬件进行操作，因此它既具有高级语言的功能，又具有低级语言的许多功能，C语言可以像汇编语言一样对<strong>位、字节和地址</strong>进行操作，而这三者是计算机最基本的工作单元，可用来写系统软件，又可用来开发应用软件，已成为一种通用程序设计语言。另外C语言具有强大的图形功能，支持多种显示器和驱动器。且计算功能、逻辑判断功能强大。    </p>
<p>C语言的运算符包含的范围很广泛，共有34种运算符。C语言把括号、赋值、强制类型转换等都作为运算符处理。从而使C语言的运算类型极其丰富，表达式类型多样化。灵活使用各种运算符可以实现在其它高级语言中难以实现的运算。 C语言的数据类型有：整型、实型、字符型、数组类型、指针类型、结构体类型、共用体类型等。能用来实现各种复杂的数据结构的运算。并引入了指针概念，使程序效率更高。    </p>
<p>C语言生成目标代码质量高，程序执行效率高，C语言描述问题比汇编语言迅速，工作量小、可读性好，易于调试、修改和移植，而代码质量与汇编语言相当。C语言一般只比汇编程序生成的目标代码效率低10%～20%。可移植性好，C语言在不同机器上的C编译程序，86%的代码是公共的，所以C语言的编译程序便于移植。在一个环境上用C语言编写的程序，不改动或稍加改动，就可移植到另一个完全不同的环境中运行。    </p>
<h4 id="当前新发明的语言Swift的比较"><a href="#当前新发明的语言Swift的比较" class="headerlink" title="当前新发明的语言Swift的比较"></a>当前新发明的语言Swift的比较</h4><p>Swift包含了很多现代语言特性尤其是从一些脚本语言如Javascript/Ruby中汲取了营养，此外苹果发布Swift时，使用特别选用的一些例子来宣称Swift性能对于Ojbective C的大幅提升（40~50%），如复杂对象排序等。但是开发者实际测试出来的情况却相反。实际数据显示，Swift在简单循环、递增、赋值、数组扩展、字符串拼接上性能远不如Objective C。可能的一个解释是Swift使用类classes，总在执行ARC（Auto Referrence Count），而Objective C则更多使用C风格的数据类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-8ef4897116759a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言是一种命令式语言（又称强制式语言，通过指明一系列可执行的运算及运算的次序来描述计算过程的语言），生于1972年的贝尔实验室。平时我们用的大多数语言（比如，C,C++,Java,C#,Python等）都是命令式语言，与它相对的是函数式语言(functional lang
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流城</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dangdangfeng.github.io/"/>
  <updated>2016-09-01T15:30:58.000Z</updated>
  <id>https://dangdangfeng.github.io/</id>
  
  <author>
    <name>吴白</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://dangdangfeng.github.io/2016/09/01/%E4%BB%8EReact%E5%88%B0Flux%E6%9E%B6%E6%9E%84/"/>
    <id>https://dangdangfeng.github.io/2016/09/01/从React到Flux架构/</id>
    <published>2016-09-01T15:09:36.000Z</published>
    <updated>2016-09-01T15:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>React 本身只涉及UI层，如果搭建大型应用，必须搭配一个前端框架。即：React + 前端框架。<a href="https://facebook.github.io/flux/docs/overview.html" target="_blank" rel="external">Flux</a>是Facebook用户建立客户端Web应用的前端架构， 它通过利用一个单向的数据流补充了React的组合视图组件，<br>相对于框架而言它更像是一种模式思想，在无需许多新代码的情况下就可以构建出合适的Web应用。</p>
<h4 id="应用的几个部分"><a href="#应用的几个部分" class="headerlink" title="应用的几个部分"></a>应用的几个部分</h4><p>应用通常分为Dispatcher调度 、存储Store和视图View(React 组件)。分析如下：</p>
<p>1) View: 应用的界面。这里创建响应用户操作的action。</p>
<p>2) Dispatcher: 中心枢纽，传递所有的action，负责把它们运达每个Store，整个数据流程的管理者。</p>
<p>3) Store: 维护一个特定application domain的状态。它们根据当前状态响应action，执行业务逻辑，同时在完成的时候发出一个change事件。这个事件用于view更新其界面。</p>
<p>4) Controller Views：React组件，从Store获取状态，并将其逐级向下传递给子组件。</p>
<p>这几个部分都是通过Action来通信的。控制器controller-view(控制器-视图)模式，视图通常在一个结构顶部，这种结构是用来从存储stroe获得数据，然后将数据传递到自己的子结构。可以简单的将控制器视图理解为React组件，这些组件会监听change事件，如果事件发生了， 就从Stores中获取应用程序新的状态数据。随后，可以将数据通过props逐级向子组件传递。控制器被存储反转控制：存储接受更新，适当地调节这些更新，而不是一致地依赖外部更新其数据，存储之外根本不知道它是如何管理领域数据的，这有助于实现一种清晰的分离关注。存储并没有直接的类似setAsRead()之类的方法，而是只有一个单一方式获取数据到其自成一体的世界中，这个方式就是回调，注册在dispatcher中的callback。</p>
<p>行为创建器（Action Creators）是一组会在视图中被调用的方法（也可以在其他地方使用）， 它们用于向Dispatcher发送actions。也就是说，我们使用Dispatcher分发的payloads，实际上就是actions。<br>Action Creators是相对独立的，它作为语法上的辅助函数以action的形式使得dispatcher传递数据更为便利。</p>
<p>应用的每一个部分可以对应于一个Store，Store可以用来管理数据，定义数据检索方法，此外，Store中还包括了注册给Dispatcher的回调函数。控制器视图（Controller View）会监听我们的Store， 并利用这一点通过发出事件方式通知控制器视图应用程序的状态发生了改变， 从而进行视图层的重新渲染。</p>
<p>每一个 store　的角色是提供状态信息，它与相关的 UI 和成为关联点为了状态的更新。这并不意味着整个业务逻辑需要被实现在 store 本身。每当一个状态更新（的事件）发生， 自动更新 UI 的机制就被触发, 这是 Flux 的一个核心理念。它保证了 UI 始终显示最新的状态，并且可以摆脱一直需要（手动地）维护这些代码的工作。这一步类似于在 MVVM 架构中，将一个视图绑定到 ViewModel。如果要自己实现部分 UI 更新的代码可以借用ReactiveCocoa,它提供了很多操作 (skipUntil，take，map，其他。)，很容易就能创建这些关系。但此处不做过多的讨论。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-7ff05b4bb695a031.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>示例代码可以参考<a href="https://github.com/ruanyf/extremely-simple-flux-demo" target="_blank" rel="external">阮一峰写的demo</a>.</p>
<h4 id="数据的”单向流动”"><a href="#数据的”单向流动”" class="headerlink" title="数据的”单向流动”"></a>数据的”单向流动”</h4><p>数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。</p>
<p><strong>数据的流程可以分为以下步骤：</strong></p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个”change”事件</li>
<li>View 收到”change”事件后，更新页面</li>
</ol>
<p>通过应用的数据流是一个方向，没有两边绑定(two-way bingding：Angular.js有此方式)，应用状态在存储中维护，允许应用不同部分保持解耦，在存储之间发生依赖的地方，它们能够保持严格的层次关系（设计原则：尽量松耦合，无法回避的就变成树形层次结构），同步管理由dispatcher负责。而two-way绑定会导致级联更新，当一个对象改变导致另外对象改变，接着会触发更多的更新，当应用规模增长时，这些级联更新会使得预期响应用户交互的结果变得困难，当更新只会在一个轮回中发生改变数据时，整个系统就变得可预期。</p>
<p>不过，很多场景下不仅仅包括应用程序内部的状态数据，还可能包括来自外部的数据，即常见的RESTful服务，在Action中引入外部数据流是个不错的方式，然后把数据送到Store中。<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc" target="_blank" rel="external">官方的示例代码</a>很好的为我们解决了疑惑。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-5cde667b0db85470.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据流"></p>
<p>Dispatcher接收actions作为payloads，并且将payloads分发给所注册的回调函数。并且包括了允许你以指定次序调用这些回掉函数的执行逻辑，例如在处理前等待数据更新。在Flux架构中只有一个Dispatcher，它是你整个应用的中央Hub。在下面的handleTestAction方法中调用了dispatch方法（该方法来自Dispatcher实现），它会将payloads广播给所有注册到它的回调函数 （注意，这里所说的回调是在store中注册给Dispatcher的）。然后，action会触发Store中相应事件，并最终体现在state的更新上。示例如下：</p>
<pre><code>//创建一个简单的Dispatcher
var Dispatcher = require(&apos;flux&apos;).Dispatcher;
var AppDispatcher = new Dispatcher();

AppDispatcher.handleTestAction = function(action) {
  this.dispatch({
    source: &apos;Test_ACTION&apos;,
    action: action
  });
}

module.exports = AppDispatcher;
</code></pre><p>Dispatcher模块能够定义依赖，并在Store中向Dispatcher注册回调函数。如果你的应用的某个部分依赖于其他部分的数据更新，为了能够进行合适的渲染，Dispatcher中的waitFor方法将会非常有用。在Store中存储注册给Dispatcher的回调函数的返回值.如果一个相关的action发生了，那么就触发一个change事件，并且监听 此事件的视图会根据新的状态（state）进行重新渲染。</p>
<pre><code>TestStore.dispatcherIndex = AppDispatcher.register(function(payload) {});//dispatcherIndex 存储注册给Dispatcher的回调函数的返回值
</code></pre><p>在Store中处理每一个被分发的action时，我们可以使用Dispatcher的waitFor方法来确保我们的ShoeStore已经被更新了，示例代码如下：</p>
<pre><code>case &apos;Do_Something&apos;:
  AppDispatcher.waitFor([
    TestStore.dispatcherIndex
  ], function() {
    CheckoutStore.purchaseShoes(TestStore.getSelectedShoes());
  });
  break;
</code></pre><p>在Facebook提供的例子中，action的类型常数被用于定义这些action所被应用的场景，并且是伴随着action一起被传递的。现在，在所注册的回调函数内部，这些actions可以根据他们的action类型来处理。</p>
<p>总结来说，Flux 模式首先会定义状态类型的形状。之后会定义 actions。然后实现业务逻辑和针对每个 action 状态的转变 - 这个实现在 store 中。最后实现 UI 绑定方法，将状态映射到视图展示层。Flux 主要的好处在于它把有关的内容严格的区分开。这让测试业务逻辑和大块的 UI 代码变得非常容易。测试时需要关注两个逻辑：在 store 中的业务逻辑和视图模型的提供者 （就是那些我们实现的类似 React 的方法，他们基于输入的状态描述了 UI）。但是，国内对这方面并不是很关注，关于测试，此处不做太多的讨论。有需要的可以看下这篇<a href="https://www.objc.io/issues/15-testing/snapshot-testing/" target="_blank" rel="external">文章</a>（可能需要翻墙！）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面的分析，我们会发现Flux的React应用开发类似于jQuery的DOM遍历操作。没有Flux可以照常进行React应用开发，但是你在代码组织和数据流程上会缺乏优雅的解决方案。Flux可以把接受数据和发送数据分离。因此当出错的时候可以很容易地沿着数据流看看到底是哪里出错了。</p>
<p>如果你想使用FLux架构，但你并不想使用React，那么你可以参考 <a href="https://github.com/f/delorean" target="_blank" rel="external">Delorean</a>，它是一个Flux框架，并且可以让你使用Ractive.js或者Flight。另一个值得参考的库是 <a href="http://fluxxor.com" target="_blank" rel="external">Fluxxor</a>，它实现了在紧耦合的Flux组件中包含一个中央Flux实例。</p>
<p>Flux让事情变得可预见。</p>
<p>注：本文受到了<a href="http://blog.andrewray.me/flux-for-stupid-people/" target="_blank" rel="external">《Flux For Stupid People》</a>和<a href="https://skillsmatter.com/skillscasts/8179-turning-uikit-inside-out" target="_blank" rel="external">《Turning UIKit inside out》</a>的启发。在此对其表示感谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 本身只涉及UI层，如果搭建大型应用，必须搭配一个前端框架。即：React + 前端框架。&lt;a href=&quot;https://facebook.github.io/flux/docs/overview.html&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
    
      <category term="前端" scheme="https://dangdangfeng.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>mac上自定义脚本命令</title>
    <link href="https://dangdangfeng.github.io/2016/01/11/mac%E4%B8%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://dangdangfeng.github.io/2016/01/11/mac上自定义脚本命令/</id>
    <published>2016-01-11T15:34:53.000Z</published>
    <updated>2016-09-01T15:36:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>AppleScript 是 Mac OS X内置的一种功能强大的脚本语言，使用 AppleScript 的目的是把一些重复繁琐并且耗费时间的任务自动化。AppleScript 的一个优点是你不必是一个天才程序员才能使用它，事实上你甚至不需要有任何编程的经验！</p>
<h4 id="OS-X-中使用appleScript快速调出终端"><a href="#OS-X-中使用appleScript快速调出终端" class="headerlink" title="OS X 中使用appleScript快速调出终端"></a>OS X 中使用appleScript快速调出终端</h4><p>os x 上很多功能都可以通过Apple自家的Automator.app创建，且使用此方法可以为任何的程序创建快捷键。</p>
<p>1.第一步 打开 Automator.app，可以在spotlight中搜索Automator,然后打开。<br><img src="http://upload-images.jianshu.io/upload_images/1170656-af4786d785df7361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Automator"><br>2.选择 新建，然后选择服务</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-4030f0834d9b3b97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择服务"></p>
<p>3.服务收到 选择为 没有输入</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-ed184d3d7315f368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择"></p>
<p>然后在左边侧栏中双击 Run AppleScript</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-cc945ec8fc9bab78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snip20151226_6.png"></p>
<p>4.在编辑区输入</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-4ccdde257b2c4e82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入"></p>
<p>这样 AppleScript 就写好了，ctrl + s 将其保存为 Open Terminal只需将脚本中的 tell application “Terminal” 中的 “Terminal” 改为其他的程序名，就可以为其它的程序建立快捷键</p>
<p>5.设置快捷键<br>打开系统偏好设置-&gt;键盘-&gt;快捷键</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-cd256ae46b9f5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置快捷键"></p>
<p>在键盘快捷键设置的左侧栏中选中 服务 ，可以看到Open Terminal ，然后完成快捷键的设置。我的快捷键设置alt ＋ contrl ＋1。</p>
<h4 id="AppleScript-字典"><a href="#AppleScript-字典" class="headerlink" title="AppleScript 字典"></a>AppleScript 字典</h4><p>要打开字典，在 AppleScript Editor 选择菜单 File-&gt;Open Dictionary (或快捷键Shift-Command-O)。例如在打开的字典里向下浏览，找到程序 Mail 然后按 “Choose”，你应该会看到以下的窗口：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-df4b5bbe92c2127f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AppleScript 字典"></p>
<p>在左边的列中包含了指令和物件的 “套件”。当你选择了一个套件，你会在下面的显示窗中看到此套件所包含的所有东西。你可以通过点击第二列及第三列里的命令来缩小预览的范围。套件包含了 “指令” （圆形的C图标）和 “类” （方形的C图标），而 “类” 包含了 “属性”（P图标）和 “元素”（E图标）。</p>
<h4 id="使用-Mail-字典来创建邮件变量"><a href="#使用-Mail-字典来创建邮件变量" class="headerlink" title="使用 Mail 字典来创建邮件变量"></a>使用 Mail 字典来创建邮件变量</h4><p>由于我们完全不知道怎么告诉 Mail 去创建一个新的邮件信息，所以我们必须借助于 AppleScript 字典。如果你点击一下 “Standard Suite” 你会看到一些 AppleScript 自带的公共标准命令。由于我们是要 “创建” 一个新的邮件信息，我们通过向下浏览来找到相关的命令，你会发现里面没有 “create” 这个命令，但在向下滑到差不多中间的部分你会找到 “make” 这个命令。听起来貌似不错，所以创建一个新的邮件系统，其实是要告诉 AppleScript 我们要 “make” 一些东西。</p>
<p>接下来点击最左列的 “Mail” 套件。我们刚才已经找到动作是 “make”，所以在这里我们跳过所有“指令”（动词）不看，直接翻到下面的 “类”（名词）中。我们第一个看到的类是 “outgoing message”，太好了这就是我们要的，因为我们就是要发出一个新的邮件信息。接着点击 “outgoing message” 类然后看下面显示的属性说明。</p>
<p>我们需要把第一步创建的几个简单变量插入到新邮件变量中。但在下面的 “outgoing message” 属性列表中，我们只找到邮件标题和内容的属性，而没看到收件人相关的属性。现在我们知道引用这些属性的正确语法了。注意，字典告诉你的是属性的定义格式。比如 subject 这个属性，我们定义的方法是 “subject:你想打的标题字样”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-842803b21c2e09a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="outgoing message"></p>
<p>同样你会在套件中找到一个叫 “send”的指令，我们会使用这个指令来发送邮件。现在我们还需要知道正确表达收件人名字和收件人邮箱地址的语法。由于不在这个套件中，我们点击 “Message” 套件。向下浏览到差不多一半的时候我们找到 “receipient” 这个类，点击这个类会看到他的属性列表，同样我们可以通过简单的英文来引用这个类的属性，它的属性包括 “name” 和 “address”。</p>
<p>你可以使用字典窗右上角的搜索栏快速的搜索你需要的类或属性等。</p>
<p>创建我们的邮件信息</p>
<pre><code>--Variables
set recipientName to &quot;John Doe&quot;
set recipientAddress to &quot;nobody@nowhere.com&quot;
set theSubject to &quot;AppleScript Automated Email&quot;
set theContent to &quot;This email was created and sent using   AppleScript!&quot;

--Mail Tell Block
tell application &quot;Mail&quot;

--Create the message
set theMessage to make new outgoing message with   properties {subject:theSubject, content:theContent, visible:true}

end tell
</code></pre><p>创建了一个 tell 命令块来包住所有发送给 Mail 应用程序的命令。然后我创建了一个变量（theMessage）并让他去 “make” 一个新的 “outgoing message”而且指定上面说到的它的属性。需要注意的是属性组需要用{}来包住，每个属性间用逗号分隔。</p>
<p>设置收件人和发送邮件</p>
<pre><code>--Variables
set recipientName to &quot;John Doe&quot;
set recipientAddress to &quot;nobody@nowhere.com&quot;
set theSubject to &quot;AppleScript Automated Email&quot;
set theContent to &quot;This email was created and sent using AppleScript!&quot;

--Mail Tell Block
tell application &quot;Mail&quot;

--Create the message
set theMessage to make new outgoing message with properties {subject:theSubject, content:theContent, visible:true}

--Set a recipient
tell theMessage
    make new to recipient with properties {name:recipientName, address:recipientAddress}

    --Send the Message
    send

end tell
end tell
</code></pre><p>theMessage 指向的是一个 outgoing message 类的实例，我们在前面查 outgoing message 类的时候，看到除了属性列表外，前面还有一个叫 Elements 的说明，这里说明的是这个类具有这些元素，其中就包括一个叫 to recipient 的元素。那么这里就比较好理解了，“tell theMessage make new to recipient” 这句就可以理解为告诉 theMessage 这个实例创建（或者叫设置）它自己的 to recipient 元素，当然用的就是后面跟的 properties 了。</p>
<p>最后我们执行 “send” 指令来发送我们的邮件。注意最下面我们用了两次 end tell，因为有两个 tell 命令块需要关闭。当你修改完一些输入的错误并编译完成后点击 “Run”，Mail 程序应该会自动创建一封邮件并且发出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-ef40b28f57d531e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-cf9591e5d04babb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收件箱"></p>
<p>具体命令，我们后续再聊！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AppleScript 是 Mac OS X内置的一种功能强大的脚本语言，使用 AppleScript 的目的是把一些重复繁琐并且耗费时间的任务自动化。AppleScript 的一个优点是你不必是一个天才程序员才能使用它，事实上你甚至不需要有任何编程的经验！&lt;/p&gt;
&lt;h4
    
    </summary>
    
    
      <category term="杂谈" scheme="https://dangdangfeng.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>React Native的极简手册</title>
    <link href="https://dangdangfeng.github.io/2015/10/01/React-Native%E7%9A%84%E6%9E%81%E7%AE%80%E6%89%8B%E5%86%8C/"/>
    <id>https://dangdangfeng.github.io/2015/10/01/React-Native的极简手册/</id>
    <published>2015-10-01T14:53:33.000Z</published>
    <updated>2016-08-31T15:08:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装入门"><a href="#安装入门" class="headerlink" title="安装入门"></a>安装入门</h4><p>安装入门可以参考：<a href="http://reactnative.cn/docs/0.31/tutorial.html#content" target="_blank" rel="external">React Native官方文档</a>。</p>
<p>NodeJS知识储备：参考<a href="https://leanpub.com/nodebeginner-chinese" target="_blank" rel="external">《NodeJS入门》</a>。（尊重知识，请购买原版）。</p>
<p>书籍：<a href="http://item.jd.com/11844102.html" target="_blank" rel="external">《React Native入门与实战》</a></p>
<p>代码示例：<a href="https://github.com/fangwei716/30-days-of-react-native" target="_blank" rel="external">30天学习React Native教程</a></p>
<p>看到这里，对React Native的使用就有了一些认识了。</p>
<h4 id="React-and-React-Native-and-NodeJS"><a href="#React-and-React-Native-and-NodeJS" class="headerlink" title="React and React Native and NodeJS"></a>React and React Native and NodeJS</h4><p><a href="https://facebook.github.io/react/index.html" target="_blank" rel="external">React</a>是由Facebook开发出来的用于开发用户交互界面的JS库。其源码由Facebook和社区优秀的程序员维护。React带来了很多新的东西，例如组件化、JSX、虚拟DOM等。其提供的虚拟DOM使得我们渲染组件呈现非常之快，让我们从频繁操作DOM的繁重工作之中解脱。它做的工作更多偏重于MVC中的V层，结合其它如Flux等一起，你可以非常容易构建强大的应用。</p>
<p>React的世界里，一切都是组件。你可以构建任何直接的HTML没有的组件，例如下拉菜单、导航菜单等。同时，组件里也可以包含其它组件。每一个组件都有一个render方法，用于呈现该组件。同时，每一个组件都有属于自己的scope，从而与其它的组件界定开来，用于构建属于该组件的方法，以方便复用。JSX是基于JS的扩展，它允许你在JS里直接写HTML的代码，而不用像我们过去一样要想在JS里写HTML不得不拼接一大堆的字符串。React不直接操作DOM，频繁的操作DOM会非常影响性能和体验。React将DOM结构储存在内存中，与render方法的返回值进行比较，通过其自由的diff算法计算出不同的地方，然后反应到真实的DOM当中。也就是说，大多数情况我们渲染组件、更改组件状态等都是操作的虚拟DOM，只有在有所改变的情况下，才会反应到真实的DOM当中。React Native基于ReacJS，把 React 编程模式的能力带到移动开发,用来开发iOS和Android原生应用.</p>
<p>NodeJs 是基于JavaScript的,可以做为后台开发的语言. 提供了很多系统级的API，如文件操作、网络编程等. 用事件驱动, 异步编程,主要是为后台网络服务设计.React Native 借助 Node.js，即 JavaScript 运行时来创建 JavaScript 代码。</p>
<p>总结来说，React Native使用NodeJS来做系统处理，使用React来渲染。</p>
<h4 id="构建原理"><a href="#构建原理" class="headerlink" title="构建原理"></a>构建原理</h4><p>在AppDelegate.m里，找到 </p>
<pre><code>application:didFinishLaunchingWithOptions：
</code></pre><p>在这个方法中，主要做了几件事：</p>
<ul>
<li>定义了 JS 代码所在的位置，它在 dev 环境下是一个 URL，通过 development server 访问；在生产环境下则从磁盘读取，当然前提是已经手动生成过了 bundle 文件；</li>
<li>创建了一个 RCTRootView 对象，该类继承于 UIView，处理程序所有 View 的最外层；</li>
<li>调用 RCTRootView 的 initWithBundleURL 方法。在该方法中，创建了 bridge 对象。顾名思义，bridge 起着两个端之间的桥接作用，其中真正工作的是类就是大名鼎鼎的 RCTBatchedBridge。RCTBatchedBridge 是初始化时通信的核心，我们重点关注的是 start 方法。在 start 方法中，会创建一个 GCD 线程，该线程通过串行队列调度了以下几个关键的任务。</li>
</ul>
<p>RCTRootView 用于加载 JavaScript 应用以及渲染最后的视图的。当应用开始运行的时候，RCTRootView将会从以下的URL中加载应用：</p>
<pre><code>http://localhost:8081/index.ios.bundle
</code></pre><p>重新调用了你运行这个App时打开的终端窗口，它开启了一个 packager 和 server 来处理上面的请求。在 Safari 中打开那个 URL；你将会看到这个 App 的 JavaScript 代码。你也可以在 React Native 框架中找到你的代码。当你的App开始运行了以后，这段代码将会被加载进来，然后 JavaScriptCore 框架将会执行它。在程序里，它将会加载 功能 组件，然后构建出原生的 UIKit 视图。JavaScript应用运行在模拟器上，使用的是原生UI，没有任何内嵌的浏览器。应用程序会使用 React.createElement 来构建应用 UI ,React会将其转换到原生环境中。</p>
<p>当 UI 渲染出来后,render 方法会返回一颗视图渲染树,并与当前的 UIKit 视图进行比较。这个称之为 reconciliation 的过程的输出是一个简单的更新列表, React 会将这个列表应用到当前视图。只有实际改变了的部分才会重新绘制。即ReactJS独特的——virtual-DOM(文档对象模型,一个web文档的视图树)和 reconciliation概念。</p>
<h4 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h4><p>组件的生命周期分成三个状态：</p>
<pre><code>Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM
</code></pre><p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<pre><code>componentWillMount()
componentDidMount()
componentWillUpdate(object nextProps, object nextState)
componentDidUpdate(object prevProps, object prevState)
componentWillUnmount()
</code></pre><p>此外，React 还提供两种特殊状态的处理函数。</p>
<pre><code>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用
</code></pre><p>这些方法的详细说明，可以参考<a href="https://facebook.github.io/react/docs/working-with-the-browser.html#component-lifecycle" target="_blank" rel="external">官方文档</a>。</p>
<p>另外一个需要关注的点是，组件的style属性的设置方式不能写成</p>
<pre><code>style=&quot;opacity:{this.state.opacity};&quot;
</code></pre><p>而要写成</p>
<pre><code>style={{opacity: this.state.opacity}}
</code></pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>
<h4 id="JS-和-Native-交互"><a href="#JS-和-Native-交互" class="headerlink" title="JS 和 Native 交互"></a>JS 和 Native 交互</h4><p>xcode启动后会执行 ../node_modules/react-native/packager/react-native-xcode.sh文件。脚步中主要是读取 Xcode 带过来的环境变量，同时加载 nvm 包使得 Node.js 环境可用，最后执行 react-native-cli 的命令：</p>
<pre><code>$NODE_BINARY &quot;$REACT_NATIVE_DIR/local-cli/cli.js&quot; bundle \
  --entry-file index.ios.js \
  --platform ios \
  --dev $DEV \
  --bundle-output &quot;$DEST/main.jsbundle&quot; \
  --assets-dest &quot;$DEST&quot;
</code></pre><p>通过此处，index.ios.js和main.jsbundle就可以使用了。</p>
<p>通过../react-native/local-cli/cli.js 中的 run 方法，进入/bundle/bundle.js ,由此进入了 /bundle/buildBundle.js。从js脚本中可以看出大体做了下面的工作：</p>
<ul>
<li>从入口文件开始分析模块之间的依赖关系；</li>
<li>对 JS 文件转化，比如 JSX 语法的转化等；</li>
<li>把转化后的各个模块一起合并为一个 bundle.js。</li>
</ul>
<p>React Native对模块的分析和编译做了不少优化，大大提升了打包的速度，这样能够保证在 liveReload 时用户及时得到响应。</p>
<p>在应用程序启动之后，其中的 didFinishLaunchingWithOptions 方法会被调用，通过上面的分析，我们可以看到自己实现的页面就被加入到应用程序中了。JS 引擎，在调试环境下，对应的 Executor 为 RCTWebSocketExecutor，它通过 WebSocket 连接到 Chrome 中，在 Chrome 里运行 JS;在生产环境下，对应的 Executor 为 RCTContextExecutor，这应该就是传说中的 javascriptcore。</p>
<p>Native 调用 JS 是通过发送消息到 Chrome 触发执行、或者直接通过 javascriptcore 执行 JS 代码的。在 JS 端调用 Native 一般都是直接通过引用模块名，JS 把(调用模块、调用方法、调用参数) 保存到队列中；Native 调用 JS 时，顺便把队列返回过来；Native 处理队列中的参数，同样解析出(模块、方法、参数)，并通过 NSInvocation 动态调用；Native方法调用完毕后，再次主动调用 JS。JS 端通过 callbackID，找到对应JS端的 callback，进行一次调用。两端都保存了所有暴露的 Native 模块信息表作为通信的基础。</p>
<p>JS不会主动传递数据给OC，在调OC方法时，会把ModuleID,MethodID等数据加到一个队列里，等OC过来调JS的任意方法时，再把这个队列返回给OC，此时OC再执行这个队列里要调用的方法。native开发里，只在有事件触发的时候才执行代码。在React Native里，事件发生时OC都会调用JS相应的模块方法去处理，处理完这些事件后再执行JS想让OC执行的方法，而没有事件发生的时候，是不会执行任何代码的。</p>
<p>另外，一个 Native 模块如果想要暴露给 JS，需要在声明时显示地调用 RCT_EXPORT_MODULE。宏定义了 load 方法，该方法会自动被调用，在方法中对当前类进行注册。模块如果要暴露出指定的方法，需要通过 RCT_EXPORT_METHOD 宏进行声明。</p>
<p>总结：整个启动过程就是，JS端先把代码大包成bundle.js传到Native端的主函数，主函数创建RCTRootView.在RCTRootView里使用GCD扫描暴露的模块，创建JS引擎，将模块信息序列化为json.此时加载JS代码，在JS引擎中执行bundle.js,将json对象反序列化保存为NativeModules对象。</p>
<p>JS 和 Native 的交互过程中， RCTBatchedBridge 在两端通信过程中扮演了重要的角色。</p>
<pre><code>//RCTBatchedBridge.m
- (void)start
{
  dispatch_queue_t bridgeQueue = dispatch_queue_create(&quot;com.facebook.react.RCTBridgeQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

  // 异步的加载打包完成的js文件，也就是main.jsbundle，如果包文件在本地则直接加载，否则根据URL通过NSURLSession方式去下载
  [self loadSource:^(NSError *error, NSData *source) {}];

  // 同步初始化需要暴露给给js层的native模块
  [self initModules];

  //异步初始化JS Executor，也就是js引擎
  dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
[weakSelf setUpExecutor];
  });

  //异步获取各个模块的配置信息
  dispatch_group_async(setupJSExecutorAndModuleConfig, bridgeQueue, ^{
config = [weakSelf moduleConfig];
  });

  //获取各模块的配置信息后，将这些信息注入到JS环境中
  [self injectJSONConfiguration:config onComplete:^(NSError *error) {}];

  //开始执行main.jsbundle
  [self executeSourceCode:sourceCode];
}
</code></pre><p>js为了桥接native层也引入了BatchedBridge，BatchedBridge是MessageQueue的一个实例，而且是全局唯一的一个实例。：</p>
<pre><code>//BatchedBridge.js
const MessageQueue = require(&apos;MessageQueue&apos;);
const BatchedBridge = new MessageQueue(
  __fbBatchedBridgeConfig.remoteModuleConfig,
  __fbBatchedBridgeConfig.localModulesConfig,
);
//将BatchedBridge添加到js的全局global对象中，
Object.defineProperty(global, &apos;__fbBatchedBridge&apos;, { value: BatchedBridge });
module.exports = BatchedBridge;
</code></pre><p><code><strong>fbBatchedBridgeConfig</strong></code>是一个全局的js变量，<code>fbBatchedBridgeConfig.remoteModuleConfig</code>就是之前我们在native层导出的模块配置表.</p>
<p>messageQueue保存着js跟native的模块交互的所有信息。<code>_genModules</code>方法，该方法会根据config解析每个模块的信息并保存到this.RemoteModules中.<code>_genModules</code>会历遍所有的remoteModules,根据每个模块的配置信息(如何生成配置信息下面会提到)和module索引ID来创建每个模块.</p>
<p>react为了性能的优化，当js两次调用方法的间隔小于MIN_TIME_BETWEEN_FLUSHES_MS(5ms)时间，会将调用信息先缓存到_queue中，等待下次在一并提交给native层执行.</p>
<h4 id="Navigator组件到NavigationExperimental组件"><a href="#Navigator组件到NavigationExperimental组件" class="headerlink" title="Navigator组件到NavigationExperimental组件"></a>Navigator组件到NavigationExperimental组件</h4><p>Navigator and NavigatorIOS两个都是有状态(即保存各个导航的序顺)的组件，允许你的APP在多个不同的场景(屏幕）之间管理你的导航。这两个导航管理了一个路由栈(route stack)，这样就允许我们使用pop(), push()和replace()来管理状态。NavigatorIOS是使用了iOS的 UINavigationController类，而Navigator都是基于Javascript。 Navigator适用于两个平台，而NavigatorIOS只能适用于iOS. 如果在一个APP中应用了多个导航组件(Navigator and NavigatorIOS一起使用). 那么在两者之间进行导航过渡，会变得非常困难.</p>
<p>ＮavigationExperimental以一种新的方法实现导航逻辑，这样允许任何的视图都可以作为导航的视图 。它包含了一个预编异的组件NavigationAnimatedView来管理场景间的动画。它内部的每一个视图都可以有自己的手势和动画。</p>
<p>React Native项目已经不再维护Navigator组件而全面转向NavigationExperimental组件了。NavigationExperimental改进了Navigator组件的一下几个方面：</p>
<ul>
<li><p>单向数据流, 它使用reducers 来操作最顶层的state 对像，而在Navigator中，当你在子导航页中，不可能操作到app最初打开页面时的state对像，除非，一级级的通过props传递过方法名或函数名，然后在子页面中调用这些方法或者函数，来修改某个顶层的数据。</p>
</li>
<li><p>为了允许存在本地和基于 js的导航视图，导航的逻辑和路由，必须从视图逻辑中独立出来。</p>
</li>
<li><p>改进了切换时的场景动画，手势和导航栏</p>
</li>
</ul>
<p><a href="http://facebook.github.io/react-native/releases/0.32/docs/navigation.html#navigationexperimental" target="_blank" rel="external">NavigationExperimental</a>(<a href="http://facebook.github.io/react-native/releases/0.32/docs/navigation.html#navigationexperimental)的使用：" target="_blank" rel="external">http://facebook.github.io/react-native/releases/0.32/docs/navigation.html#navigationexperimental)的使用：</a><br>实现方案可参考<a href="https://rnplay.org/apps/nT-EnA" target="_blank" rel="external">此处</a>(<a href="https://rnplay.org/apps/nT-EnA)。" target="_blank" rel="external">https://rnplay.org/apps/nT-EnA)。</a></p>
<p>具体使用也可以看<a href="https://www.zfanw.com/blog/react-native-navigator-experimental-usage.html" target="_blank" rel="external">这里</a>(<a href="https://www.zfanw.com/blog/react-native-navigator-experimental-usage.html" target="_blank" rel="external">https://www.zfanw.com/blog/react-native-navigator-experimental-usage.html</a>).</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-3c800f024a2bb20f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;安装入门&quot;&gt;&lt;a href=&quot;#安装入门&quot; class=&quot;headerlink&quot; title=&quot;安装入门&quot;&gt;&lt;/a&gt;安装入门&lt;/h4&gt;&lt;p&gt;安装入门可以参考：&lt;a href=&quot;http://reactnative.cn/docs/0.31/tutorial.htm
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>10道经典的iOS面试题</title>
    <link href="https://dangdangfeng.github.io/2015/09/11/10%E9%81%93%E7%BB%8F%E5%85%B8%E7%9A%84iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://dangdangfeng.github.io/2015/09/11/10道经典的iOS面试题/</id>
    <published>2015-09-11T15:00:36.000Z</published>
    <updated>2016-08-31T15:07:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因，最近的移动端开发有点供大于求，鉴于当前残酷的商业现状，向往年那样的需求量也不大可能，尤其是15年B和A都停止了社招工作，但是现在的大厂都不招人了吗？显然，那也未必，需求总是有的，不过是需求有了限制。</p>
<p>一般接到面试邀请，公司已经默认您基本达到了他们的要求，要么学历好，要么经历好。互联网公司都是极其有效率的，虽然各公司各部门的流程不一定相同，但大概都是一样的，如果遇到合适的优秀求职者都是先拿下再说，流程慢慢走，因为优秀的程序员都是转瞬即逝（当然只是社招）。一般都会有一面二面三面（T有五面，A四面），J的有些部门就是一二三一遍过，或者至少是一面二面，当然前提是技术面表现不错。</p>
<p>公司一般考察三点：人是否聪明？基础是否扎实？知识是否有深度和广度？技术面一般会遇到偏理论型的或实战型的，理论型的会着重在基础知识，原理的理解，算法，系统优化等方面深入；实战型的或许有白板编程，大概就是“Talk is easy, show me the code”。因为公司已经默认面试者拥有了相关知识，所以深度和广度是有的，面试下来也不轻松。</p>
<h4 id="一些偏理论的问题"><a href="#一些偏理论的问题" class="headerlink" title="一些偏理论的问题"></a>一些偏理论的问题</h4><ol>
<li><p>什么是OC</p>
</li>
<li><p>什么是面向对象</p>
</li>
<li><p>OC和传统的面向对象语言有什么区别和优势</p>
</li>
<li><p>HTTP协议及HTTPS，能否保持长连接等</p>
</li>
<li><p>TCP/IP协议</p>
</li>
<li><p>设计模式</p>
</li>
<li><p>算法及数据结构</p>
</li>
<li><p>系统优化及界面优化等</p>
</li>
<li><p>block及delegate的深入理解</p>
</li>
<li><p>数据库相关</p>
</li>
</ol>
<p>抛出问题不是我们的风格，试着深入浅出的解决这些问题才是我们的目的。当然这些不会是全部，只是限于篇幅，本次先谈这些。更加详细的，我们下篇再谈。</p>
<h4 id="深入浅出，详细解答"><a href="#深入浅出，详细解答" class="headerlink" title="深入浅出，详细解答"></a>深入浅出，详细解答</h4><p><strong>1. 什么是OC</strong></p>
<p>OC语言在c语言的基础上，增加了一层最小的面向对象语法，完全兼容C语言，在OC代码中，可以混用c，甚至是c++代码。可以使用OC开发mac osx平台和iOS平台的应用程序。拓展名：c语言.c  OC语言.m  兼容C++.mm。</p>
<p>为了与c语言的关键字区分开来,基本上所有的关键字都是以@开头。基本类型：5种，增加了布尔类型，BOOL类型与其他类型的用法一致，BOOL类型的本质是char类型的，定义如下：</p>
<pre><code>Typedef signed char BOOL
</code></pre><p>宏定义:</p>
<pre><code>#define YES  (BOOL)1
#define NO   (BOOL)0
</code></pre><p>布尔类型的输出一般当做整数来用。</p>
<p>在OC中Nil相当于是null,也就是0（具体可以参考之前写的<a href="http://www.jianshu.com/p/9c0310845286" target="_blank" rel="external">《您所不知道的nil/Nil/NULL/NSNull的空与空》</a>）。程序编译连接过程为：源文件（.m）—(编译)—-&gt;目标文件（.0）—–（链接）—-&gt;可执行文件（.out）。</p>
<p>每个对象内部都默认有一个isa指针指向这个对象所使用的类。isa是对象中的隐藏指针，指向创建这个对象的类。OC做为一门面向对象语言，具有面向对象的语言特性，如封装、继承、多态。也具有静态语言的特性(如C++)，又有动态语言的效率(动态绑定、动态加载等)。</p>
<p>Apple公司领导着Objective-C语言的发展与维护，包括Objective-C运行时，Cocoa/Cocoa-Touch框架以及Objective-C语言的编译器。看上去Objective-C就如同以下一个云状图： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-7e363cd917357952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="云状图"></p>
<p>这个问题很大，可谈的东西很多，当面试者问这样的问题时，其实他不单单是想知道这个语言的一些知识点，除此之外是想了解您对OC的理解深度，更深的一层是想与面试者产生共鸣。基本上一个问题下来，面试者的水分就能挤出不少。这是不是一个好的问题，我不知道，但这确实是一个会被问到的问题。</p>
<p><strong>2. 什么是面向对象</strong></p>
<p>OC语言是面向对象的，c语言是面向过程的，面向对象和面向过程只是解决问题的两种思考方式，面向过程关注的是解决问题涉及的步骤，面向对象关注的是设计能够实现解决问题所需功能的类。</p>
<p>面向对象的编程方法具有四个基本特征：抽象，封装，继承和多态。</p>
<p>抽象是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。</p>
<p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。继承性很好的解决了软件的可重用性问题。</p>
<p>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。</p>
<p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。<strong>多态是依赖于接口的</strong>。</p>
<p>但是，在C++使用OOP的编程方式在一些场合未能提供最高性能。现在内存存取成为计算机性能的重要瓶颈，这个问题在C++设计OOP编程范式的实现方式之初并未能考虑周全。现时的OOP编程有可能不缓存友好（cache friendly），导致有时候并不能发挥硬件最佳性能。大概就是过度封装，多态增加cache miss的可能性，数据存取时导致载入缓存的浪费等。</p>
<p><strong>3. OC和传统的面向对象语言有什么区别和优势</strong></p>
<p>OC中方法的实现只能写在@implementation··@end中，对象方法的声明只能写在@interface···@end中间；对象方法都以-号开头，类方法都以+号开头；对象方法只能由对象来调用，类方法只能由类来调用，不能当做函数一样调用。函数属于整个文件，可以写在文件中的任何位置，包括@implementation··@end中，但写在@interface···@end会无法识别，函数的声明可以在main函数内部也可以在main函数外部。对象方法归类\对象所有；函数调用不依赖于对象；函数内部不能直接通过成员变量名访问对象的成员变量。</p>
<p>Objective-C的运行时是动态的，它能让你在运行时为类添加方法或者去除方法以及使用反射。 OC的动态特性表现为了三个方面：动态类型、动态绑定、动态加载。之所以叫做动态，是因为必须到运行时(run time)才会做一些事情。</p>
<p>动态类型，说简单点就是id类型。动态类型是跟静态类型相对的。像内置的明确的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(run time)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>
<p>动态绑定(dynamic binding)需要用到@selector/SEL。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去。这就是动态绑定，要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：<strong>SEL并不是C里面的函数指针</strong>，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找字自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。</p>
<p>动态加载就是根据需求动态地加载资源，在运行时加载新类。在运行时创建一个新类,只需要3步:<br>1、为 class pair分配存储空间 ,使用 objc_allocateClassPair函数<br>2、增加需要的方法使用class_addMethod函数,增加实例变量用class_addIvar<br>3 、用objc_registerClassPair函数注册这个类,以便它能被别人使用。</p>
<blockquote>
<p>使用这些函数请引#import <objc runtime.h=""></objc></p>
</blockquote>
<p><strong>4. HTTP协议及HTTPS，能否保持长连接等</strong></p>
<p>HTTP协议是客户端最常用到的协议了，HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。HTTPS是以安全为目标的HTTP通道，是HTTP的安全版。 在HTTP下加入SSL层。 HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息。http的连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。</p>
<p>Request和Response的格式：</p>
<pre><code>// 请求
GET / HTTP/1.1

Host:xxx.xxxx.com

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.10) Gecko/2016042316 Firefox/3.0.10

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-us,en;q=0.5

Accept-Encoding: gzip,deflate

Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7

Keep-Alive: 300

Connection: keep-alive

If-Modified-Since: Mon, 25 May 2016 03:19:18 GMT


//响应
HTTP/1.1 200 OK

Cache-Control: private, max-age=30

Content-Type: text/html; charset=utf-8

Content-Encoding: gzip

Expires: Mon, 25 May 2016 03:20:33 GMT

Last-Modified: Mon, 25 May 2016 03:20:03 GMT

Vary: Accept-Encoding

Server: Microsoft-IIS/7.0

X-AspNet-Version: 2.0.50727

X-Powered-By: ASP.NET

Date: Mon, 25 May 2016 03:20:02 GMT

Content-Length: 12173

消息体的内容（略）
</code></pre><p>HTTP/1.1的默认模式使用带流水线的持久连接。这种情况下，HTTP客户每碰到一个引用就立即发出一个请求，因而HTTP客户可以一个接一个紧挨着发出各个引用对象的请求。服务器收到这些请求后，也可以一个接一个紧挨着发出各个对象。如果所有的请求和响应都是紧挨着发送的，那么所有引用到的对象一共只经历1个RTT的延迟(而不是像不带流水线的版本那样，每个引用到的对象都各有1个RTT的延迟)。另外，带流水线的持久连接中服务器空等请求的时间比较少。与非持久连接相比，持久连接(不论是否带流水线)除降低了1个RTT的响应延迟外，缓启动延迟也比较小。其原因在于既然各个对象使用同一个TCP连接，服务器发出第一个对象后就不必再以一开始的缓慢速率发送后续对象。相反，服务器可以按照第一个对象发送完毕时的速率开始发送下一个对象。</p>
<p>参考书目：<a href="http://item.jd.com/11056556.html" target="_blank" rel="external">《HTTP权威指南》</a></p>
<p><strong>5. TCP/IP协议</strong></p>
<p>此处参考之前写的文章<a href="http://www.jianshu.com/p/3e4f3de18e3b" target="_blank" rel="external">《关于iOS socket都在这里了》</a> 。里面涵盖了常用到的TCP/IP协议的一些原理型知识。</p>
<p>参考书目：<a href="http://item.jd.com/11311644.html" target="_blank" rel="external">《TCP/IP详解》</a></p>
<p><strong>6. 设计模式</strong><br>代理模式：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现，即常用的delegate。优势是解耦合，敏捷原则是开放-封闭原则。</p>
<p>观察者模式：是一种通知方式，不关心谁去接收，只负责发布信息，即Notification通知中心、KVO。可以解耦合，实现的敏捷原则是接口隔离原则，开放-封闭原则。</p>
<p>单例模式：确保程序运行期某个类，只有一份实例，用于进行资源共享控制，使用简单，延时求值，易于跨模块。实现的敏捷原则是单一职责原则，例如[UIApplication sharedApplication]。</p>
<p>策略模式：定义算法族，封装起来，使他们之间可以相互替换，使算法的变化独立于使用算法的用户，如排序算法，NSArray的sortedArrayUsingSelector等，<strong>controller对view的实现也是一种策略模式</strong>。实现了接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。</p>
<p>工厂模式：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势是易于替换，面向抽象编程，工厂模式是抽象工厂的一部分，抽象工厂的实现依赖于具体工厂，工厂模式产生特定的品类，而抽象工厂可以产生很多不同的品类。实现了DIP依赖倒置原则。</p>
<p>参考书目：<a href="http://item.jd.com/10871643.html" target="_blank" rel="external">《Objective-C编程之道：iOS设计模式解析》</a><br><strong>7. 算法及数据结构</strong></p>
<p>技术运用得多熟练，决定你的当下水准，基础打得多好，决定你的发展上限。</p>
<p>最经典的就是反转二叉树了：</p>
<pre><code>+ (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode {
if (!rootNode) {  return nil; }
if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) {  return rootNode; }
NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
[queueArray addObject:rootNode]; //压入根节点
while (queueArray.count &gt; 0) {
BinaryTreeNode *node = [queueArray firstObject];
[queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
BinaryTreeNode *pLeft = node.leftNode;
node.leftNode = node.rightNode;
node.rightNode = pLeft;

if (node.leftNode) {
    [queueArray addObject:node.leftNode];
}
if (node.rightNode) {
    [queueArray addObject:node.rightNode];
}

}

return rootNode;
}
</code></pre><p>IOS常用数据结构有NSArray、NSMutableArray、NSDictionary、NSMutableDictionary等，这些基础知识就不细说了。不过，单向链表和双向链表关于插入和查询的效率问题还是要了解一些的。单向链表存储结构的节点中只有一个指向直接后继的指针域，双向链表的节点中有两个指针域，其中一个指向直接后继，另一个指向直接前驱。</p>
<p>单向链表增加删除节点简单，遍历时候不会死循环（双向也不会死循环，循环链表忘了进行控制的话很容易进入死循环）。缺点是只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。</p>
<p>双向链表可以找到前驱和后继，可进可退，缺点是增加删除节点复杂（其实就复杂一点点）</p>
<p>参考书目：<a href="http://item.jd.com/11098789.html" target="_blank" rel="external">《算法 第4版》</a><br><strong>8. 系统优化及界面优化等</strong></p>
<p>此处可以参考之前的文章<a href="http://www.jianshu.com/p/f4adce56166f" target="_blank" rel="external">《如何编写稳定流畅的iOS移动端应用》</a>,<a href="http://www.jianshu.com/p/d74398c50fe1" target="_blank" rel="external">《深刻理解移动端优化之离屏渲染》</a>,<a href="http://www.jianshu.com/p/393920b15539" target="_blank" rel="external">《不要过多的或者低效的使用NSNotification》</a>,这几篇文章对某些关键点已经尽力讲清楚了，篇幅有限，这里就不再复述了。</p>
<p><strong>9. block及delegate的深入理解</strong></p>
<p>此处可以参考我之前写的<a href="http://www.jianshu.com/p/bbccac805641" target="_blank" rel="external">block和delegate傻傻分不清楚</a>，自认为已经尽力讲清楚了一些原理，希望对您有所帮助。</p>
<p><strong>10. 数据库相关</strong></p>
<p>表面上SQLite将数据分为以下几种类型：integer : 整数、real : 实数（浮点数）、text : 文本字符串、blob : 二进制数据，比如文件，图片之类的。实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以设置类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer。</p>
<p>在一般开发过程中，使用的都是第三方开源库 <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a>，封装了基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。FMDB有三个主要的类：FMDatabase,一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句。FMResultSet，使用FMDatabase执行查询后的结果集。FMDatabaseQueue，用于在多线程中执行多个查询或更新，它是线程安全的。具体操作请移步gitHub。</p>
<hr>
<p>自认为问的太大的问题不是好问题，然而这些问题在大厂里确实是存在的。最后，您也可以参考我之前写的三篇文章，<a href="http://www.jianshu.com/p/8f16613861fa" target="_blank" rel="external">《那些著名或非著名的iOS面试题－前编》</a>,<a href="http://www.jianshu.com/p/7214f164141b" target="_blank" rel="external">《那些著名或非著名的iOS面试题－中编》</a>,<a href="http://www.jianshu.com/p/5178204a58d6" target="_blank" rel="external">《那些著名或非著名的iOS面试题－后编》</a>。这些从术的方面详细的介绍了一些iOS面试中常见的问题，当然在追求“术“的同时也不能忽略了”道“。</p>
<p>不论面试什么公司，态度一定要好，我不止一次的听同事说起“某某面试者太XX了”，虽然做技术的有些孤傲可以理解，但毕竟是工作嘛，工作时还是要一团和气。面试着装上自然就好，如果不是高级管理岗，西装革履的也没必要。怀着一颗阳光的心去拥抱一切吧。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-d7ab3168fa9a5a0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="看起来好累"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于众所周知的原因，最近的移动端开发有点供大于求，鉴于当前残酷的商业现状，向往年那样的需求量也不大可能，尤其是15年B和A都停止了社招工作，但是现在的大厂都不招人了吗？显然，那也未必，需求总是有的，不过是需求有了限制。&lt;/p&gt;
&lt;p&gt;一般接到面试邀请，公司已经默认您基本达到
    
    </summary>
    
    
      <category term="Interview" scheme="https://dangdangfeng.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>如何幽雅的谈论Hybrid App</title>
    <link href="https://dangdangfeng.github.io/2015/08/21/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BAHybrid-App/"/>
    <id>https://dangdangfeng.github.io/2015/08/21/如何优雅的谈论Hybrid-App/</id>
    <published>2015-08-21T15:40:19.000Z</published>
    <updated>2016-08-31T14:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>重要的并不是我们提供的信息量有多大，而是我们能否给他们提供真正需要的信息。             -《瞬间之美》</p>
</blockquote>
<p>本文涉及如下方面：</p>
<ul>
<li>什么是Hybrid架构(可略读)</li>
<li>Hybrid与Native的关系</li>
<li>设计上的考虑</li>
<li>一句话说明白</li>
<li>技术实现</li>
<li>Cordova</li>
</ul>
<hr>
<h4 id="Hybrid架构"><a href="#Hybrid架构" class="headerlink" title="Hybrid架构"></a>Hybrid架构</h4><blockquote>
<p>Hybrid App：Hybrid App is a mobile application that is coded in both browser-supported language and computer language. They are available through application distribution platforms such as the Apple App Store, Google Play etc. Usually, they are downloaded from the platform to a target device, such as iPhone, Android phone or Windows Phone. The subscribers need to install to run them.</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-3b19957dce0c01d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。Hybrid开发效率高、跨平台、低层本的特点，Hybrid从业务开发上讲，没有版本问题，对于BUG能及时修复。但Hybrid也是有缺点的，Hybrid体验比不上Native，同样的功能在性能上存在巨大差距。Web界面上JS对HTML Node的操作需要消耗大量的CPU资源，手机CPU的性能还不能与PC相提并论，就算在智能手机之间，硬件水准也参差不齐，一个可以在iPhone 6上流畅运行的界面，跑到三星上很可能就卡住不动了。所以我们经常可以发现一些富交互页面上的操作无法达到令人满意的流畅度，而流畅度也正是用户评价一款App优劣的最直观因素。所以混合式编程比较适用于需要快速试错、快速占领市场的团队，当然，也不是绝对。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-2d23bdaa9e7a426a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Hybrid App按网页语言与程序语言的混合，通常分为三种类型：多View混合型，单View混合型，Web主体型。</p>
<p>多View混合型即Native View和Web View独立展示，交替出现。这种应用混合逻辑相对简单。即在需要的时候，将WebView当成一个独立的View（Activity）运行起来，在WebView内完成相关的展示操作。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。</p>
<p>单View混合型即在同一个View内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单View混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。</p>
<p>Web主体型即移动应用的主体是Web View，主要以网页语言编写，穿插Native功能的Hybrid App开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。Web主体型的移动应用用户体验的好坏，主要取决于底层中间件的交互与跨平台的能力。国外的appMobi、PhoneGap和国内的WeX5、AppCan和Rexsee都属于Web主体型移动应用中间件。其中Rexsee不支持跨平台开发。appMobi和PhoneGap除基础的底层能力更多是通过<strong>插件（Plugins）</strong>扩展的机制实现Hybrid。AppCan除了插件机制，还提供了大量的单View混合型的接口来完善和弥补Web主体型Hybrid App体验差的问题，接近Native App的体验。而WeX5则在揉合PhoneGap和Bootstrap等主流技术的基础上，对性能进一步做了深度优化，不但完全具备Native App对本地资源的调用能力，性能体验也不输原生；WeX5所开发出来的app具备完全的跨端运行能力，可以无需任何修改直接运行在各种前端环境上。</p>
<p>多主体共存型（灵活型）是一种新型的开发模式，即支持Web主体型的应用，又支持以Native主体的应用，也支持两者混合的开发模式。比如kerkee框架 ，它具有跨平台、用户体验好、性能高、扩展性好、灵活性强、易维护、规范化、具有Debug环境、彻底解决跨域问题等特点。用户体验与Native App媲美。功能方面，开发者可随意扩展接口。</p>
<h4 id="Hybrid与Native的关系"><a href="#Hybrid与Native的关系" class="headerlink" title="Hybrid与Native的关系"></a>Hybrid与Native的关系</h4><p>在Hybrid架构设计中Native提供的是一宿主环境，实现合理的逻辑架构需要考虑：交互设计，资源访问，Hybrid开发调试，通讯设计、并发设计、异常处理、日志监控以及安全模块等问题，前端要做的事情就是封装Native提供的各种能力。</p>
<p>处理交互设计时需要考虑前端与Native配合处理，如H5与Native的互相跳转逻辑；<br>资源访问机制需要做到既能以file的方式访问Native内部资源，又能使用url的方式访问线上资源，处理好跳转的逻辑；需要提供前端资源增量替换机制，以摆脱APP迭代发版问题，避免用户升级APP，这里将涉及到静态资源在APP中的存放策略，更新策略的设计，以及服务器端的支持等。当然，有现成框架和解决方案的支持，但这些确实是不可忽略的问题。</p>
<p>Hybrid的交互是通过Native调用前端页面的JS方法，或者前端页面通过JS调用Native提供的接口实现的，两者交互的桥梁是Webview，iOS可以使用javascripbrige来实现（现成框架），在UIWebView的shouldStartLoadWithRequest方法里面捕获url的变化，解析出需要的参数，然后传给一个统一的处理方法。app自身可以自定义url schema，并且把自定义的url注册在调度中心。JS与Native通信可以创建这类URL被Native捕获处理，即schema跳转逻辑。APP安装后会在手机上注册一个schema，比如淘宝是taobao://，Native会有一个进程监控Webview发出的所有schema://请求，然后分发到“控制器”。hybridapi处理程序，Native控制器处理时会需要param提供的参数（encode过），根据实际需要处理业务逻辑问题。</p>
<h4 id="设计上的考虑"><a href="#设计上的考虑" class="headerlink" title="设计上的考虑"></a>设计上的考虑</h4><p>无论在Android还是iOS平台上，都有各自的一套交互习惯，包括视觉风格，界面切换，操作习惯等，与Web习惯完全不同。以iOS界面切换为例，系统风格是新界面自右向左推入，后退时界面自左向右推出，而旧界面保持状态。Web开发的默认习惯则是刷新页面，无论新载入页面或是后退，都会对页面进行刷新。因此使用Web模式开发多界面功能就面临这样的交互习惯差异，造成体验上的损失。当然Web方式也可模拟Native的交互方式，但这样的模拟首先提高了开发成本，有悖于最初的高效原则，从效果上看，也很难达到Native的流畅性。</p>
<h4 id="一句话说明白"><a href="#一句话说明白" class="headerlink" title="一句话说明白"></a>一句话说明白</h4><p>如果用一句话来讲明白这个问题，就是Hybrid混合式编程可以在Native原生应用的基础上通过一些Hybrid框架实现本地和JS的交互处理。在不影响性能的情况下，实现应用的动态化。</p>
<h4 id="技术实现原理"><a href="#技术实现原理" class="headerlink" title="技术实现原理"></a>技术实现原理</h4><p>Hybrid技术将静态资源存于Native，目录结构可以如下面划分，当然不是绝对的，基本要求是将对应版本的Hybrid插件下载到本地，存放方便就好。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-17f9fb8918c3d88c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>在正式的开发中，还要考虑增量机制，因为不同的版本会对应着不同的业务逻辑，真实的增量机制需要服务器端的配合，版本映射表是每次大版本APP发布时由服务器端生成。当APP启动时，APP会读取版本信息，如果发现本地版本号比线上的小，便会下载对应的zip文件，然后解压之后并且替换整个原有的文件，本次增量结束，因为所有的版本文件不会重复，APP回滚时可用回到任意想去的版本，也可以对任意版本做BUG修复。</p>
<p>以上，我们得知，Hybrid和Native交互可以通过两种方式：Url Schema和JavaScriptCore等地交互。H5与Native交互的桥梁为Webview，“联系”的方式以url schema的方式，在用户安装app后，app可以自定义url schema，并且把自定义的url注册在调度中心。</p>
<pre><code>demoschema://hybridapi?callback=hybrid_1446276509894&amp;param=%7B%22data1%22%3A1%2C%22data2%22%3A2%7D
</code></pre><p>App调用H5:将一组API绑定在webView的window对象上，App通过iOS原生方法调用window对象中的js方法。<br>H5与App通信：App实现对Webview URL的观察者模式，H5 通过改变URL的哈希值，通过解析哈希值的变化执行相应的操作。</p>
<p>另一种是JavaScriptCore，具体的可以看之前写的文章<a href="http://www.jianshu.com/p/bbfa8dee967e" target="_blank" rel="external">JavaScriptCore框架</a>。</p>
<pre><code>context[@&quot;makeUIColor&quot;] = ^(NSDictionary *rgbColor){
float red = [rgbColor[@&quot;red&quot;] floatValue];
float green = [rgbColor[@&quot;green&quot;] floatValue];
float blue = [rgbColor[@&quot;blue&quot;] floatValue];
return [UIColor colorWithRed:(red / 255.0)
                   green:(green / 255.0)
                    blue:(blue / 255.0)
                   alpha:1];
};
JSValue *color = [context evaluateScript:@&quot;makeUIColor({red: 50, green: 150, blue: 250})&quot;];
NSLog(@&quot;color:%@&quot;,[color toObject]);
</code></pre><p>通过这种方式就可以在JavaScript中调用Objective-C。</p>
<p>当然，除此之外也可以用JSBridge技术实现。<br>JS中：</p>
<pre><code> button.onclick = function(e) {
    e.preventDefault();
    var data = &apos;Hello from JS button&apos;;
    log(&apos;JS sending message&apos;, data);
    window.external.test1(data, &apos;haha&apos;);
}
</code></pre><p>通过JSBridge,执行本地类中的test1方法。此处只是一个引子，详细的会在另一篇文章中单独引出。</p>
<p>至于H5和Native的跳转问题，可以采用统跳协议来完成。这又是另外一个问题了。当然也可以在JS里定义跳转地址，通过JS交互来处理。</p>
<h4 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h4><p>写了那么久，感觉现在才进入主题。</p>
<p>Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。Cordova还提供了一组统一的JavaScript类库，以及为这些类库所用的设备相关的原生后台代码。</p>
<p>测试使用可以到Github上下载<a href="https://github.com/apache/cordova-ios" target="_blank" rel="external">源码</a>,也可以使用命令：</p>
<pre><code>cordova create hello com.example.hello HelloWorld
cd hello
cordova platform add ios
</code></pre><p>这样就创建了hello文件夹下的测试目录(com.example.hello 为应用程序的id名，与Xcode中类似，可以在 config.xml 中修改，如果不指定的话默认为 io.cordova.hellocordova)。</p>
<blockquote>
<p>目录文件说明：<br>config.xml ：cordova的配置文件<br>hooks/ ：存放自定义cordova命令的脚本文件。<br>platforms/ ：各个平台原生工程代码，会在build时被覆盖勿修改<br>plugins/ ：插件目录（主要是提供各个平台的原生API）<br>www/ ：用H5编写的源代码目录，build时会被放入各个平台的assets\www目录。<br>www/index.html ：App入口html文件</p>
</blockquote>
<p>在Xcode编译运行的话，使用的是 Staging 下面的html页面。</p>
<p>命令安装需要安装cordova命令</p>
<pre><code>brew install node //该命令执行后，自动装好node和npm。
brew upgrade node //更新node(可不执行)
</code></pre><p>为了解决校验码不正确问题。npm 使用国内镜像的方法 （三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p>
<pre><code>1.通过config命令
npm config set registry http://registry.cnpmjs.org npm info underscore （如果上面配置正确这个命令会有字符串response）
2.命令行指定
npm --registry http://registry.cnpmjs.org info underscore 
3.编辑 ~/.npmrc 加入下面内容
registry = http://registry.cnpmjs.org
</code></pre><p>之后：</p>
<pre><code>sudo npm install -g cordova
</code></pre><p>打开platform/ios里的HelloWorld.xcodeproj即可测试。</p>
<p>下面就是源码分析了，因为要对照着源码来说，大家可以到<a href="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse" target="_blank" rel="external">这里</a>(<a href="https://github.com/dangdangfeng/Cordova-Source-Code-Analyse)，参考我写的详细的源码分析。通过这里，写一个混合式App应该不是问题了。" target="_blank" rel="external">https://github.com/dangdangfeng/Cordova-Source-Code-Analyse)，参考我写的详细的源码分析。通过这里，写一个混合式App应该不是问题了。</a></p>
<p>最后，祝大家看的愉快！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;重要的并不是我们提供的信息量有多大，而是我们能否给他们提供真正需要的信息。             -《瞬间之美》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文涉及如下方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是Hybrid架构(可略读)&lt;/li&gt;

    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>谈谈C的性能特点</title>
    <link href="https://dangdangfeng.github.io/2015/07/01/%E8%B0%88%E8%B0%88C%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E7%82%B9/"/>
    <id>https://dangdangfeng.github.io/2015/07/01/谈谈C的性能特点/</id>
    <published>2015-06-30T16:48:11.000Z</published>
    <updated>2016-08-31T14:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>C语言是一种命令式语言（又称强制式语言，通过指明一系列可执行的运算及运算的次序来描述计算过程的语言），生于1972年的贝尔实验室。平时我们用的大多数语言（比如，C,C++,Java,C#,Python等）都是命令式语言，与它相对的是函数式语言(functional language)，如Haskell,Lisp。函数式语言更像数学，命令式语言更接近人的思维。</p>
<h4 id="C语言的特性"><a href="#C语言的特性" class="headerlink" title="C语言的特性"></a>C语言的特性</h4><p>C语言的典型特征是编译型语言(compiled language)（相对于解释型语言来说）、命令式的、人工管理内存 。对于编译型语言，程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接运行编译的结果就行了，<strong>因此效率高</strong>。 以此相对，解释型语言程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次，因此<strong>效率比较低</strong>。由此，当涉及到速度，内存，低层次特性(low-level features)如：移动stack pointer等常会使用C语言。</p>
<p>从内存的角度思考C语言，相对于其他语言，<strong>汇编语言直接操作内存；C、C++访问内存；Java,C#,Scheme/LISP,ML使用的是内存自动管理机制</strong>。 C语言通过堆(heap)和栈（stack）访问的内存，C函数将会分配到棧中，函数在被调用时进棧(pushed on to stack)， 函数在返回时出棧(popefd off the stack)，函数能访问当前棧顶部以下的所有内存；堆是一块儿用于动态内存分配的内存区域，可以把它想像称为一个巨大的数组 ，通过指针(pointer)来访问，如果操作系统允许，整个程序都能访问堆。C语言人工内存管理目的是允许程序能够分配内存用于当前的使用 ；当程序执行完后，能够释放内存，用于重新分配 ，C语言的标准类库中有malloc和free两个函数支持内存管理 。从内存的层面，C语言虽然使用起来更复杂些，但在可操作性上更好一些，毕竟自动内存管理，内存的释放不是立即的。</p>
<p>C语言比起其他的高级语言来说，更接近计算机，也就是说，它介于高级语言和汇编语言之间，通常来说比其他高级语言执行效率更高一点。当然，C语言的函数化特点（即所有C程序都是由函数构成）和灵活的语法也是吸引程序设计者的地方。</p>
<h4 id="C语言的优势"><a href="#C语言的优势" class="headerlink" title="C语言的优势"></a>C语言的优势</h4><p>C语言一共只有32个关键字，9种控制语句，程序书写形式自由，区分大小写。把高级语言的基本结构和语句与低级语言的实用性结合起来。C语言允许直接访问物理地址，可以直接对硬件进行操作，因此它既具有高级语言的功能，又具有低级语言的许多功能，C语言可以像汇编语言一样对<strong>位、字节和地址</strong>进行操作，而这三者是计算机最基本的工作单元，可用来写系统软件，又可用来开发应用软件，已成为一种通用程序设计语言。另外C语言具有强大的图形功能，支持多种显示器和驱动器。且计算功能、逻辑判断功能强大。    </p>
<p>C语言的运算符包含的范围很广泛，共有34种运算符。C语言把括号、赋值、强制类型转换等都作为运算符处理。从而使C语言的运算类型极其丰富，表达式类型多样化。灵活使用各种运算符可以实现在其它高级语言中难以实现的运算。 C语言的数据类型有：整型、实型、字符型、数组类型、指针类型、结构体类型、共用体类型等。能用来实现各种复杂的数据结构的运算。并引入了指针概念，使程序效率更高。    </p>
<p>C语言生成目标代码质量高，程序执行效率高，C语言描述问题比汇编语言迅速，工作量小、可读性好，易于调试、修改和移植，而代码质量与汇编语言相当。C语言一般只比汇编程序生成的目标代码效率低10%～20%。可移植性好，C语言在不同机器上的C编译程序，86%的代码是公共的，所以C语言的编译程序便于移植。在一个环境上用C语言编写的程序，不改动或稍加改动，就可移植到另一个完全不同的环境中运行。    </p>
<h4 id="当前新发明的语言Swift的比较"><a href="#当前新发明的语言Swift的比较" class="headerlink" title="当前新发明的语言Swift的比较"></a>当前新发明的语言Swift的比较</h4><p>Swift包含了很多现代语言特性尤其是从一些脚本语言如Javascript/Ruby中汲取了营养，此外苹果发布Swift时，使用特别选用的一些例子来宣称Swift性能对于Ojbective C的大幅提升（40~50%），如复杂对象排序等。但是开发者实际测试出来的情况却相反。实际数据显示，Swift在简单循环、递增、赋值、数组扩展、字符串拼接上性能远不如Objective C。可能的一个解释是Swift使用类classes，总在执行ARC（Auto Referrence Count），而Objective C则更多使用C风格的数据类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-8ef4897116759a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言是一种命令式语言（又称强制式语言，通过指明一系列可执行的运算及运算的次序来描述计算过程的语言），生于1972年的贝尔实验室。平时我们用的大多数语言（比如，C,C++,Java,C#,Python等）都是命令式语言，与它相对的是函数式语言(functional lang
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>iOS9之后我们需要关注的事情</title>
    <link href="https://dangdangfeng.github.io/2015/05/13/iOS9%E4%B9%8B%E5%90%8E%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>https://dangdangfeng.github.io/2015/05/13/iOS9之后我们需要关注的事情/</id>
    <published>2015-05-13T13:58:50.000Z</published>
    <updated>2016-09-01T13:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-cab02fd7bf9ee004.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS9"></p>
<h4 id="应用隐私控制-外部调用"><a href="#应用隐私控制-外部调用" class="headerlink" title="应用隐私控制-外部调用"></a>应用隐私控制-外部调用</h4><p>iOS9增加了隐私控制，自己的应用如果需要调用其它应用，需要在工程的info.plist中添加一个key为LSApplicationQueriesSchemes的数组值，里面包含需要添加白名单的string类型的scheme。即使用URL scheme将其加入白名单。如项目中使用了qq，微信等分享登录功能，需要添加的值为：</p>
<pre><code>mqqopensdkapiV2

mqqOpensdkSSoLogin

mqq

mqzoneopensdkapiV2

mqzoneopensdkapi19

mqzoneopensdkapi

mqzoneopensdk

mqzone

weixin

wechat ...
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1170656-ebd8251189201050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p>
<p>如果不添加该项，使用canOpenURL:判断应用是否安装时会报错。</p>
<pre><code>canOpenURL: failed for URL: &quot;mqqopensdkapiV2://qqapp&quot; - error: &quot;This app is not allowed to query for scheme mqqopensdkapiV2”
</code></pre><h4 id="bitcode"><a href="#bitcode" class="headerlink" title="bitcode"></a>bitcode</h4><p>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<p>Xcode7 默认开启了bitcode，如果App使用的第三方类库不支持bitcode会提示错误，只需要在”Build Settings”-&gt;”Enable Bitcode”选项中关闭bitcode即可。</p>
<p>开启Bitcode编译后，编译产生的文件体积会变大 (因为是中间代码，不是用户下载的包)，且dSYM文件不能用来崩溃日志的符号化 (用户下载的包是Apple服务重新编译产生的，有产生新的符号文件)。通过Archive方式上传AppStore的包，可以在 Xcode的Organizer工具中下载对应安装包的新的符号文件。</p>
<h4 id="改用更安全的HTTPS"><a href="#改用更安全的HTTPS" class="headerlink" title="改用更安全的HTTPS"></a>改用更安全的HTTPS</h4><p>如果在Xcode 7之前使用的时http请求，那么在XCode 7上编译的App是不能联网的。iOS9把所有的http请求都改为https了：iOS9系统发送的网络请求将统一使用TLS 1.2 SSL。采用TLS 1.2 协议，目的是 强制增强数据访问安全，而且 系统 Foundation 框架下的相关网络请求，将不再默认使用 Http 等不安全的网络协议，而默认采用 TLS 1.2。</p>
<p>修改方法是要么使服务器支持https访问，要么关闭https的使用。第一种方法对于个人开发者来说代价还是比较大的，第二种方法:在工程的Info.plist文件里添加NSAppTransportSecurity字典类型的，添加一个元素：key为NSAllowsArbitraryLoads，值为YES。</p>
<p><strong>什么是SSL/TLS</strong></p>
<p>HTTP+SSL/TLS+TCP = HTTPS<br>TLS 是 SSL 新的别称。SSL 3.0版本之后的迭代版本被重新命名为TLS 1.0。</p>
<p><strong>SSL/TLS协议解决的问题</strong></p>
<p>1.所有信息都是加密传播，第三方无法窃听。<br>2.具有校验机制，一旦被篡改，通信双方会立刻发现。<br>3.配备身份证书，防止身份被冒充。</p>
<p>iOS9中新增App Transport Security（简称ATS）特性, 主要使原来请求的时候用到的HTTP，都转向TLS1.2协议进行传输。这也意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。</p>
<p>在Info.plist新增一段用于控制ATS的配置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-fb1fd555239f1dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制ATS的配置"></p>
<p>这段配置中的NSAppTransportSecurity是ATS配置的根节点，配置了节点表示告诉系统要走自定义的ATS设置。而NSAllowsAritraryLoads节点则是控制是否禁用ATS特性，设置YES就是禁用ATS功能。</p>
<p>其实ATS并不单单针对HTTP进行了限制，而是对HTTPS也有一定的要求，如果你希望自己所有的域名，除了一些已知并不会使用ATS之外的，所有通信都使用ATS。这种情况下你可以指定一些不使用ATS的特殊情况，而其余的情况使用ATS。对于这种场景，可以使用<em>NSExceptionDomains</em>来标识使用ATS默认设置的域。<br>以QQdemo为例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-22799f250b4ed42e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQdemo"></p>
<p>其中NSIncludesSubdomains设置为YES表示子级域名都使用相同设置。NSExceptionRequiresForwardSecrecy为NO由于不支持ForwardSecrecy，因此屏蔽掉改功能。最后NSExceptionAllowInsecureHTTPLoads设置为YES，则表示允许访问没有证书或者是自签名、过期、主机名不匹配的证书引发的错误的域名（这里检查过QQ的证书貌似没有什么问题，但是还是需要设置此项才允许访问）。这是比较严谨的做法，指定了能访问哪些特定的HTTP。</p>
<h4 id="forward-secrecy"><a href="#forward-secrecy" class="headerlink" title="forward secrecy"></a>forward secrecy</h4><p>中文可叫做前向保密。perfect forward secrecy,叫做完全前向保密,要求一个密钥只能访问由它所保护的数据；用来产生密钥的元素一次一换，不能再产生其他的密钥；一个密钥被破解，并不影响其他密钥的安全性。</p>
<p><strong>支持Forward Secrecy的加密方式</strong></p>
<pre><code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-cab02fd7bf9ee004.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
    
      <category term="杂谈" scheme="https://dangdangfeng.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发的奇技淫巧</title>
    <link href="https://dangdangfeng.github.io/2015/03/25/iOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>https://dangdangfeng.github.io/2015/03/25/iOS开发的奇技淫巧/</id>
    <published>2015-03-25T15:09:53.000Z</published>
    <updated>2016-08-31T15:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-c0163bdc4c2cce56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="JSON返回空值"><a href="#JSON返回空值" class="headerlink" title="JSON返回空值"></a>JSON返回空值</h4><p>开发过程中，我们通过http请求，后台返回json数据，而有时数据里某一字段的值为null，然后我们把此值赋值给NSArray,NSdictionary,或是NSString会判断此值为null，做的处理通常是：</p>
<pre><code>if(dict == nil)或是if(dict == Nil)或是if(dict == NULL)再或是if(dict isEqual nil)
</code></pre><p>但事实并不这么简单。<br>当字典，数组为null时，后台打印的输出结果是这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-fb00347741f564bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这就需要在代码判断时利用[NSNull null]来判断。</p>
<pre><code>if(![location isEqual:[NSNull null]]){
 NSLog(@&quot;YES&quot;);
}
</code></pre><p>空字符串或数组中一个为空，会打印:<null> 。代表着这是一个空字符串，赋值为空，指针是存在的，只是内容为空。在iOS上，内容为空不能简单的判断str==null（null 在ios上得用[NSNull null]）。</null></p>
<p>赋值为nil,可以直接用＝＝nil来判断，相当于空指针。打印为：（null）</p>
<p>控制台打印：</p>
<pre><code>str=（null） 
</code></pre><p>代表着 字符串或数组或字典是一个空指针，（而非空字符串）判断的时候，直接用：</p>
<pre><code>if(str == nil)
</code></pre><p>就可以了。</p>
<h4 id="内存泄露压力测试"><a href="#内存泄露压力测试" class="headerlink" title="内存泄露压力测试"></a>内存泄露压力测试</h4><p>用 dispatch 写个小函数，方便测试。</p>
<pre><code>func dipatch_forever(duration: Double, _ queue : dispatch_queue_t, _ block : dispatch_block_t){ 
   let time = dispatch_time(DISPATCH_TIME_NOW, Int64(duration * Double(NSEC_PER_SEC))) 
       dispatch_after(time, queue) {
        block() 
        dipatch_forever(duration, queue, block) 
      }
}

func main_dipatch_forever(duration: Double, _ block : dispatch_block_t) { 
 dipatch_forever(duration, dispatch_get_main_queue(), block)
 }
</code></pre><p>每当怀疑某界面或函数有问题。就随手写个回调，不断地 push 界面，pop 界面。或者不断地用随机数调用某些函数。或者创建删除对象。</p>
<pre><code>main_dipatch_forever(0.0) {
// Do something
}
</code></pre><p>这样界面或函数中稍微有内存泄露，或者程序不稳定。就会很容易看到内存飞快地涨或程序直接崩掉。经得起这种压力测试的，那段程序基本会很稳定（正确性需要额外测）。</p>
<h4 id="更改iphone的键盘颜色："><a href="#更改iphone的键盘颜色：" class="headerlink" title="更改iphone的键盘颜色："></a>更改iphone的键盘颜色：</h4><p>UIKeyboardTypeNumberPad，UIKeyboardTypePhonePad只有这2种数字键盘才有效果。</p>
<p><strong>键盘外观</strong></p>
<pre><code>typedef enum {
UIKeyboardAppearanceDefault, // 默认外观：浅灰色
UIKeyboardAppearanceAlert, //深灰/石墨色
} UIKeyboardAppearance;

 textView.keyboardAppearance ＝ UIKeyboardAppearanceAlert ;

- (void)textViewDidBeginEditing:(UITextView *)textView{

NSArray *ws = [[UIApplication sharedApplication] windows];

for(UIView *w in ws){

NSArray *vs = [w subviews];

for(UIView *v in vs) {
if([[NSString stringWithUTF8String:object_getClassName(v)] isEqualToString:@&quot;UIKeyboard&quot;]){
v.backgroundColor = [UIColor redColor];
}
}
}
</code></pre><p><strong>自动大写</strong></p>
<pre><code>typedef enum {
UITextAutocapitalizationTypeNone, //不自动大写
UITextAutocapitalizationTypeWords, //单词首字母大写
UITextAutocapitalizationTypeSentences, //句子首字母大写
UITextAutocapitalizationTypeAllCharacters, //所有字母大写
} UITextAutocapitalizationType;

用法用例：textField.autocapitalizationType = UITextAutocapitalizationTypeWords;
</code></pre><p><strong>自动更正</strong></p>
<pre><code>typedef enum {
UITextAutocorrectionTypeDefault,//默认
UITextAutocorrectionTypeNo,//不自动更正
UITextAutocorrectionTypeYes,//自动更正
} UITextAutocorrectionType;

用法用例：textField.autocorrectionType = UITextAutocorrectionTypeYes;
</code></pre><p>####查看一段代码的执行时间</p>
<pre><code>#define Begin   NSDate *startTime = [NSDate date]
#define Go   NSLog(@&quot;Time: %f&quot;, -[startTime timeIntervalSinceNow])
</code></pre><p>查看执行时间的代码的地方进行这么处理</p>
<pre><code>Begin
//do your work here
Go
</code></pre><h4 id="锯齿化问题"><a href="#锯齿化问题" class="headerlink" title="锯齿化问题"></a>锯齿化问题</h4><p>在使用view的缩放的时候，layer.border.width随着view的放大，会出现锯齿化的问题，解决这个问题需要设置这个属性。</p>
<pre><code>self.layer.allowsEdgeAntialiasing = YES;
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1170656-f253d04c96ef1226.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>####关于关键字volatile</p>
<p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。就像大家更熟悉的const一样，volatile是一个类型修饰符。它是被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。</p>
<p>Volatile变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile变量的最新值。Volatile变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。</p>
<p>出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile变量而不是锁。当使用 volatile变量而非锁时，某些习惯用法更加易于编码和阅读。此外，volatile变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile变量还可以提供优于锁的性能优势。</p>
<p><strong>代码示例</strong></p>
<pre><code>volatile int i=10; 
int j = i; 
... 
int k = i; 
</code></pre><p>volatile 告诉编译器i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的可执行码会重新从i的地址读取数据放在k中。编译器在产生release版可执行码时会进行编译优化，加volatile关键字的变量有关的运算，将不进行编译优化。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在k中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问，不会出错。</p>
<pre><code>int square(volatile int *ptr) { return *ptr * *ptr; } 
</code></pre><p>这段代码的目的是用来返指针<em>ptr指向值的平方，但是，由于</em>ptr指向一个volatile型参数，编译器将产生类似下面的代码： </p>
<pre><code>int square(volatile int *ptr) { 
int a,b; 
a = *ptr; 
b = *ptr; 
return a * b;
} 
</code></pre><p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p>
<pre><code>long square(volatile int *ptr) { int a; a = *ptr; return a * a; } 
</code></pre><p><strong>下面是volatile变量的几个使用：</strong><br>• 并行设备的硬件寄存器（如：状态寄存器）<br>• 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>• 多线程应用中被几个任务共享的变量</p>
<p><strong>那么问题来了：</strong><br>• 一个参数既可以是const还可以是volatile吗？答案是是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>
<p>• 一个指针可以是volatile 吗？答案是是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。</p>
<p><strong>在编写多线程程序中使用volatile的关键点：</strong><br>1.将所有的共享对象声明为volatile；<br>2.不要将volatile直接作用于基本类型；<br>3.当定义了共享类的时候，用volatile成员函数来保证线程安全；<br>在多线程中，我们可以利用锁的机制来保护好资源临界区。在临界区的外面操作共享变量则需要volatile，在临界区的里面则non-volatile了。</p>
<h4 id="关键字const的位置"><a href="#关键字const的位置" class="headerlink" title="关键字const的位置"></a>关键字const的位置</h4><p>const意味着”只读”，分析下面的含义：</p>
<pre><code>const int a;
int const a;// 前两个的作用是一样，a是一个常整型数。
const int *a;// 第三个意味着a是一个指向常整型数的指针（整型数是不可修改的，但指针可以）
int * const a;// 第四个意思a是一个指向整型数的常指针（指针指向的整型数是可以修改的，但指针是不可修改的）
int const * const a;// a是一个指向常整型数的常指针（指针指向的整型数是不可修改的，同时指针也是不可修改的）。表示a是一个指针常量，初始化的时候必须固定指向一个int常量或者int变量，之后就不能再指向别的地方了，它总是把它所指向的目标当作一个int常量。也可以写成const int* const a;含义相同。
</code></pre><p>合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。这样可以减少bug的出现。欲阻止一个变量被改变，可以使用 const 关键字。</p>
<p>在定义 const 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；对指针来说，可以指定指针本身为 const，也可以指定指针所指的数据为 const，或二者同时指定为 const；在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；对于类的成员函数，若指定其为 const 类型，则表明其是一个常函数，不能修改类的成员变量；对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。</p>
<h4 id="滑动的时候隐藏navigation-bar"><a href="#滑动的时候隐藏navigation-bar" class="headerlink" title="滑动的时候隐藏navigation bar"></a>滑动的时候隐藏navigation bar</h4><pre><code>navigationController.hidesBarsOnSwipe = Yes;
</code></pre><h4 id="消除导航条返回键带的title"><a href="#消除导航条返回键带的title" class="headerlink" title="消除导航条返回键带的title"></a>消除导航条返回键带的title</h4><pre><code>[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)
                                                 forBarMetrics:UIBarMetricsDefault];
</code></pre><h4 id="将Navigationbar变成透明而不模糊"><a href="#将Navigationbar变成透明而不模糊" class="headerlink" title="将Navigationbar变成透明而不模糊"></a>将Navigationbar变成透明而不模糊</h4><pre><code>[self.navigationController.navigationBar setBackgroundImage:[UIImage new]
                         forBarMetrics:UIBarMetricsDefault];
self.navigationController.navigationBar .shadowImage = [UIImage new];
self.navigationController.navigationBar .translucent = YES;
</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</p>
<h4 id="用一个pan手势来代替UISwipegesture的各个方向"><a href="#用一个pan手势来代替UISwipegesture的各个方向" class="headerlink" title="用一个pan手势来代替UISwipegesture的各个方向"></a>用一个pan手势来代替UISwipegesture的各个方向</h4><pre><code>- (void)pan:(UIPanGestureRecognizer *)sender
{
typedef NS_ENUM(NSUInteger, UIPanGestureRecognizerDirection) {
UIPanGestureRecognizerDirectionUndefined,
UIPanGestureRecognizerDirectionUp,
UIPanGestureRecognizerDirectionDown,
UIPanGestureRecognizerDirectionLeft,
UIPanGestureRecognizerDirectionRight
};

static  UIPanGestureRecognizerDirection direction = UIPanGestureRecognizerDirectionUndefined;

switch (sender.state) {
case  UIGestureRecognizerStateBegan: {
if  (direction == UIPanGestureRecognizerDirectionUndefined) {
CGPoint velocity = [sender velocityInView:recognizer.view];
BOOL isVerticalGesture = fabs(velocity.y) &gt; fabs(velocity.x);
if (isVerticalGesture) {
    if (velocity.y &gt; 0) {
    direction = UIPanGestureRecognizerDirectionDown;
    }    
    else  {
    direction = UIPanGestureRecognizerDirectionUp;
    }
}
else{ 
if (velocity.x &gt; 0) {
direction = UIPanGestureRecognizerDirectionRight;
}
else
{
direction = UIPanGestureRecognizerDirectionLeft;
}
}
}
break ;
}

case UIGestureRecognizerStateChanged: {
switch (direction) {
case UIPanGestureRecognizerDirectionUp: {
[self handleUpwardsGesture:sender];
break ;
}

case UIPanGestureRecognizerDirectionDown: {
[self handleDownwardsGesture:sender];
break;
}

case  UIPanGestureRecognizerDirectionLeft: {
[self handleLeftGesture:sender];
break;
}

case UIPanGestureRecognizerDirectionRight: {
[self handleRightGesture:sender];
break ;
}
default : {
break;
}
}
break;
}

case  UIGestureRecognizerStateEnded: {
direction = UIPanGestureRecognizerDirectionUndefined;  
break;
}

default:
break;
}
}
</code></pre><h4 id="拉伸图片不变形"><a href="#拉伸图片不变形" class="headerlink" title="拉伸图片不变形"></a>拉伸图片不变形</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-9c32b9138380e54c.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>等同于：</p>
<pre><code>[[UIImage imageNamed:@&quot;&quot;] stretchableImageWithLeftCapWidth:10 topCapHeight:10];
[[UIImage imageNamed:@&quot;&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10)];
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-c0163bdc4c2cce56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
    
    </summary>
    
    
      <category term="skill" scheme="https://dangdangfeng.github.io/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>从UIWindow谈起</title>
    <link href="https://dangdangfeng.github.io/2014/12/30/%E4%BB%8EUIWindow%E8%B0%88%E8%B5%B7/"/>
    <id>https://dangdangfeng.github.io/2014/12/30/从UIWindow谈起/</id>
    <published>2014-12-30T13:55:55.000Z</published>
    <updated>2016-09-01T13:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一篇名为<a href="http://www.jianshu.com/p/0c637f496ec9" target="_blank" rel="external">iOS视图成像解构</a>的文章,<a href="http://www.jianshu.com/p/0c637f496ec9" target="_blank" rel="external">iOS视图成像解构</a>主要是结合各种工具来分析程序中视图在不同布局下产生的一些问题，今天主要讲一些原理上的东西，结合今天的内容，对您以后开发中视图显示出现的问题可能会有些帮助。</p>
<h4 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h4><p>下面先看看Apple的官方文档</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-fc6677d242b61837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Apple官方文档"></p>
<p>UIWindow继承自UIView，UIWindow是一种特殊的UIView，通常在一个程序中只会有一个UIWindow，但可以手动创建多个UIWindow，同时加到程序里面。即使有多个UIWindow对象，也只有一个UIWindow可以接受到用户的触屏事件（即主窗口）。</p>
<p>iOS程序启动完毕后，先创建Application，再创建它的代理，之后创建UIWindow（创建的第一个对象是UIApplication），接着创建控制器的view，最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了。</p>
<p>一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow。也就说，没有UIWindow，就看不见任何UI界面。</p>
<h4 id="主窗口和次窗口"><a href="#主窗口和次窗口" class="headerlink" title="主窗口和次窗口"></a>主窗口和次窗口</h4><pre><code>【self.window makekeyandvisible】让窗口成为主窗口，并且显示出来。有这个方法，才能把信息显示到屏幕上。
</code></pre><p>   因为Window有makekeyandvisible这个方法，可以让这个Window凭空的显示出来，而其他的view没有这个方法，所以它只能依赖于Window，Window显示出来后，view才依附在Window上显示出来。</p>
<pre><code>【self.window make keywindow】//让uiwindow成为主窗口，但不显示。
</code></pre><p>次窗口，需要定义一个Window属性来保存变量。 window的属性定义为strong，就是为了让其不销毁， 一个应用程序只能有一个主窗口。只有主窗口才能响应键盘的输入事件，如果不能输入内容，可以查看是否是显示在主窗口上，不在主窗口上的不能响应。</p>
<h4 id="WindowLevel"><a href="#WindowLevel" class="headerlink" title="WindowLevel"></a>WindowLevel</h4><p>UIWindow有三个层级，分别是Normal，StatusBar，Alert。Normal级别是最低的，StatusBar处于中等水平，Alert级别最高。而通常我们的程序的界面都是处于Normal这个级别上的，系统顶部的状态栏应该是处于StatusBar级别，UIActionSheet和UIAlertView这些通常都是用来中断正常流程，提醒用户等操作，因此位于Alert级别。</p>
<p>根据window显示级别优先的原则，级别高的会显示在上面，级别低的在下面，我们程序正常显示的view位于最底层。</p>
<p>当Level层级相同的时候，只有第一个设置为KeyWindow的显示出来，后面同级的再设置KeyWindow也不会显示。UIWindow在显示的时候是不管KeyWindow是谁，都是Level优先的，即Level最高的始终显示在最前面。</p>
<h4 id="UIWindow是显示的起点"><a href="#UIWindow是显示的起点" class="headerlink" title="UIWindow是显示的起点"></a>UIWindow是显示的起点</h4><p>1.UIWindow对象是所有UIView的根，管理和协调应用程序的显示。<br>2.UIViewController对象负责管理所有UIView的层次结构，并响应设备的方向变化。<br>3.UIView对象定义了一个屏幕上的一个矩形区域，同时处理该区域的绘制和触屏事件。可以在这个区域内绘制图形和文字，还可以接收用户的操作。一个UIView的实例可以包含和管理若干个子UIView。</p>
<h4 id="UIWindow在程序中的作用"><a href="#UIWindow在程序中的作用" class="headerlink" title="UIWindow在程序中的作用"></a>UIWindow在程序中的作用</h4><p>1.作为容器，包含app所要显示的所有视图<br>2.传递触摸消息到程序中view和其他对象<br>3.与UIViewController协同工作，方便完成设备方向旋转的支持</p>
<h4 id="storyboard项目中的创建过程"><a href="#storyboard项目中的创建过程" class="headerlink" title="storyboard项目中的创建过程"></a>storyboard项目中的创建过程</h4><p>当用户点击应用程序图标的时候，先执行Main函数，执行UIApplicationMain(),根据其第三个和第四个参数创建Application，创建代理，并且把代理设置给application（看项目配置文件info.plist里面的storyboard的name，根据这个name找到对应的storyboard），开启一个事件循环，当程序加载完毕，他会调用代理的didFinishLaunchingWithOptions:方法。在调用didFinishLaunchingWithOptions:方法之前，会加载storyboard，在加载的时候创建一个window，接下来会创建箭头所指向的控制器，把该控制器设置为UIWindow的根控制器，接下来再将window显示出来，即看到了运行后显示的界面。</p>
<h4 id="rootViewController和addSubview的不同"><a href="#rootViewController和addSubview的不同" class="headerlink" title="rootViewController和addSubview的不同"></a>rootViewController和addSubview的不同</h4><p>创建一个控制器，把view添加到uiwindow上面有两种方式<br><strong>1.rootViewController</strong><br>　rootViewController是UIWindow的一个遍历方法，通过设置该属性为要添加view对应的ViewController，UIWindow将会自动将其view添加到当前window中，同时负责ViewController和view的生命周期的维护，防止其过早释放</p>
<p><strong>2.addSubview</strong><br>　直接将view通过addSubview方式添加到window中，程序负责维护view的生命周期以及刷新，但是并不会为去理会view对应的ViewController，因此采用这种方法将view添加到window以后，我们还要保持view对应的ViewController的有效性，不能过早释放。</p>
<p>提示：不通过控制器的view也可以做开发，但是在实际开发中，不要这么做，不要直接把view添加到UIWindow上面去。因为，难以管理。以后的开发中，建议使用rootViewController。</p>
<h4 id="UIView有关图层布局的方法"><a href="#UIView有关图层布局的方法" class="headerlink" title="UIView有关图层布局的方法"></a>UIView有关图层布局的方法</h4><p>一个 UIView 里面可以包含许多的 Subview（其他的 UIView），而这些 Subview 彼此之间是有层级关系的。<br><strong>1.新增Subview</strong> </p>
<pre><code>[UIView addSubview:Subview];     //替UIView增加一个Subview 
</code></pre><p><strong> 2.移动图层</strong><br>在UIView中将Subview往前或是往后移动一个图层，往前移动会覆盖住较后层的 Subview，而往后移动则会被较上层的Subview所覆盖。</p>
<pre><code>[UIView bringSubviewToFront:Subview];       //将Subview往前移动一个图层（与它的前一个图层对调位置）
[UIView sendSubviewToBack:Subview];      //将Subview往后移动一个图层（与它的后一个图层对调位置） 
</code></pre><p><strong>3.交换两个Subview彼此的图层层级</strong></p>
<pre><code>[UIView exchangeSubviewAtIndex:indexA withSubviewAtIndex:indexB];    //交换两个图层
</code></pre><p><strong>4.取得子视图在UIView中的索引值（Index ）</strong></p>
<pre><code>NSInteger index = [[UIView subviews] indexOfObject:Subview名称];       //取得Index
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1170656-c6fc927c9d65a964.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="怀念乔布斯"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了一篇名为&lt;a href=&quot;http://www.jianshu.com/p/0c637f496ec9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS视图成像解构&lt;/a&gt;的文章,&lt;a href=&quot;http://www.jianshu.com/p
    
    </summary>
    
    
      <category term="技术" scheme="https://dangdangfeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>OC的内存管理</title>
    <link href="https://dangdangfeng.github.io/2014/11/01/OC%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://dangdangfeng.github.io/2014/11/01/OC的内存管理/</id>
    <published>2014-11-01T13:47:24.000Z</published>
    <updated>2016-09-01T13:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>内存管理四句箴言：</p>
<p>自己生成的自己持有<br>非自己生成的对象自己也可持有<br>不再需要自己持有时释放<br>非自己持有的对象无法释放</p>
</blockquote>
<p>Objective-C中的内存管理机制跟C语言中指针的内容是同样重要的，要开发一个程序并不难，但是优秀的程序则更测重于内存管理，它们往往占用内存更少，运行更加流畅。在Xcode4.2及之后的版本中由于引入了ARC（Automatic Reference Counting）机制,程序编译时Xcode可以自动给你的代码添加内存释放代码。内存管理是开发中不可忽略的一块，虽然ARC帮我们节省了很多精力，不过作为一名合格的开发人员，最基本的知识还是要理解的。</p>
<h4 id="自持与不自持"><a href="#自持与不自持" class="headerlink" title="自持与不自持"></a>自持与不自持</h4><p>在开发中，如果使用了alloc,new,copy,mutableCopy或以其开头的方法名，意味着自己生成的对象只有自己持有，如：allocMyJob,newItName,copyAfter,mutableCopyYourName。但是以allocate,newer,copying,mutableCopyed开头的是不自己持有的，很明显它们是假冒的。</p>
<p>以下为例：</p>
<pre><code>id obj = [NSMutableArray array]; // 取得非自己生成并持有的对象
</code></pre><p>取得的对象存在，但自己并不持有对象。NSMutableArray类对象被赋给变量obj,但变量obj自己并不持有该对象。持有时需要用retain方法，如：</p>
<pre><code>id obj = [NSMutableArray array]; 
[obj retain];
</code></pre><p>通过retain,非自己用alloc等生成的对象也可以自己持有了。</p>
<p>不需要时，使用release释放，对象一经释放就不可访问了。用alloc/new/copy/mutableCopy持有和retain持有的对象，不需要时一定要用release释放。</p>
<p>同理使用如allocObject也可以取得自己持有对象。</p>
<pre><code>id obj1 = [obj0 allocObject];
</code></pre><p>当使用autorelease时，即是取得了对象存在，但是自己不持有对象。如：</p>
<pre><code>- (id)object
{
id obj = [[NSObject alloc] init]; //自己持有对象
[obj autorelease];
return obj;// 取得的对象存在，但自己不持有
}
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/1170656-b57663af5fa31350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="autorelease"></p>
<h4 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h4><p>[NSMutableArray array]就是因为用了autorelease使得谁都不持有的。当然再次使用retain就持有了。程序里的所有autorelease pool是以桟（stack）的形式组织的。新创建的pool位于桟的最顶端。当发送autorelease消息给一个对象时，这个对象被加到栈顶的那个pool中。发送drain给一个pool时，这个pool里所有对象都会受到release消息，而且如果这个pool不是位于栈顶，那么位于这个pool“上端”的所有pool也会受到drain消息。</p>
<p>[pool drain] 和 [pool release] 的区别：<br>release，在引用计数环境下，由于NSAutoReleasePool是一个不可以被retain的类型，所以release会直接dealloc pool对象。当pool被dealloc的时候，pool向所有在pool中的对象发出一个release的消息，如果一个对象在这个pool中autorelease了多次，pool对这个对象的每一次autorelease都会release。在GC(garbage-collected environment)环境下release是一个no-op操作（代表没有操作，是一个占据进行很少的空间但是指出没有操作的计算机指令）。</p>
<p>drain，在引用计数环境下，它的行为和release是一样的。在GC的环境下，这个方法调用objc_collect_if_needed 触发GC。重点是：在GC环境下，release是一个no-op，所以除非你不希望在GC环境下触发GC，你都应该使用drain而不是使用release来释放pool。原文如下：</p>
<blockquote>
<p>drain</p>
<p>In a reference-counted environment, releases and pops the receiver; in a garbage-collected environment, triggers garbage collection if the memory allocated since the last collection is greater than the current threshold.     - (void)drain</p>
<p>Discussion<br><strong>In a reference-counted environment, this method behaves the same as release. </strong>Since an autorelease pool cannot be retained (see retain<br>), this therefore causes the receiver to be deallocated. When an autorelease pool is deallocated, it sends a release message to all its autoreleased objects. If an object is added several times to the same pool, when the pool is deallocated it receives a release message for each time it was added.In a garbage-collected environment, this method ultimately calls objc_collect_if_needed.</p>
<p>Special Considerations<br>In a garbage-collected environment, release is a no-op, so unless you do not want to give the collector a hint it is important to use drain in any code that may be compiled for a garbage-collected environment.</p>
</blockquote>
<p>对于iOS来说drain和release的作用其实是一样的。</p>
<p>一个对象被加到一个pool很多次，只要多次发送autorelease消息给这个对象就可以；同时，当这个pool被回收时，这个对象也会收到同样多次release消息。简单地可以认为接收autorelease消息等同于：接收一个retain消息，同时加入到一个pool里；这个pool用来存放这些暂缓回收的对象；一旦这个pool被回收（drain），那么pool里面的对象会收到同样次数的release消息。－UIKit框架已经帮你自动创建一个autorelease pool。大部分时候，你可以直接使用这个pool，不必自己创建；所以你给一个对象发送autorelease消息，那么这个对象会加到这个UIKit自动创建的pool里。</p>
<p>某些时候，可能需要创建一个pool：<br>1.没有使用UIKit框架或者其它内含autorelease pool的框架，那么要使用pool，就要自己创建。</p>
<p>2.如果一个循环体要创建大量的临时变量，那么创建自己的pool可以减少程序占用的内存峰值。（如果使用UIKit的pool，那么这些临时变量可能一直在这个pool里，只要这个pool受到drain消息；完全不使用autorelease pool应该也是可以的，可能只是要发一些release消息给这些临时变量，所以使用autorelease pool还是方便一些）</p>
<p>3.创建线程时必须创建这个线程自己的autorelease pool。－使用alloc和init消息来创建pool，发送drain消息则表示这个pool不再使用。pool的创建和drain要在同一上下文中，比如循环体内。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>ObjC中没有垃圾回收机制，在ObjC中内存的管理是依赖对象引用计数器来进行的：在ObjC中每个对象内部都有一个与之对应的整数（retainCount），叫“引用计数器”，当一个对象在创建之后它的引用计数器为1，当调用这个对象的alloc、retain、new、copy方法之后引用计数器自动在原来的基础上加1（OC中调用一个对象的方法就是给这个对象发送一个消息），当调用这个对象的release方法之后它的引用计数器减1，如果一个对象的引用计数器为0，则系统会自动调用这个对象的dealloc方法来销毁这个对象。手动管理内存有时候并不容易，因为对象的引用有时候是错综复杂的，对象之间可能互相交叉引用，此时需要遵循一个法则：<strong>谁创建，谁释放</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;内存管理四句箴言：&lt;/p&gt;
&lt;p&gt;自己生成的自己持有&lt;br&gt;非自己生成的对象自己也可持有&lt;br&gt;不再需要自己持有时释放&lt;br&gt;非自己持有的对象无法释放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C中的内存管理机制跟C语言中指针的
    
    </summary>
    
    
      <category term="技术" scheme="https://dangdangfeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Category不会想当然</title>
    <link href="https://dangdangfeng.github.io/2014/10/31/Category%E4%B8%8D%E4%BC%9A%E6%83%B3%E5%BD%93%E7%84%B6/"/>
    <id>https://dangdangfeng.github.io/2014/10/31/Category不会想当然/</id>
    <published>2014-10-31T15:19:54.000Z</published>
    <updated>2016-08-31T15:20:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-b15065b256cabc84.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Category用于向已经存在的类添加方法从而达到扩展已有类的目的，在很多情形下Category也是比创建子类更优的选择。Category用于大型类有效分解。新添加的方法会被被扩展的类的所有子类自动继承。Category也可以用于替代这个已有类中某个方法的实体，从而达到修复BUG的目的。如此就不能去调用已有类中原有的那个被替换掉方法实体了。需要注意的是，当准备有Category来替换某一个方法的时候，一定要保证实现原来方法的所有功能，否则这种替代就是没有意义而且会引起新的BUG。</p>
<p>Category的方法不一定非要在@implementation中实现，也可以在其他位置实现，但是当调用Category的方法时，依据继承树没有找到该方法的实现，程序则会崩溃。Category理论上不能添加变量，但是可以使用@dynamic 来弥补这种不足。</p>
<pre><code> @implementation NSObject (Category)
 @dynamic variable;
 - (id) variable
 {
 return objc_getAssociatedObject(self, externVariableKey);
 }
 - (void)setVariable:(id) variable
{
 objc_setAssociatedObject(self, externVariableKey, variable,
 OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre><p>和子类不同的是，Category不能用于向被扩展类添加实例变量。Category通常作为一种组织框架代码的工具来使用。如果需要添加一个新的变量，则需添加子类。如果只是添加一个新的方法，用Category是比较好的选择。</p>
<h4 id="runtime对category的加载过程"><a href="#runtime对category的加载过程" class="headerlink" title="runtime对category的加载过程"></a>runtime对category的加载过程</h4><p>下面是runtime中category的结构：</p>
<pre><code>struct _category_t {
const char *name; // 类的名字
struct _class_t *cls; // 要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象
const struct _method_list_t *instance_methods; // 实例方法
const struct _method_list_t *class_methods; // 类方法
const struct _protocol_list_t *protocols; // 这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的
const struct _prop_list_t *properties; // 这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用objc_setAssociatedObject和objc_getAssociatedObject方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。
};
</code></pre><p>category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，不论有没有import category 的.h，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程。runtime加载完成后，category的原始信息在类结构里将不会存在。</p>
<p>objc runtime的加载入口是一个叫_objc_init的方法，在library加载前由libSystem dyld调用，进行初始化操作。调用map_images方法将文件中的image map到内存。调用_read_images方法初始化map后的image，这里面干了很多的事情，像load所有的类、协议和category，著名的+ load方法就是这一步调用的。category的初始化，循环调用了_getObjc2CategoryList方法。</p>
<p>在调用完_getObjc2CategoryList后，runtime终于开始了category的处理，首先分成两拨，一拨是实例对象相关的调用addUnattachedCategoryForClass，一拨是类对象相关的调用addUnattachedCategoryForClass，然后会调到attachCategoryMethods方法，这个方法把一个类所有的category_list的所有方法取出来组成一个method_list_t ，这里是倒序添加的，也就是说，新生成的category的方法会先于旧的category的方法插入。</p>
<p>生成了所有method的list之后，调用attachMethodLists将所有方法前序添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法覆盖了，但被覆盖的方法确实还在那里。</p>
<pre><code>static void attachCategoryMethods(class_t *cls, category_list *cats,
                  BOOL *inoutVtablesAffected)
{
if (!cats) return;
if (PrintReplacedMethods) printReplacements(cls, cats);

BOOL isMeta = isMetaClass(cls);
method_list_t **mlists = (method_list_t **)
    _malloc_internal(cats-&gt;count * sizeof(*mlists));

// Count backwards through cats to get newest categories first
int mcount = 0;
int i = cats-&gt;count;
BOOL fromBundle = NO;
while (i--) {
    method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);
    if (mlist) {
        mlists[mcount++] = mlist;
        fromBundle |= cats-&gt;list[i].fromBundle;
    }
}

attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);

_free_internal(mlists);

}
</code></pre><p>这也即是我们上面说的Category修复Bug的原理。</p>
<h4 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h4><p>Extension非常像是没有命名的类别。扩展只是用来定义类的私有方法的，实现要在原始的.m里面。还以用来改变原始属性的一些性质。一般的时候，Extension都是放在.m文件中@implementation的上方。 Extension中的方法必须在@implementation中实现，否则编译会报错。Category没有源代码的类添加方法，格式：定义一对.h和.m。Extension作用于管理类的所有方法，格式：把代码写到原始类的.m文件中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-b15065b256cabc84.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>移动端优化之离屏渲染</title>
    <link href="https://dangdangfeng.github.io/2014/09/27/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
    <id>https://dangdangfeng.github.io/2014/09/27/移动端优化之离屏渲染/</id>
    <published>2014-09-27T14:00:19.000Z</published>
    <updated>2016-09-01T14:01:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-56254b398efc6894.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="渲染.jpg"></p>
<p>相比于当前屏幕渲染，离屏渲染的代价是很高的，这也是iOS移动端优化的必要部分。</p>
<p>OpenGL中，GPU屏幕渲染有以下两种方式：</p>
<p>1.On-Screen Rendering<br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>
<p>2.Off-Screen Rendering<br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p>一般情况下，OpenGL会将应用提交到Render Server的动画直接渲染显示（基本的Tile-Based渲染流程），但对于一些复杂的图像动画的渲染并不能直接渲染叠加显示，而是需要根据Command Buffer分通道进行渲染之后再组合，这一组合过程中，就有些渲染通道是不会直接显示的；Masking渲染需要更多渲染通道和合并的步骤；而这些没有直接显示在屏幕的上的通道就是Offscreen Rendering Pass。</p>
<p>Offscreen Render为什么卡顿，Offscreen Render需要更多的渲染通道，而且不同的渲染通道间切换需要耗费一定的时间，这个时间内GPU会闲置，当通道达到一定数量，对性能也会有较大的影响。</p>
<h4 id="离屏渲染的触发"><a href="#离屏渲染的触发" class="headerlink" title="离屏渲染的触发"></a>离屏渲染的触发</h4><p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。</p>
<p>离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。</p>
<p>如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。</p>
<p>然而，这是一个权衡。第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。然而，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。</p>
<p>离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。</p>
<p>Instrument 的 Core Animation 工具有一个叫做<em>Color Offscreen-Rendered Yellow</em>的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查<em>Color Hits Green and Misses Red</em>选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。</p>
<p>一般情况下，你需要避免离屏渲染，因为这是很大的消耗。直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。因为这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。</p>
<p>所以当你打开<em>Color Offscreen-Rendered Yellow</em>后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。</p>
<p>同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。</p>
<p>如果你使用 layer 的方式会通过屏幕外渲染，你最好摆脱这种方式。为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。</p>
<p>至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。</p>
<p>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。</p>
<h4 id="离屏渲染的体现"><a href="#离屏渲染的体现" class="headerlink" title="离屏渲染的体现"></a>离屏渲染的体现</h4><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<p>1.创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</p>
<p>2.上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</p>
<p>那哪些情况会Offscreen Render呢？</p>
<pre><code>1) drawRect
2) layer.shouldRasterize = true;
3) 有mask或者是阴影(layer.masksToBounds, layer.shadow*)；
 3.1) shouldRasterize（光栅化）
 3.2) masks（遮罩）
 3.3) shadows（阴影）
 3.4) edge antialiasing（抗锯齿）
 3.5) group opacity（不透明）
4) Text（UILabel, CATextLayer, Core Text, etc）...
</code></pre><p> 注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。</p>
<p>需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。</p>
<p>而其它属性如果是开启的，就不会有缓存，离屏绘制会在每一帧都发生。</p>
<h4 id="另一种特殊的“离屏渲染”方式：CPU渲染"><a href="#另一种特殊的“离屏渲染”方式：CPU渲染" class="headerlink" title="另一种特殊的“离屏渲染”方式：CPU渲染"></a>另一种特殊的“离屏渲染”方式：CPU渲染</h4><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地<br>完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<h4 id="当前屏幕渲染、离屏渲染、CPU渲染的选择"><a href="#当前屏幕渲染、离屏渲染、CPU渲染的选择" class="headerlink" title="当前屏幕渲染、离屏渲染、CPU渲染的选择"></a>当前屏幕渲染、离屏渲染、CPU渲染的选择</h4><p>1.尽量使用当前屏幕渲染<br>鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。</p>
<p>2.离屏渲染 VS CPU渲染<br>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一方面来说，一部分（通过drawRect并且使用任何CoreGraphics来实现的绘制，或使用CoreText[其实就是使用CoreGraphics]绘制）的确涉及到了“离屏绘制”，但是这和我们通常说的那种离屏绘制是有区别的。当你实现drawRect方法或者通过CoeGraphics绘制的时候，其实你是在使用CPU绘制。并且这个绘制的过程会在你的App内同步地进行。基本上你只是调用了一些向位图缓存内写入一些二进制信息的方法而已。</p>
<p>而另外一种形式离屏绘制是发生在绘制服务（是独立的处理过程）并且同时通过GPU执行（这里就不是像前面提到的用CPU了）。当OpengGL的绘制程序在绘制每个layer的时候，有可能因为包含多子层级关系而必须停下来把他们合成到一个单独的缓存里。你可能认为GPU应该总是比CPU牛逼一点，但是在这里我们还是需要慎重的考虑一下。因为对GPU来说，从当前屏幕（on-screen）到离屏（off-screen）上下文环境的来回切换（这个过程必须flush管线和光栅），代价是非常大的。因此对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。所以如果你正在尝试处理一些复杂的层级，并且在犹豫到底用-[CALayer setShouldRasterize:]还是通过CoreGraphics来绘制层级上的所有内容，唯一的方法就是测试并且进行权衡。</p>
<p>有机会，我们下次再谈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-56254b398efc6894.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
    
      <category term="技术" scheme="https://dangdangfeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>从代码看一个程序员的笔力</title>
    <link href="https://dangdangfeng.github.io/2014/08/31/%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8B%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AC%94%E5%8A%9B/"/>
    <id>https://dangdangfeng.github.io/2014/08/31/从代码看一个程序员的笔力/</id>
    <published>2014-08-30T16:38:23.000Z</published>
    <updated>2016-08-30T16:39:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>从代码的整洁度上就可以看出一个程序员的实力，规范其实就是让你养成一种良好习惯的标杆，在此面前我们应该顺从（本篇以OC为例）。</p>
<ol>
<li><p>单页代码最好控制在800行以内，每个方法最好不要超过100行，过多建议对代码进行重构</p>
</li>
<li><p>相同的逻辑方法定义避免在多个地方出现，尽量将公用的类、方法抽取出来</p>
</li>
<li><p>删除未被使用的代码，不要大片注释未被使用的代码，确定代码不会使用，请及时删除</p>
</li>
<li><p>对其他项目中copy过来的代码，根据具体需要更新代码风格，及时删除未被使用的代码</p>
</li>
<li><p>项目中所有Group或者文件名称（图片名字等），不要使用汉字命名，尽量使用英文命名，国内特有名词可以使用拼音。</p>
</li>
<li><p>项目中所有Group都需要在项目目录中存在一个真实的目录，Group中的文件与真实目录中文件一一对应。</p>
</li>
<li><p>请在项目中写必要代码的注释</p>
</li>
<li><p>请多使用 #pragma mark - Mark Name 对方法进行分组 。如:</p>
<pre><code>#pragma mark - **********View lifeCycle******
</code></pre></li>
<li><p>所有类名称以项目工程开头命名，如：“JS”（简书）。针对不同视图控制器，在末尾添加后缀，如： UIButton 后缀添加“Button”或大家皆知的简写，NSArray的变量命名为xxxArray等。</p>
</li>
<li><p>类、方法、属性等命名，做到见名知意，采用驼峰式命名规则。</p>
</li>
<li><p>根据资源类型或者所属业务逻辑对项目资源进行分组，使得整个项目结构清晰明了；整个项目保持一种代码书写风格。</p>
</li>
<li><p>避免在程序中直接出现常数，使用超过一次的应以宏定义的形式来替代。常数的宏定义应与它实际使用时的类型相一致。如以3.0来定义浮点类型，用3表示整型。 常量的命名应当能够表达出它的用途，并且用大写字母表示。例如：</p>
<pre><code>#define PI 3.1415926
</code></pre></li>
<li><p>当使用条件语句编码时，不要嵌套if语句，多个返回语句也是OK。</p>
<pre><code>- (void)testMethod {
   if (![testSome boolValue]) {// 不合适就返回，下面做处理
   return;
  }
 //Do something important
}
</code></pre></li>
<li><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<pre><code>NSError *error;
if (![self trySomethingWithError:&amp;error]) {
  // Handle Error
}
</code></pre></li>
<li><p>当参数过长时，每个参数占用一行，以冒号对齐。如：</p>
<pre><code>- (void)aboutFisrtNumber:(NSString *)oneStr
          withNextNumber:(NSString *)twoStr
          withLastNumber:(NSString *)threeStr{
// do something
}
</code></pre></li>
<li><p>一行很长的代码应该分成两行代码，下一行用两个空格隔开</p>
<pre><code>self.productsRequest = [[JSProductsRequest alloc] 
  initWithProductIdentifiers:productIdentifiers];
</code></pre></li>
<li><p>删除多余的空行，所有方法与方法之间空1行，所有代码块之间空1行。变量声明后需要空1行，如果需要分类区别，各类别之间空1行。条件、循环，选择语句，整个语句结束，需要空1行。最后一个括弧之前不空行。注释与代码之间不空行。</p>
<pre><code>#pragma 与方法之间空1行
</code></pre></li>
<li><p>每行代码最多不得超过100个字</p>
</li>
<li><p>如果类声明中包含多个protocol，每个protocol占用一行，缩进2个字符如:</p>
<pre><code>@interface BootViewController : UITableViewController&lt;&lt;/p&gt;
UITableViewDelegate,
UITableViewDataSource,
UITextFieldDelegate,
UITextViewDelegate
&gt;{
// code
}
</code></pre></li>
<li><p>图片命名：采用单词全拼，或者大家公认无岐义的缩写(比如：nav，bg，btn等)；采用“模块+功能”命名法，模块分为公共模块、私有模块。公共模块主要包括统一的背景，导航条，标签，公共的按钮背景，公共的默认图等等；私有模块主要根据app的业务；功能模块划分，比如用户中心，消息中心等。建议背景图采用以bg作前缀，按钮背景采用btn作前缀。</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-798d683d4df650ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从代码的整洁度上就可以看出一个程序员的实力，规范其实就是让你养成一种良好习惯的标杆，在此面前我们应该顺从（本篇以OC为例）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单页代码最好控制在800行以内，每个方法最好不要超过100行，过多建议对代码进行重构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;
    
    </summary>
    
    
      <category term="method" scheme="https://dangdangfeng.github.io/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的谈论OC</title>
    <link href="https://dangdangfeng.github.io/2014/08/30/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%B0%88%E8%AE%BAOC/"/>
    <id>https://dangdangfeng.github.io/2014/08/30/如何优雅的谈论OC/</id>
    <published>2014-08-30T15:35:30.000Z</published>
    <updated>2016-08-30T15:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文包括：</p>
<ul>
<li>OC的面向对象</li>
<li>运行时Runtime</li>
<li>运行循环RunLoop</li>
<li>事件响应链</li>
<li>引用计数</li>
<li>生命周期</li>
<li>与其他语言的区别</li>
</ul>
<hr>
<p>Objective-C 简称OC（下面以此代称），是在C语言的基础上，增加了一层最小的面向对象语言。是一种静态输入的语言，即“必须先声明数据中每个变量（或者容器）的数据类型”。但它是一个动态语言，代码中的某一部分可以在app运行的时候被扩展和修改（比如，在被编译之后）。OC完全兼容C语言，在代码中，可以混用c，甚至是c++代码。</p>
<h3 id="面向对象三原则（封装，继承，多态）"><a href="#面向对象三原则（封装，继承，多态）" class="headerlink" title="面向对象三原则（封装，继承，多态）"></a>面向对象三原则（封装，继承，多态）</h3><p>面向对象具有四个基本特征：抽象，封装，继承和多态。</p>
<p>C语言是面向过程的语言(关注的是函数)，OC,C++,JAVA,C#,PHP,Swift是面向对象的，面向过程关注的是解决问题涉及的步骤，而面向对象关注的是设计能够实现解决问题所需功能的类。抽象是面向对象的思想基础。</p>
<p>抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。抽象是一种思想，封装继承和多态是这种思想的实现。</p>
<h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>封装是把过程和数据包围起来（即函数和数据结构，函数是行为，数据结构是描述），有限制的对数据的访问。面向对象基于这个基本概念开始的（<em>因为面向对象更注重的是类</em>），即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。但是封装会导致并行效率问题，因为执行部分和数据部分被绑定在一起，制约了并行程度。面向对象思想将函数和数据绑在一起，扩大了代码重用时的粒度。而且封装下的拆箱装箱过程中也会导致内存的浪费。</p>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>继承是一种层次模型，允许和鼓励类的<em>重用</em>，并提供了一种明确表述<em>共性</em>的方法。新类继承了原始类的特性，新类称为原始类的派生类（子类和父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。继承性很好的解决了软件的可重用性问题。但是，不恰当地使用继承导致的最大的一个缺陷特征就是高耦合（即“牵一发而动全身”，是设计类时<em>层次</em>没分清导致的）。解决方案是用组合替代继承。将模块拆开，然后通过定义好的接口进行交互，一般来说可以选择Delegate模式来交互。使用继承其实是如何给一类对象划分层次的问题。在正确的继承方式中，父类应当扮演的是底层的角色，子类是上层的业务。父类只是给子类提供服务，并不涉及子类的业务逻辑；层级关系明显，功能划分清晰；父类的所有变化，都需要在子类中体现，此时耦合已经成为需求。</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括<em>参数化多态性和包含多态性</em>。很好的解决了应用程序函数同名问题，多态一般都要跟继承结合起来说，其本质是子类通过覆盖或重载父类的方法，来使得对同一类对象同一方法的调用产生不同的结果。覆盖是对接口方法的实现，继承中也可能会在子类覆盖父类中的方法。重载，是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样）； 但继承会引入多态使用混乱的境况并产生耦合，更好的方法是使用接口。通过IOP将子类与可能被子类引入的不相关逻辑剥离开来，提高了子类的可重用性，降低了迁移时可能的耦合。接口规范了子类哪些必须实现，哪些可选实现。那些不在接口定义的方法列表里的父类方法，事实上就是不建议覆重的方法。如果引入多态之后导致对象角色不够单纯，那就不应当引入多态，如果引入多态之后依旧是单纯角色，那就可以引入多态；如果要覆重的方法是角色业务的其中一个组成部分，那么就最好不要用多态的方案，用IOP，因为在外界调用的时候其实并不需要通过多态来满足定制化的需求。</p>
<h3 id="动态性（Runtime）"><a href="#动态性（Runtime）" class="headerlink" title="动态性（Runtime）"></a>动态性（Runtime）</h3><p>Objective-C 是面相运行时的语言，它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。使用Runtime可以按需要把消息重定向给合适的对象，交换方法的实现等等。</p>
<p>Runtime简称运行时，其中最主要的是消息机制，是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。。OC的函数调用称为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</p>
<p>如：</p>
<pre><code>[obj makeText];
＝＝》
objc_msgSend(obj,@selector(makeText));
</code></pre><p>编译器执行上述转换。在objc_msgSend函数中，首先通过obj的isa指针找到obj对应的class。每个对象内部都默认有一个isa指针指向这个对象所使用的类。isa是对象中的隐藏指针，指向创建这个对象的类。在Class中先去cache中通过SEL查找对应函数method（cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若cache中未找到,再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</p>
<h4 id="动态性的三方面"><a href="#动态性的三方面" class="headerlink" title="动态性的三方面"></a>动态性的三方面</h4><p>OC的动态特性表现为了三个方面：动态类型、动态绑定、动态加载。之所以叫做动态，是因为必须到运行时(runtime)才会做一些事情。</p>
<p>动态类型，就是id类型。动态类型是跟静态类型相对的。内置的基本类型都属于静态类型(int、NSString等)。静态类型在编译的时候就能被识别出来（即前面说的静态输入）。所以，若程序发生了类型不对应，编译器就会发出警告。而动态类型就编译器编译的时候是不能被识别的，要等到运行时(runtime)，即程序运行的时候才会根据语境来识别。所以这里面就有两个概念要分清：编译时跟运行时。</p>
<p>动态语言和静态语言的一个区别是静态语言提前编译好文件，即所有的逻辑已在编译时确定，运行时直接加载编译后的文件；而动态语言是在运行时才确定实现。典型的静态语言是C＋＋，动态语言包括OC，JAVA，C#等；因为静态语言提前编译好了执行文件，也就是通常所说的静态语言效率较高的原因。</p>
<p>动态绑定(dynamic binding)需要用到@selector/SEL。先来看看“函数”，对于其他一些静态语言，比如c++,一般在编译的时候就已经将要调用的函数的函数签名都告诉编译器了。静态的，不能改变。而在OC中，其实是没有函数的概念的，我们叫“消息机制”，所谓的函数调用就是给对象发送一条消息。这时，动态绑定的特性就来了。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。要实现他就必须用SEL变量绑定一个方法。最终形成的这个SEL变量就代表一个方法的引用。这里要注意一点：SEL并不是C里面的函数指针，虽然很像，但真心不是函数指针。SEL变量只是一个整数，他是该方法的ID。以前的函数调用，是根据函数名，也就是字符串去查找函数体。但现在，我们是根据一个ID整数来查找方法，整数的查找自然要比字符串的查找快得多！所以，动态绑定的特定不仅方便，而且效率更高。</p>
<p>动态加载就是根据需求动态地加载资源，在运行时加载新类。在运行时创建一个新类,只需要3步:</p>
<p>1、为 class pair分配存储空间 ,使用 objc_allocateClassPair函数</p>
<p>2、增加需要的方法使用class_addMethod函数,增加实例变量用class_addIvar</p>
<p>3 、用objc_registerClassPair函数注册这个类,以便它能被别人使用。</p>
<h5 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h5><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP类似函数指针，指向具体的Method实现。</p>
<p>用 method_exchangeImplementations 来交换2个方法中的IMP，<br>用 class_replaceMethod 来修改类，<br>用 method_setImplementation 来直接设置某个方法的IMP，归根结底，都是偷换了selector的IMP。</p>
<h3 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h3><p>RunLoop是一让线程能随时处理事件但不退出的机制。RunLoop实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。一个runloop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。</p>
<p>RunLoop的四个作用为:使程序一直运行接受用户输入;决定程序在何时应该处理哪些Event;调用解耦;节省CPU时间。</p>
<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）。</p>
<p>主线程的runloop默认是启动的。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>NSRunLoop是一种更加高明的消息处理模式，在对消息处理过程进行了更好的抽象和封装，不用处理一些很琐碎很低层次的具体消息的处理，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使你的线程在有工作的时候工作，没有工作的时候休眠，可以大大节省系统资源。</p>
<p>对其它线程来说，runloop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。在任何一个Cocoa程序的线程中，都可以通过：</p>
<pre><code>NSRunLoop   *runloop = [NSRunLoop currentRunLoop];
</code></pre><p>获取到当前线程的runloop。</p>
<p>Cocoa中的NSRunLoop类并不是线程安全的<br>我们不能在一个线程中去操作另外一个线程的runloop对象，那很可能会造成意想不到的后果。但是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的runloop完全可以混合使用。Cocoa中的NSRunLoop类可以通过实例方法：</p>
<pre><code>- (CFRunLoopRef)getCFRunLoop;
</code></pre><p>获取对应的CFRunLoopRef类，来达到线程安全的目的。</p>
<p>Runloop的管理并不完全是自动的。我们仍必须设计线程代码以在适当的时候启动runloop并正确响应输入事件，当然前提是线程中需要用到runloop。而且，我们还需要使用while/for语句来驱动runloop能够循环运行，下面的代码就成功驱动了一个run loop：</p>
<pre><code>BOOL isRunning = NO;
do {
 isRunning = [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDatedistantFuture]];
} while (isRunning);
</code></pre><p>Runloop同时也负责autorelease pool的创建和释放<br>在使用手动的内存管理方式的项目中，会经常用到很多自动释放的对象，如果这些对象不能够被即时释放掉，会造成内存占用量急剧增大。Runloop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。</p>
<p><strong>系统默认注册了5个Mode:</strong></p>
<p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>
<p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>
<p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
<p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>
<p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>
<p><strong>轮播图中的NSTimer问题</strong><br>创建定时器：</p>
<pre><code>1：NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(changeImage) userInfo:nil repeats:YES];
</code></pre><p>此方法创建的定时器，必须加到NSRunLoop中。</p>
<pre><code>NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; 
[runLoop addTimer:timer forMode: NSRunLoopCommonModes];
</code></pre><p> forMode的参数有两种类型可供选择：<code> NSDefaultRunLoopMode ， NSRunLoopCommonModes</code>，第一个参数为默认参数，当下面有textView，textfield等控件时，拖拽控件，此时轮播器会停止轮播，是因为NSRunLoop的原因，NSRunLoop为一个死循环，实时监测有无事件响应，如果当前线程就是主线程，也就是UI线程时，某些UI事件，比如UIScrollView的拖动操作，会将Run Loop切换成NSEventTrackingRunLoopMode模式，在这个过程中，默认的NSDefaultRunLoopMode模式中注册的事件是不会被执行的。NSRunLoopCommonModes 能够在多线程中起作用，这个模式等效于NSDefaultRunLoopMode和NSEventTrackingRunLoopMode的结合，这也是将modes换为NSRunLoopCommonModes便可解决的原因。</p>
<pre><code>2： self.timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(changeImage) userInfo:nil repeats:YES];
</code></pre><p>此种创建定时器的方式，默认加到了runloop，且默认为第二个参数。</p>
<p><strong>main函数的运行</strong></p>
<p>在main.m中：</p>
<pre><code>int main(int argc, char *argv[])
{
   @autoreleasepool {
     return UIApplicationMain(argc, argv, nil, NSStringFromClass([appDelegate class]));
  }
}
</code></pre><p>UIApplicationMain() 函数会为main thread 设置一个NSRunLoop 对象，这就解释了app应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p>仅当在为你的程序创建辅助线程的时候，你才需要显式运行一个runloop。Runloop是程序主线程基础设施的关键部分,所以，Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动runloop。IOS程序中UIApplication的run方法（或Mac OS X中的NSApplication）作为程序启动步骤的一部分，它在程序正常启动的时候就会启动程序的主循环。如果你使用xcode提供的模板创建你的程序，那你永远不需要自己去显式的调用这些例程。</p>
<p>对于辅助线程，你需要判断一个runloop是否是必须的。如果是必须的，那么你要自己配置并启动它。你不需要在任何情况下都去启动一个线程的runloop。比如，你使用线程来处理一个预先定义的长时间运行的任务时，你应该避免启动runloop。Runloop在你要和线程有更多的交互时才需要，比如以下情况：</p>
<p>1.使用端口或自定义输入源来和其他线程通信;</p>
<p>2.使用线程的定时器;</p>
<p>3.Cocoa中使用任何performSelector…的方法;</p>
<p>4.使线程周期性工作;</p>
<h3 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h3><p>对于IOS设备用户来说，操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：</p>
<p>1、触屏事件（Touch Event）</p>
<p>2、运动事件（Motion Event）</p>
<p>3、远端控制事件（Remote-Control Event）</p>
<p>事件的传递和响应分两个链：</p>
<p>传递链：由系统向离用户最近的view传递。</p>
<blockquote>
<p>UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view</p>
</blockquote>
<p>响应链：由离用户最近的view向系统传递。</p>
<blockquote>
<p>initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application</p>
</blockquote>
<p>响应者链（Responder Chain）:由多个响应者对象连接起来的链条，作用是能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</p>
<p>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。</p>
<p>UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。</p>
<p><strong>响应者链有以下特点：</strong></p>
<p>1、响应者链通常是由视图（UIView）构成的；</p>
<p>2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；</p>
<p>3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；</p>
<p>4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点；</p>
<p>5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
<p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用<code>hitTest:withEvent:</code>方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用<code>hitTest:withEvent:</code>，此方法会在其视图层级结构中的每个视图上调用<code>pointInside:withEvent:</code>（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果<code>pointInside:withEvent:</code>返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。</p>
<p><code>hitTest:withEvent:</code>方法的处理流程如下:</p>
<p>首先调用当前视图的<code>pointInside:withEvent:</code>方法判断触摸点是否在当前视图内；若返回NO,则<code>hitTest:withEvent:</code>返回nil;若返回YES,则向当前视图的所有子视图(subviews)发送<code>hitTest:withEvent:</code>消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则<code>hitTest:withEvent:</code>方法返回此对象，处理结束；如所有子视图都返回非，则<code>hitTest:withEvent:</code>方法返回自身(self)。</p>
<h3 id="引用计数器（ARC-和-MRC）"><a href="#引用计数器（ARC-和-MRC）" class="headerlink" title="引用计数器（ARC 和 MRC）"></a>引用计数器（ARC 和 MRC）</h3><p>ARC:自动引用计数器(Automatic Reference Counting)</p>
<p>MRC:手动引用计算器（由于现在几乎不用了，不做过多解说）</p>
<p>Objective-c中提供了两种内存管理机制MRC（MannulReference Counting）和ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。Xcode 4.1及其以前版本没有ARC。</p>
<p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain,release和autorelease。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease调用）的变量进行管理，当内存紧张时回收内存。<br>（1） retain，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;<br>（2） release，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;<br>（3） autorelease，该方法是将该对象内存的管理放到autoreleasepool中。</p>
<p>在ARC中与内存管理有关的标识符，可以分为变量标识符和属性标识符，对于变量默认为<code>__strong</code>，而对于属性默认为<code>unsafe_unretained</code>。也存在autoreleasepool。</p>
<p>其中assign/retain/copy与MRC下property的标识符意义相同，strong类似与retain,assign类似于<code>unsafe_unretained</code>，<code>strong/weak/unsafe_unretained</code>与ARC下变量标识符意义相同，只是一个用于属性的标识，一个用于变量的标识(带两个下划短线__)。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong>app应用程序有5种状态：</strong></p>
<p>Not running未运行：程序没启动。</p>
<p>Inactive未激活：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</p>
<p>Active激活：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。</p>
<p>Backgroud后台：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<p>Suspended挂起：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
<p>iOS的入口在main.m文件的main函数，根据UIApplicationMain函数，程序将进入AppDelegate.m，这个文件是xcode新建工程时自动生成的。AppDelegate.m文件，关乎着应用程序的生命周期。</p>
<p>1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。</p>
<p>2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。</p>
<p>3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。</p>
<p>4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。</p>
<p>5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。</p>
<p>6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。</p>
<p>初次启动：</p>
<p>iOS_didFinishLaunchingWithOptions</p>
<p>iOS_applicationDidBecomeActive</p>
<p>按下home键：</p>
<p>iOS_applicationWillResignActive</p>
<p>iOS_applicationDidEnterBackground</p>
<p>点击程序图标进入：</p>
<p>iOS_applicationWillEnterForeground</p>
<p>iOS_applicationDidBecomeActive</p>
<p>当应用程序进入后台时,应该保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死。释放尽可能释放的内存。</p>
<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
</code></pre><p>方法有大概5秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。</p>
<p>如果还需要长时间的运行任务，可以在该方法中调用</p>
<pre><code>[application beginBackgroundTaskWithExpirationHandler:^{ 

NSLog(@&quot;begin Background Task With Expiration Handler&quot;); 

}];
</code></pre><p>程序终止</p>
<p>程序只要符合以下情况之一，只要进入后台或挂起状态就会终止：</p>
<p>①iOS4.0以前的系统</p>
<p>②app是基于iOS4.0之前系统开发的。</p>
<p>③设备不支持多任务</p>
<p>④在Info.plist文件中，程序包含了 UIApplicationExitsOnSuspend 键。</p>
<p>系统常常是为其他app启动时由于内存不足而回收内存最后需要终止应用程序，但有时也会是由于app很长时间才响应而终止。如果app当时运行在后台并且没有暂停，系统会在应用程序终止之前调用app的代理的方法 <code>- (void)applicationWillTerminate:(UIApplication *)application</code>，这样可以让你可以做一些清理工作。你可以保存一些数据或app的状态。这个方法也有5秒钟的限制。超时后方法会返回程序从内存中清除。用户可以手工关闭应用程序。</p>
<h3 id="和其他动态语言的区别"><a href="#和其他动态语言的区别" class="headerlink" title="和其他动态语言的区别"></a>和其他动态语言的区别</h3><p>OC中方法的实现只能写在<code>@implementation··@end</code>中，对象方法的声明只能写在<code>@interface···@end</code>中间；对象方法都以-号开头，类方法都以+号开头；函数属于整个文件，可以写在文件中的任何位置，包括<code>@interface··@end</code>中，但写在<code>@interface···@end</code>会无法识别；</p>
<p>对象方法只能由对象来调用，类方法只能由类来调用，不能当做函数一样调用，对象方法归类\\对象所有；类方法调用不依赖于对象；类方法内部不能直接通过成员变量名访问对象的成员变量。OC只支持单继承，没有接口，但可以用delegate代替。</p>
<p>Objective-C与其他语言最大的区别是其运行时的动态性，它能让你在运行时为类添加方法或者去除方法以及使用反射。极大的方便了程序的扩展。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-103f66199e930d9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OC的面向对象&lt;/li&gt;
&lt;li&gt;运行时Runtime&lt;/li&gt;
&lt;li&gt;运行循环RunLoop&lt;/li&gt;
&lt;li&gt;事件响应链&lt;/li&gt;
&lt;li&gt;引用计数&lt;/li&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;li&gt;与其他语言的区别&lt;/li&gt;
&lt;/u
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>那些著名或非著名的iOS面试题－后编</title>
    <link href="https://dangdangfeng.github.io/2014/07/24/%E9%82%A3%E4%BA%9B%E8%91%97%E5%90%8D%E6%88%96%E9%9D%9E%E8%91%97%E5%90%8D%E7%9A%84iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8D%E5%90%8E%E7%BC%96/"/>
    <id>https://dangdangfeng.github.io/2014/07/24/那些著名或非著名的iOS面试题－后编/</id>
    <published>2014-07-24T14:58:40.000Z</published>
    <updated>2016-08-31T15:07:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Runtime"><a href="#1-Runtime" class="headerlink" title="1. Runtime"></a>1. Runtime</h4><p>Objective-C 是面相运行时的语言（runtime oriented language），就是说它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。这就给了你很大的灵活性，你可以按需要把消息重定向给合适的对象，你甚 至可以交换方法的实现，等等。</p>
<p>RunTime简称运行时。就是系统在运行的时候的一些机制，其中最主要的是消息机制。OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</p>
<p>以下面的代码为例：</p>
<pre><code>[obj makeText];
</code></pre><p>其中obj是一个对象，makeText是一个函数名称。对于这样一个简单的调用。在编译时RunTime会将上述代码转化成</p>
<pre><code>objc_msgSend(obj,@selector(makeText));
</code></pre><p>首先，编译器将代码[obj makeText];转化为objc_msgSend(obj, @selector (makeText));，在objc_msgSend函数中。首先通过obj的isa指针找到obj对应的class。在Class中先去cache中 通过SEL查找对应函数method（猜测cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若 cache中未找到。再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加 入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。</p>
<p><strong>Objective-C Runtime 是什么？</strong><br>Objective-C 的 Runtime 是一个运行时库（Runtime Library），它是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。这就是说它在类信息（Class information） 中被加载，完成所有的方法分发，方法转发，等等。Objective-C runtime 创建了所有需要的结构体，让 Objective-C 的面相对象编程变为可能。</p>
<p><strong>Method Swizzling 原理</strong></p>
<p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，<br>我们可以利用 class_replaceMethod 来修改类，<br>我们可以利用 method_setImplementation 来直接设置某个方法的IMP，……<br>归根结底，都是偷换了selector的IMP。</p>
<h4 id="2-GCD实现1，2并行和3串行和45串行，4，5是并行。即3依赖1，2的执行，45依赖3的执行。"><a href="#2-GCD实现1，2并行和3串行和45串行，4，5是并行。即3依赖1，2的执行，45依赖3的执行。" class="headerlink" title="2. GCD实现1，2并行和3串行和45串行，4，5是并行。即3依赖1，2的执行，45依赖3的执行。"></a>2. GCD实现1，2并行和3串行和45串行，4，5是并行。即3依赖1，2的执行，45依赖3的执行。</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-2fe2e7b2c01a9252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关系"><br><strong>队列组的方式</strong></p>
<pre><code>- (void) methodone{
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@&quot;%d&quot;,1);
});

dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    NSLog(@&quot;%d&quot;,2);
});

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@&quot;3&quot;);

    dispatch_group_t group1 = dispatch_group_create();

    dispatch_group_async(group1, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;%d&quot;,4);
    });

    dispatch_group_async(group1, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;%d&quot;,5);
    });

});

}
</code></pre><p>串行队列：队列中的任务只会顺序执行</p>
<pre><code>dispatch_queue_t q = dispatch_queue_create(“....”, dispatch_queue_serial);
</code></pre><p>并行队列： 队列中的任务通常会并发执行。
　　　　　　　</p>
<pre><code>dispatch_queue_t q = dispatch_queue_create(&quot;......&quot;, dispatch_queue_concurrent);
</code></pre><p>全局队列：是系统开发的，直接拿过来用就可以；与并行队列类似，但调试时，无法确认操作所在队列　。</p>
<pre><code>dispatch_queue_t q = dispatch_get_global_queue(dispatch_queue_priority_default, 0);
</code></pre><p>主队列：每一个应用开发程序对应唯一一个主队列，直接get即可；在多线程开发中，使用主队列更新UI。</p>
<pre><code>dispatch_queue_t q = dispatch_get_main_queue();
</code></pre><p>主队列是GCD自带的串行队列，会在主线程中执行。异步全局并发队列  开启新线程，并发执行。</p>
<p>并行队列里开启同步任务是有执行顺序的，只有异步才没有顺序。</p>
<p>串行队列开启异步任务，是有顺序的。</p>
<p>串行队列开启异步任务后嵌套同步任务造成死锁。</p>
<h4 id="3-深浅复制和属性为copy，strong值的变化问题"><a href="#3-深浅复制和属性为copy，strong值的变化问题" class="headerlink" title="3. 深浅复制和属性为copy，strong值的变化问题"></a>3. 深浅复制和属性为copy，strong值的变化问题</h4><p>浅复制：只复制指向对象的指针，而不复制引用对象本身。对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不个是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作，那么发现A引用的对象同样被修改了。深复制就好理解了，内存中存在了两份独立对象本身。</p>
<p>在Objective-C中并不是所有的对象都支持Copy，MutableCopy，遵守NSCopying协议的类才可以发送Copy消息，遵守NSMutableCopying协议的类才可以发送MutableCopy消息。</p>
<p>[immutableObject copy] // 浅拷贝<br>[immutableObject mutableCopy] //深拷贝<br>[mutableObject copy] //深拷贝<br>[mutableObject mutableCopy] //深拷贝</p>
<p>属性设为copy,指定此属性的值不可更改，防止可变字符串更改自身的值的时候不会影响到对象属性（如NSString,NSArray,NSDictionary）的值。strong此属性的指会随着变化而变化。copy是内容拷贝，strong是指针拷贝。</p>
<h4 id="4-NSTimer创建后，会在哪个线程运行。"><a href="#4-NSTimer创建后，会在哪个线程运行。" class="headerlink" title="4.NSTimer创建后，会在哪个线程运行。"></a>4.NSTimer创建后，会在哪个线程运行。</h4><p>用scheduledTimerWithTimeInterval创建的，在哪个线程创建就会被加入哪个线程的RunLoop中就运行在哪个线程。</p>
<p>自己创建的Timer，加入到哪个线程的RunLoop中就运行在哪个线程。</p>
<h4 id="5-KVO，NSNotification，delegate及block区别"><a href="#5-KVO，NSNotification，delegate及block区别" class="headerlink" title="5. KVO，NSNotification，delegate及block区别"></a>5. KVO，NSNotification，delegate及block区别</h4><p>KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。</p>
<p>NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。</p>
<p>delegate 是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。</p>
<p>block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。</p>
<p>KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。</p>
<h4 id="6-如何让计时器调用一个类方法"><a href="#6-如何让计时器调用一个类方法" class="headerlink" title="6. 如何让计时器调用一个类方法"></a>6. 如何让计时器调用一个类方法</h4><p>计时器只能调用实例方法，但是可以在这个实例方法里面调用静态方法。</p>
<p>使用计时器需要注意，计时器一定要加入RunLoop中，并且选好model才能运行。scheduledTimerWithTimeInterval方法创建一个计时器并加入到RunLoop中所以可以直接使用。</p>
<p>如果计时器的repeats选择YES说明这个计时器会重复执行，一定要在合适的时机调用计时器的invalid。不能在dealloc中调用，因为一旦设置为repeats 为yes，计时器会强持有self，导致dealloc永远不会被调用，这个类就永远无法被释放。比如可以在viewDidDisappear中调用，这样当类需要被回收的时候就可以正常进入dealloc中了。</p>
<h4 id="7-调用一个类的静态方法需不需要release？"><a href="#7-调用一个类的静态方法需不需要release？" class="headerlink" title="7. 调用一个类的静态方法需不需要release？"></a>7. 调用一个类的静态方法需不需要release？</h4><p>静态方法，就是类方法，不需要，类方法对象放在autorelease中</p>
<h4 id="8-static作用？"><a href="#8-static作用？" class="headerlink" title="8. static作用？"></a>8. static作用？</h4><p>（1）函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br>（2）在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；<br>（3）在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明<br>它的模块内；<br>（4）在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>（5）在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。</p>
<h4 id="9-NSObject的load和initialize方法"><a href="#9-NSObject的load和initialize方法" class="headerlink" title="9. NSObject的load和initialize方法"></a>9. NSObject的load和initialize方法</h4><p><strong>load和initialize的共同特点</strong><br>在不考虑开发者主动使用的情况下，系统最多会调用一次<br>如果父类和子类都被调用，父类的调用一定在子类之前<br>都是为了应用运行提前创建合适的运行环境<br>在使用时都不要过重地依赖于这两个方法，除非真正必要</p>
<p><strong>load和initialize的区别</strong><br><strong>load方法</strong></p>
<p>调用时机比较早，运行环境有不确定因素。具体说来，在iOS上通常就是App启动时进行加载，但当load调用的时候，并不能保证所有类都加载完成且可用，必要时还要自己负责做auto release处理。对于有依赖关系的两个库中，被依赖的类的load会优先调用。但在一个库之内，调用顺序是不确定的。</p>
<p>对于一个类而言，没有load方法实现就不会调用，不会考虑对NSObject的继承。</p>
<p>一个类的load方法不用写明[super load]，父类就会收到调用，并且在子类之前。</p>
<p>Category的load也会收到调用，但顺序上在主类的load调用之后。</p>
<p>不会直接触发initialize的调用。</p>
<p><strong>initialize方法相关要点</strong></p>
<p>initialize的自然调用是在第一次主动使用当前类的时候。</p>
<p>在initialize方法收到调用时，运行环境基本健全。</p>
<p>initialize的运行过程中是能保证线程安全的。</p>
<p>和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。</p>
<p>由于initialize的这些特点，使得其应用比load要略微广泛一些。可用来做一些初始化工作，或者单例模式的一种实现方案。</p>
<h4 id="10-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#10-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="10. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>10. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h4><p>不能向编译后得到的类中增加实例变量；<br>能向运行时创建的类中添加实例变量；</p>
<p>因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；</p>
<p>运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-a87cffd6913fdd25.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对，就是这样"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Runtime&quot;&gt;&lt;a href=&quot;#1-Runtime&quot; class=&quot;headerlink&quot; title=&quot;1. Runtime&quot;&gt;&lt;/a&gt;1. Runtime&lt;/h4&gt;&lt;p&gt;Objective-C 是面相运行时的语言（runtime oriented l
    
    </summary>
    
    
      <category term="Interview" scheme="https://dangdangfeng.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>那些著名或非著名的iOS面试题－中编</title>
    <link href="https://dangdangfeng.github.io/2014/07/10/%E9%82%A3%E4%BA%9B%E8%91%97%E5%90%8D%E6%88%96%E9%9D%9E%E8%91%97%E5%90%8D%E7%9A%84iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8D%E4%B8%AD%E7%BC%96/"/>
    <id>https://dangdangfeng.github.io/2014/07/10/那些著名或非著名的iOS面试题－中编/</id>
    <published>2014-07-10T14:56:55.000Z</published>
    <updated>2016-08-31T15:08:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-反转二叉树，不用递归"><a href="#1-反转二叉树，不用递归" class="headerlink" title="1. 反转二叉树，不用递归"></a>1. 反转二叉树，不用递归</h4><pre><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
</code></pre><p>递归方式：</p>
<pre><code>public class Solution {
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    root.left = invertTree(root.left);
    root.right = invertTree(root.right);
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;
    return root;
}
}
</code></pre><p>object-c实现：</p>
<pre><code>/** 
 * 翻转二叉树（又叫：二叉树的镜像） 
 *
 * @param rootNode 根节点
 *
 * @return 翻转后的树根节点（其实就是原二叉树的根节点） 
 */
 + (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode {
    if (!rootNode) {  return nil; } 
    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) {  return rootNode; } 
    [self invertBinaryTree:rootNode.leftNode];
    [self invertBinaryTree:rootNode.rightNode]; 
    BinaryTreeNode *tempNode = rootNode.leftNode; 
    rootNode.leftNode = rootNode.rightNode;
    rootNode.rightNode = tempNode; 
    return rootNode;
  }
</code></pre><p>非递归方式：</p>
<pre><code>+ (BinaryTreeNode *)invertBinaryTree:(BinaryTreeNode *)rootNode {
if (!rootNode) {  return nil; }
if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) {  return rootNode; }
NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
[queueArray addObject:rootNode]; //压入根节点
while (queueArray.count &gt; 0) {
    BinaryTreeNode *node = [queueArray firstObject];
    [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
    BinaryTreeNode *pLeft = node.leftNode;
    node.leftNode = node.rightNode;
    node.rightNode = pLeft;

    if (node.leftNode) {
        [queueArray addObject:node.leftNode];
    }
    if (node.rightNode) {
        [queueArray addObject:node.rightNode];
    }

}

return rootNode;
}
</code></pre><p>示例代码参考：<a href="https://github.com/dangdangfeng/-/blob/master/ttt/ttt/ViewController.m" target="_blank" rel="external">二叉树</a></p>
<h4 id="2-写一个单例模式"><a href="#2-写一个单例模式" class="headerlink" title="2. 写一个单例模式"></a>2. 写一个单例模式</h4><pre><code>+ (AccountManager *)sharedManager
{
    static AccountManager *sharedAccountManagerInstance = nil;
    static dispatch_once_t predicate;
    dispatch_once(&amp;predicate, ^{
            sharedAccountManagerInstance = [[self alloc] init]; 
    });
return sharedAccountManagerInstance;
}
</code></pre><h4 id="3-iOS应用生命周期"><a href="#3-iOS应用生命周期" class="headerlink" title="3. iOS应用生命周期"></a>3. iOS应用生命周期</h4><p><strong>应用程序的状态</strong><br><strong>Not running未运行</strong>：程序没启动。<br><strong>Inactive未激活</strong>：程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。<br><strong>Active激活</strong>：程序在前台运行而且接收到了事件。这也是前台的一个正常的模式。<br><strong>Backgroud后台</strong>：程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态。<br><strong>Suspended挂起</strong>：程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
<p>iOS的入口在main.m文件：</p>
<pre><code>int main(int argc, char *argv[])
{
@autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
}
}
</code></pre><p>main函数的两个参数，iOS中没有用到，包括这两个参数是为了与标准ANSI C保持一致。 UIApplicationMain函数，前两个和main函数一样，重点是后两个。</p>
<p>后两个参数分别表示程序的主要类(principal class)和代理类(delegate class)。如果主要类(principal class)为nil，将从Info.plist中获取，如果Info.plist中不存在对应的key，则默认为UIApplication；如果代理类(delegate class)将在新建工程时创建。<br>       根据UIApplicationMain函数，程序将进入AppDelegate.m，这个文件是xcode新建工程时自动生成的。下面看一下AppDelegate.m文件，这个关乎着应用程序的生命周期。</p>
<p>1、<strong>application didFinishLaunchingWithOptions：</strong>当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，<strong>lauchOptions</strong>包含对应方式的内容。<br>2、<strong>applicationWillResignActive：</strong>在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。<br><strong>     3、applicationDidEnterBackground：</strong>在应用程序已进入后台程序时，要执行的委托调用。<br><strong>     4、applicationWillEnterForeground：</strong>在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。<br><strong>     5、applicationDidBecomeActive：</strong>在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。<br>     <strong>6、applicationWillTerminate：</strong>在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。 </p>
<p><strong>初次启动：</strong><br>iOS_didFinishLaunchingWithOptions<br>iOS_applicationDidBecomeActive<br><strong>按下home键：</strong><br>iOS_applicationWillResignActive<br>iOS_applicationDidEnterBackground<br><strong>点击程序图标进入：</strong><br>iOS_applicationWillEnterForeground<br>iOS_applicationDidBecomeActive</p>
<p>当应用程序进入后台时,应该保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死。释放尽可能释放的内存。</p>
<pre><code>- (void)applicationDidEnterBackground:(UIApplication *)application
</code></pre><p>方法有大概5秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。</p>
<p>如果还需要长时间的运行任务，可以在该方法中调用 </p>
<pre><code>[application beginBackgroundTaskWithExpirationHandler:^{ 

    NSLog(@&quot;begin Background Task With Expiration Handler&quot;); 

}];
</code></pre><p><strong>程序终止</strong></p>
<p>程序只要符合以下情况之一，只要进入后台或挂起状态就会终止：</p>
<p>①iOS4.0以前的系统</p>
<p>②app是基于iOS4.0之前系统开发的。</p>
<p>③设备不支持多任务</p>
<p>④在Info.plist文件中，程序包含了 UIApplicationExitsOnSuspend  键。</p>
<p>系统常常是为其他app启动时由于内存不足而回收内存最后需要终止应用程序，但有时也会是由于app很长时间才响应而终止。如果app当时运行在后台并且没有暂停，系统会在应用程序终止之前调用app的代理的方法 - (void)applicationWillTerminate:(UIApplication *)application，这样可以让你可以做一些清理工作。你可以保存一些数据或app的状态。这个方法也有5秒钟的限制。超时后方法会返回程序从内存中清除。</p>
<p>注意：用户可以手工关闭应用程序。</p>
<h4 id="4-一工人给老板打7天工要求一块金条-这金条只能切2次-工人每天要1-7金条-怎么分"><a href="#4-一工人给老板打7天工要求一块金条-这金条只能切2次-工人每天要1-7金条-怎么分" class="headerlink" title="4. 一工人给老板打7天工要求一块金条 这金条只能切2次 工人每天要1/7金条 怎么分?"></a>4. 一工人给老板打7天工要求一块金条 这金条只能切2次 工人每天要1/7金条 怎么分?</h4><p>这道题解决的主要难点在于：不是给出去的就收不回来了，可以用交换的方法。　　</p>
<p>把金条分成三段（就是分两次，或者切两刀），分别是整根金条的1/7、2/7、 4/7。　　</p>
<p>第一天：给1/7的， 第二天：给2/7的，收回1/7的； 第三天，给1/7的； 第四天：给4/7的，收回1/7和2/7的 ；第五天：给1/7的 ；第六天：给2/7的，收回1/7的；第七天发1/7。</p>
<h4 id="5-iOS中socket使用"><a href="#5-iOS中socket使用" class="headerlink" title="5. iOS中socket使用"></a>5. iOS中socket使用</h4><p>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p>
<p> http协议   对应于应用层<br> tcp协议    对应于传输层<br> ip协议     对应于网络层<br> 三者本质上没有可比性。  何况HTTP协议是基于TCP连接的。 </p>
<p> TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。</p>
<p> 我 们在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层 协议，应用层协议很多，有HTTP、FTP、TELNET等等，也可以自己定义应用层协议。WEB使用HTTP作传输层协议，以封装HTTP文本信息，然 后使用TCP/IP做传输层协议将它发送到网络上。</p>
<p><strong>SOCKET原理</strong><br>1、套接字（socket）概念<br>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>应 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应 用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>2 、建立socket连接<br>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>连 接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<p>3、SOCKET连接与TCP连接<br>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<p>4、Socket连接与HTTP连接<br>由 于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
<p>很 多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<p>下面这篇<a href="http://my.oschina.net/joanfen/blog/287238" target="_blank" rel="external">文章</a>是AsyncSocket的使用教程，大家可以看看。</p>
<h4 id="6-网络请求中post和get的区别"><a href="#6-网络请求中post和get的区别" class="headerlink" title="6. 网络请求中post和get的区别"></a>6. 网络请求中post和get的区别</h4><p>GET是用于获取数据的，POST一般用于将数据发给服务器之用。</p>
<p><strong>普遍答案</strong><br>1.GET使用URL或Cookie传参。而POST将数据放在BODY中。<br>2.GET的URL会有长度上的限制，则POST的数据则可以非常大。<br>3.POST比GET安全，因为数据在地址栏上不可见。</p>
<p>不过也有文章说其实上面的是错误的，具体参考这篇<a href="http://www.nowamagic.net/librarys/veda/detail/1919" target="_blank" rel="external">文章</a></p>
<h4 id="7-时间复杂度和空间复杂度"><a href="#7-时间复杂度和空间复杂度" class="headerlink" title="7. 时间复杂度和空间复杂度"></a>7. 时间复杂度和空间复杂度</h4><p>由于打不出数字符号，只能贴图了。<br><img src="http://upload-images.jianshu.io/upload_images/1170656-21358344d6f9d53e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间复杂度"></p>
<p><strong>求时间复杂度</strong><br>【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p>
<pre><code>x=91; y=100;while(y&gt;0) if(x&gt;100) {x=x-10;y--;} else x++;解答： T(n)=O(1)
</code></pre><p>这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数。</p>
<p>【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p>
<pre><code> x=1; 
for(i=1;i&lt;=n;i++) 
    for(j=1;j&lt;=i;j++)
       for(k=1;k&lt;=j;k++)
           x++; 　　
</code></pre><p>该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：  则该程序段的时间复杂度为</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-b640f2553e52fe12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p>【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。<br>在数值A[0..n-1]中查找给定值K的算法大致如下：   </p>
<pre><code>i=n-1;            
while(i&gt;=0&amp;&amp;(A[i]!=k))       
  i--;        
return i;        
</code></pre><p>此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。</p>
<p><strong>空间复杂度</strong><br>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　<br>　<br>（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。<br>（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。</p>
<p>一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。</p>
<h4 id="8-支付宝SDK使用"><a href="#8-支付宝SDK使用" class="headerlink" title="8. 支付宝SDK使用"></a>8. 支付宝SDK使用</h4><p>使用支付宝进行一个完整的支付功能，大致有以下步骤：向支付宝申请, 与支付宝签约，获得商户ID（partner）和账号ID（seller）和私钥(privateKey)。下载支付宝SDK，生成订单信息,签名加密调用支付宝客户端，由支付宝客户端跟支付宝安全服务器打交道。支付完毕后,支付宝客户端会自动跳回到原来的应用程序，在原来的应用程序中显示支付结果给用户看。</p>
<p><strong>集成之后可能遇到的问题</strong><br>1）集成SDK编译时找不到 openssl/asn1.h 文件<br><img src="http://upload-images.jianshu.io/upload_images/1170656-9cd15fc846eef8ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术分享">解决方案：Build Settings –&gt; Search Paths –&gt; Header Search paths : $(SRCROOT)/支付宝集成/Classes/Alipay<br><img src="http://upload-images.jianshu.io/upload_images/1170656-0c846782413bc42c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术分享"></p>
<p>2）链接时：找不到 SystemConfiguration.framework 这个库 <img src="http://upload-images.jianshu.io/upload_images/1170656-017d3f15dea91b82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术分享"><br>解决方案：<img src="http://upload-images.jianshu.io/upload_images/1170656-9c1c8eb51640d3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="技术分享"></p>
<p>打开支付宝客户端进行支付(用户没有安装支付宝客户端,直接在应用程序中添加一个WebView,通过网页让用户进行支付)<br>// 注意:如果是通过网页支付完成,那么会回调该block:callback</p>
<pre><code>[[AlipaySDK defaultService] payOrder:orderString fromScheme:@&quot;jingdong&quot; callback:^(NSDictionary *resultDic) { }];
</code></pre><p>在AppDelegate.m</p>
<pre><code>// 当通过别的应用程序,将该应用程序打开时,会调用该方法
- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options{ // 当用户通过支付宝客户端进行支付时,会回调该block:standbyCallback 
[[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) { NSLog(@&quot;result = %@&quot;,resultDic); }]; return YES;}
</code></pre><h4 id="9-远程推送"><a href="#9-远程推送" class="headerlink" title="9. 远程推送"></a>9. 远程推送</h4><p>当服务端远程向APNS推送至一台离线的设备时，苹果服务器Qos组件会自动保留一份最新的通知，等设备上线后，Qos将把推送发送到目标设备上</p>
<p>远程推送的基本过程<br>1.客户端的app需要将用户的UDID和app的bundleID发送给apns服务器,进行注册,apns将加密后的device Token返回给app<br>2.app获得device Token后,上传到公司服务器<br>3.当需要推送通知时,公司服务器会将推送内容和device Token一起发给apns服务器<br>4.apns再将推送内容送到客户端上</p>
<p>创建证书的流程：<br>1.打开钥匙串，生成CertificateSigningRequest.certSigningRequest文件<br>2.将CertificateSigningRequest.certSigningRequest上传进developer，导出.cer文件<br>3.利用CSR导出P12文件<br>4.需要准备下设备token值（无空格）<br>5.使用OpenSSL合成服务器所使用的推送证书</p>
<p>本地app代码参考<br>1.注册远程通知</p>
<pre><code> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions//中注册远程通知
{
[[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound)];
}
</code></pre><p>2,实现几个代理方法：</p>
<pre><code>//获取deviceToken令牌  
-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken  
{  
//获取设备的deviceToken唯一编号  
NSLog(@&quot;deviceToken=%@&quot;,deviceToken);  
NSString *realDeviceToken=[NSString stringWithFormat:@&quot;%@&quot;,deviceToken];  
//去除&lt;&gt;  
realDeviceToken = [realDeviceToken stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;];  
realDeviceToken = [realDeviceToken stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;];  
NSLog(@&quot;realDeviceToken=%@&quot;,realDeviceToken);  
[[NSUserDefaults standardUserDefaults] setValue:realDeviceToken forKey:@&quot;DeviceToken&quot;];  //要发送给服务器
}  

 //获取令牌出错  
-(void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error  
{  
//注册远程通知设备出错  
NSLog(@&quot;RegisterForRemoteNotification error=%@&quot;,error);  
}  
//在应用在前台时受到消息调用  
-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo  
{  
 //打印推送的消息  
NSLog(@&quot;%@&quot;,[[userInfo objectForKey:@&quot;aps&quot;] objectForKey:@&quot;alert&quot;]):  
}  
</code></pre><p>配置后台模式<img src="http://upload-images.jianshu.io/upload_images/1170656-d955d43170b41c11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>一般我们是使用开发版本的Provisioning做推送测试,如果没有问题,再使用发布版本证书的时候一般也应该是没有问题的。为了以防万一,我们可以在越狱的手机上安装我们的使用发布版证书的ipa文件(最好使用debug版本,并打印出获取到的deviceToken),安装成功后在;XCode-&gt;Window-&gt;Organizer-找到对应的设备查看console找到打印的deviceToken。</p>
<p>在后台的推送程序中使用发布版制作的证书并使用该deviceToken做推送服务.<br>使用开发和发布证书获取到的deviceToken是不一样的。</p>
<h4 id="10-protocol-和-category-中如何使用-property"><a href="#10-protocol-和-category-中如何使用-property" class="headerlink" title="10.  @protocol 和 category 中如何使用 @property"></a>10.  @protocol 和 category 中如何使用 @property</h4><p>1）在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</p>
<p>2）category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：</p>
<p>①objc_setAssociatedObject</p>
<p>②objc_getAssociatedObject</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-反转二叉树，不用递归&quot;&gt;&lt;a href=&quot;#1-反转二叉树，不用递归&quot; class=&quot;headerlink&quot; title=&quot;1. 反转二叉树，不用递归&quot;&gt;&lt;/a&gt;1. 反转二叉树，不用递归&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/**
 * Definition fo
    
    </summary>
    
    
      <category term="Interview" scheme="https://dangdangfeng.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>那些著名或非著名的iOS面试题－前编</title>
    <link href="https://dangdangfeng.github.io/2014/07/01/%E9%82%A3%E4%BA%9B%E8%91%97%E5%90%8D%E6%88%96%E9%9D%9E%E8%91%97%E5%90%8D%E7%9A%84iOS%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8D%E5%89%8D%E7%BC%96/"/>
    <id>https://dangdangfeng.github.io/2014/07/01/那些著名或非著名的iOS面试题－前编/</id>
    <published>2014-07-01T14:55:06.000Z</published>
    <updated>2016-08-31T15:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-如何追踪app崩溃率，如何解决线上闪退"><a href="#1-如何追踪app崩溃率，如何解决线上闪退" class="headerlink" title="1.如何追踪app崩溃率，如何解决线上闪退"></a>1.如何追踪app崩溃率，如何解决线上闪退</h4><p>当iOS设备上的App应用闪退时，操作系统会生成一个crash日志，保存在设备上。crash日志上有很多有用的信息，比如每个正在执行线程的完整堆栈跟踪信息和内存映像，这样就能够通过解析这些信息进而定位crash发生时的代码逻辑，从而找到App闪退的原因。通常来说，crash产生来源于两种问题：违反iOS系统规则导致的crash和App代码逻辑BUG导致的crash，下面分别对他们进行分析。</p>
<p><strong>违反iOS系统规则产生crash的三种类型</strong></p>
<p>(1) 内存报警闪退<br>当iOS检测到内存过低时，它的VM系统会发出低内存警告通知，尝试回收一些内存；如果情况没有得到足够的改善，iOS会终止后台应用以回收更多内存；最后，如果内存还是不足，那么正在运行的应用可能会被终止掉。在Debug模式下，可以主动将客户端执行的动作逻辑写入一个log文件中，这样程序童鞋可以将内存预警的逻辑写入该log文件，当发生如下截图中的内存报警时，就是提醒当前客户端性能内存吃紧，可以通过Instruments工具中的Allocations 和 Leaks模块库来发现内存分配问题和内存泄漏问题。</p>
<p>(2) 响应超时<br>当应用程序对一些特定的事件（比如启动、挂起、恢复、结束）响应不及时，苹果的Watchdog机制会把应用程序干掉，并生成一份相应的crash日志。这些事件与下列UIApplicationDelegate方法相对应，当遇到Watchdog日志时，可以检查上图中的几个方法是否有比较重的阻塞UI的动作。　</p>
<pre><code>application:didFinishLaunchingWithOptions:　
applicationWillResignActive:
applicationDidEnterBackground:　
applicationWillEnterForeground:
applicationDidBecomeActive:
applicationWillTerminate:　　
</code></pre><p>(3) 用户强制退出<br>一看到“用户强制退出”，首先可能想到的双击Home键，然后关闭应用程序。不过这种场景一般是不会产生crash日志的，因为双击Home键后，所有的应用程序都处于后台状态，而iOS随时都有可能关闭后台进程，当应用阻塞界面并停止响应时这种场景才会产生crash日志。这里指的“用户强制退出”场景，是稍微比较复杂点的操作：先按住电源键，直到出现“滑动关机”的界面时，再按住Home键，这时候当前应用程序会被终止掉，并且产生一份相应事件的crash日志。</p>
<p><strong>应用逻辑的Bug</strong><br>大多数闪退崩溃日志的产生都是因为应用中的Bug，这种Bug的错误种类有很多，比如　　</p>
<pre><code>SEGV：（Segmentation Violation，段违例），无效内存地址，比如空指针，未初始化指针，栈溢出等；
SIGABRT：收到Abort信号，可能自身调用abort()或者收到外部发送过来的信号；
SIGBUS：总线错误。与SIGSEGV不同的是，SIGSEGV访问的是无效地址（比如虚存映射不到物理内存），而SIGBUS访问的是有效地址，但总线访问异常（比如地址对齐问题）；
SIGILL：尝试执行非法的指令，可能不被识别或者没有权限；
SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作；
SIGPIPE：管道另一端没有进程接手数据；
</code></pre><p>　　常见的崩溃原因基本都是代码逻辑问题或资源问题，比如数组越界，访问野指针或者资源不存在，或资源大小写错误等。</p>
<p><strong>crash的收集</strong></p>
<p>如果是在windows上你可以通过itools或pp助手等辅助工具查看系统产生的历史crash日志，然后再根据app来查看。如果是在Mac 系统上，只需要打开xcode-&gt;windows-&gt;devices，选择device logs进行查看，如下图，这些crash文件都可以导出来，然后再单独对这个crash文件做处理分析。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-834619bd37e5cba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="看日志"></p>
<p>市场上已有的商业软件提供crash收集服务，这些软件基本都提供了日志存储，日志符号化解析和服务端可视化管理等服务：</p>
<p>Crashlytics (<a href="http://www.crashlytics.com/" target="_blank" rel="external">www.crashlytics.com</a>)<br>Crittercism (<a href="http://www.crittercism.com/" target="_blank" rel="external">www.crittercism.com</a>)<br>Bugsense (<a href="http://www.bugsense.com/" target="_blank" rel="external">www.bugsense.com</a>)　　<br>HockeyApp (<a href="http://www.hockeyapp.net/" target="_blank" rel="external">www.hockeyapp.net</a>)　　<br>Flurry(<a href="http://www.flurry.com/" target="_blank" rel="external">www.flurry.com</a>)</p>
<p>开源的软件也可以拿来收集crash日志，比如Razor,QuincyKit（git链接）等，这些软件收集crash的原理其实大同小异，都是根据系统产生的crash日志进行了一次提取或封装，然后将封装后的crash文件上传到对应的服务端进行解析处理。很多商业软件都采用了Plcrashreporter这个开源工具来上传和解析crash，比如HockeyApp,Flurry和crittercism等。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-a8b82f0317591a3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="crash信息"></p>
<p>由于自己的crash信息太长，找了一张示例：　　<br>1)crash标识是应用进程产生crash时的一些标识信息，它描述了该crash的唯一标识（E838FEFB-ECF6-498C-8B35-D40F0F9FEAE4），所发生的硬件设备类型（iphone3,1代表iphone4），以及App进程相关的信息等；<br>2）基本信息描述的是crash发生的时间和系统版本；　　<br>3）异常类型描述的是crash发生时抛出的异常类型和错误码；　　<br>4）线程回溯描述了crash发生时所有线程的回溯信息，每个线程在每一帧对应的函数调用信息（这里由于空间限制没有全部列出）；　　<br>5）二进制映像是指crash发生时已加载的二进制文件。以上就是一份crash日志包含的所有信息，接下来就需要根据这些信息去解析定位导致crash发生的代码逻辑， 这就需要用到符号化解析的过程（洋名叫：symbolication)。</p>
<p><strong>解决线上闪退</strong><br>首先保证，发布前充分测试。发布后依然有闪退现象，查看崩溃日志，及时修复并发布。</p>
<h4 id="2-什么是事件响应链，点击屏幕时是如何互动的，事件的传递。"><a href="#2-什么是事件响应链，点击屏幕时是如何互动的，事件的传递。" class="headerlink" title="2.什么是事件响应链，点击屏幕时是如何互动的，事件的传递。"></a>2.什么是事件响应链，点击屏幕时是如何互动的，事件的传递。</h4><p><img src="http://upload-images.jianshu.io/upload_images/1170656-e5b08d215be73490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件响应链"></p>
<p>对于IOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：</p>
<p>1、触屏事件（Touch Event）</p>
<p>2、运动事件（Motion Event）</p>
<p>3、远端控制事件（Remote-Control Event）</p>
<p><strong>响应者链（Responder Chain）</strong><br>响应者对象（Responder Object），指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。</p>
<p>UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。</p>
<p>响应者链有以下特点：<br>1、响应者链通常是由视图（UIView）构成的；<br>2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）；<br>3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图；<br>4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者<br>需要指出的是，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点；<br>5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。</p>
<p><strong>点击屏幕时是如何互动的</strong><br>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p>
<p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。</p>
<p>hitTest:withEvent:方法的处理流程如下:首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；若返回NO,则hitTest:withEvent:返回nil;若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p>
<p>事件的传递和响应分两个链：</p>
<p>传递链：由系统向离用户最近的view传递。UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view<br>响应链：由离用户最近的view向系统传递。initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application</p>
<h4 id="3-Run-Loop是什么，使用的目的，何时使用和关注点"><a href="#3-Run-Loop是什么，使用的目的，何时使用和关注点" class="headerlink" title="3.Run Loop是什么，使用的目的，何时使用和关注点"></a>3.Run Loop是什么，使用的目的，何时使用和关注点</h4><p>Run Loop是一让线程能随时处理事件但不退出的机制。RunLoop 实际上是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<p><strong>系统默认注册了5个Mode:</strong></p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p><strong>Run Loop的四个作用:</strong></p>
<p>使程序一直运行接受用户输入<br>决定程序在何时应该处理哪些Event<br>调用解耦<br>节省CPU时间</p>
<p>主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main() 函数：</p>
<pre><code>int main(int argc, char *argv[])
{
       @autoreleasepool {
         return UIApplicationMain(argc, argv, nil, NSStringFromClass([appDelegate class]));
      }
 }
</code></pre><p>重点是UIApplicationMain() 函数，这个方法会为main thread 设置一个NSRunLoop 对象，这就解释了本文开始说的为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p>对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。在任何一个Cocoa程序的线程中，都可以通过：</p>
<pre><code>NSRunLoop   *runloop = [NSRunLoop currentRunLoop];
</code></pre><p>来获取到当前线程的run loop。</p>
<p>一个run loop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。</p>
<p>NSRunLoop是一种更加高明的消息处理模式，他就高明在对消息处理过程进行了更好的抽象和封装，这样才能是的你不用处理一些很琐碎很低层次的具体消息的处理，在NSRunLoop中每一个消息就被打包在input source或者是timer source中了。使用run loop可以使你的线程在有工作的时候工作，没有工作的时候休眠，这可以大大节省系统资源。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-81b8810296457210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop"></p>
<p><strong>什么时候使用run loop</strong><br>仅当在为你的程序创建辅助线程的时候，你才需要显式运行一个run loop。Run loop是程序主线程基础设施的关键部分。所以，Cocoa和Carbon程序提供了代码运行主程序的循环并自动启动run loop。IOS程序中UIApplication的run方法（或Mac OS X中的NSApplication）作为程序启动步骤的一部分，它在程序正常启动的时候就会启动程序的主循环。类似的，RunApplicationEventLoop函数为Carbon程序启动主循环。如果你使用xcode提供的模板创建你的程序，那你永远不需要自己去显式的调用这些例程。</p>
<p>对于辅助线程，你需要判断一个run loop是否是必须的。如果是必须的，那么你要自己配置并启动它。你不需要在任何情况下都去启动一个线程的run loop。比如，你使用线程来处理一个预先定义的长时间运行的任务时，你应该避免启动run loop。Run loop在你要和线程有更多的交互时才需要，比如以下情况：<br>使用端口或自定义输入源来和其他线程通信<br>使用线程的定时器<br>Cocoa中使用任何performSelector…的方法<br>使线程周期性工作</p>
<p><strong>关注点</strong></p>
<ol>
<li><p>Cocoa中的NSRunLoop类并不是线程安全的<br>我们不能再一个线程中去操作另外一个线程的run loop对象，那很可能会造成意想不到的后果。不过幸运的是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的run loop完全可以混合使用。Cocoa中的NSRunLoop类可以通过实例方法：</p>
<pre><code>- (CFRunLoopRef)getCFRunLoop;
</code></pre><p>获取对应的CFRunLoopRef类，来达到线程安全的目的。</p>
</li>
<li><p>Run loop的管理并不完全是自动的。<br>我们仍必须设计线程代码以在适当的时候启动run loop并正确响应输入事件，当然前提是线程中需要用到run loop。而且，我们还需要使用while/for语句来驱动run loop能够循环运行，下面的代码就成功驱动了一个run loop：</p>
<pre><code>BOOL isRunning = NO;
do {
     isRunning = [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDatedistantFuture]];
} while (isRunning);
</code></pre></li>
<li><p>Run loop同时也负责autorelease pool的创建和释放<br>在使用手动的内存管理方式的项目中，会经常用到很多自动释放的对象，如果这些对象不能够被即时释放掉，会造成内存占用量急剧增大。Run loop就为我们做了这样的工作，每当一个运行循环结束的时候，它都会释放一次autorelease pool，同时pool中的所有自动释放类型变量都会被释放掉。</p>
</li>
</ol>
<h4 id="4-ARC和MRC"><a href="#4-ARC和MRC" class="headerlink" title="4. ARC和MRC"></a>4. ARC和MRC</h4><p>Objective-c中提供了两种内存管理机制MRC（MannulReference Counting）和ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。Xcode 4.1及其以前版本没有ARC。</p>
<p>在MRC的内存管理模式下，与对变量的管理相关的方法有：retain,release和autorelease。retain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease调用）的变量进行管理，当drain时回收内存。<br>（1）      retain，该方法的作用是将内存数据的所有权附给另一指针变量，引用数加1，即retainCount+= 1;<br>（2）      release，该方法是释放指针变量对内存数据的所有权，引用数减1，即retainCount-= 1;<br>（3）      autorelease，该方法是将该对象内存的管理放到autoreleasepool中。</p>
<p>在ARC中与内存管理有关的标识符，可以分为变量标识符和属性标识符，对于变量默认为__strong，而对于属性默认为unsafe_unretained。也存在autoreleasepool。</p>
<p>其中assign/retain/copy与MRC下property的标识符意义相同，strong类似与retain,assign类似于unsafe_unretained，strong/weak/unsafe_unretained与ARC下变量标识符意义相同，只是一个用于属性的标识，一个用于变量的标识(带两个下划短线__)。所列出的其他的标识符与MRC下意义相同。</p>
<h4 id="5-线程和进程"><a href="#5-线程和进程" class="headerlink" title="5. 线程和进程"></a>5. 线程和进程</h4><p>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p>
<p><strong>进程的执行过程是线状的</strong>，尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。这是进程宏观上的执行过程。而进程又可有单线程进程与多线程进程两种。我们知道，进程有 一个进程控制块 PCB ，相关程序段 和 该程序段对其进行操作的数据结构集 这三部分，单线程进程的执行过程在宏观上是线性的，微观上也只有单一的执行过程；而多线程进程在宏观上的执行过程同样为线性的，但微观上却可以有多个执行操作（线程），如不同代码片段以及相关的数据结构集。<strong>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</strong>除了 CPU 之外，<strong>计算机内的软硬件资源的分配与线程无关</strong>，线程只能共享它所属进程的资源。与进程控制表和 PCB 相似，每个线程也有自己的线程控制表 TCB ，而这个 TCB 中所保存的线程状态信息则要比 PCB 表少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈），寄存器中的状态数据。<strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源</strong>。</p>
<p>线程可以有效地提高系统的执行效率，但并不是在所有计算机系统中都是适用的，如某些很少做进程调度和切换的实时系统。使用线程的好处是有多个任务需要处理机处理时，减少处理机的切换时间；而且，线程的创建和结束所需要的系统开销也比进程的创建和结束要小得多。最适用使用线程的系统是多处理机系统和网络系统或分布式系统。</p>
<h4 id="6-平常常用的多线程处理方式及优缺点"><a href="#6-平常常用的多线程处理方式及优缺点" class="headerlink" title="6. 平常常用的多线程处理方式及优缺点"></a>6. 平常常用的多线程处理方式及优缺点</h4><p>iOS有四种多线程编程的技术，分别是：NSThread，Cocoa NSOperation，GCD（全称：Grand Central Dispatch）,pthread。</p>
<p><strong>四种方式的优缺点介绍:</strong></p>
<p>1）NSThread<strong>优点：NSThread 比其他两个轻量级</strong>。<strong>缺点：</strong>需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销。</p>
<p>2）Cocoa  NSOperation<strong>优点:</strong>不需要关心线程管理， 数据同步的事情，可以把精力放在自己需要执行的操作上。Cocoa operation相关的类是NSOperation, NSOperationQueue.NSOperation是个抽象类,使用它必须用它的子类，可以实现它或者使用它定义好的两个子类: NSInvocationOperation和NSBlockOperation.创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p>
<p>3)<strong>GCD</strong>(全优点)Grand Central dispatch(GCD)是Apple开发的一个多核编程的解决方案。在iOS4.0开始之后才能使用。GCD是一个替代NSThread, NSOperationQueue,NSInvocationOperation等技术的很高效强大的技术。</p>
<p>4) pthread是一套通用的多线程API，适用于Linux\Windows\Unix,跨平台，可移植，使用C语言，生命周期需要程序员管理，IOS开发中使用很少。</p>
<p><strong>GCD线程死锁</strong></p>
<p>GCD 确实好用 ，很强大，相比NSOpretion 无法提供 取消任务的功能。<br>如此强大的工具用不好可能会出现线程死锁。 如下代码：</p>
<pre><code>- (void)viewDidLoad{ 
[super viewDidLoad];     
NSLog(@&quot;=================4&quot;);
dispatch_sync(dispatch_get_main_queue(), 
             ^{ NSLog(@&quot;=================5&quot;); }); 
NSLog(@&quot;=================6&quot;);
}
</code></pre><p><strong>GCD Queue 分为三种：</strong><br>1，The main queue  ：主队列，主线程就是在个队列中。<br>2，Global queues ： 全局并发队列。<br>3，用户队列:是用函数 dispatch_queue_create创建的自定义队列</p>
<p><strong><strong>dispatch_sync 和  dispatch_async 区别：</strong></strong></p>
<p>dispatch_async(queue,block)  async 异步队列，dispatch_async<br> 函数会立即返回, block会在后台异步执行。</p>
<p>dispatch_sync(queue,block)   sync 同步队列，dispatch_sync<br> 函数不会立即返回，及阻塞当前线程,等待 block同步执行完成。</p>
<p><strong>分析上面代码：</strong><br>viewDidLoad 在主线程中， 及在dispatch_get_main_queue() 中，执行到sync 时 向<br>dispatch_get_main_queue()插入 同步 threed。sync 会等到 后面block 执行完成才返回， sync 又再 dispatch_get_main_queue() 队列中，它是串行队列，sync 是后加入的，前一个是主线程，所以 sync 想执行 block 必须等待主线程执行完成，主线程等待 sync 返回，去执行后续内容。照成死锁，sync 等待mainThread 执行完成， mianThread 等待sync 函数返回。下面例子：</p>
<pre><code>- (void)viewDidLoad{ 
[super viewDidLoad]; 
dispatch_async(dispatch_get_global_queue(0, 0), ^{ 
               NSLog(@&quot;=================1&quot;);
              dispatch_sync(dispatch_get_main_queue(), ^{ 
              NSLog(@&quot;=================2&quot;); }); 
NSLog(@&quot;=================3&quot;); });
}
</code></pre><p>程序会完成执行，为什么不会出现死锁。<br>首先： async 在主线程中  创建了一个异步线程 加入  全局并发队列，async 不会等待block 执行完成，立即返回，<br>1，async 立即返回， viewDidLoad 执行完毕，及主线程执行完毕。<br>2，同时，全局并发队列立即执行异步 block ， 打印 1， 当执行到 sync 它会等待 block 执行完成才返回， 及等待dispatch_get_main_queue() 队列中的 mianThread 执行完成， 然后才开始调用block 。因为1 和 2 几乎同时执行，因为2 在全局并发队列上， 2 中执行到sync 时 1 可能已经执行完成或 等了一会，mainThread 很快退出， 2 等已执行后继续内容。如果阻塞了主线程，2 中的sync 就无法执行啦，mainThread 永远不会退出， sync 就永远等待着。</p>
<h4 id="7-大量数据表的优化方案"><a href="#7-大量数据表的优化方案" class="headerlink" title="7. 大量数据表的优化方案"></a>7. 大量数据表的优化方案</h4><p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<pre><code>select id from t where num is null
</code></pre><p>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p>
<p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p>
<p>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<pre><code>select id from t where num=0
</code></pre><p>3.应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：</p>
<pre><code>select id from t where num=10 or Name=&apos;admin&apos;
</code></pre><p>可以这样查询：</p>
<pre><code>select id from t where num=10 union all select id from t where Name=&apos;admin&apos;
</code></pre><p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<pre><code>select id from t where num in (1,2,3)
</code></pre><p>对于连续的数值，能用 between 就不要用 in 了：</p>
<pre><code>select id from t where num between 1 and 3
</code></pre><p>很多时候用 exists 代替 in 是一个好的选择：</p>
<pre><code>select num from a where num in (select num from b)
</code></pre><p>用下面的语句替换：</p>
<pre><code>select num from a where exists (select 1 from b where num=a.num)
</code></pre><p>6.下面的查询也将导致全表扫描：</p>
<pre><code>select id from t where name like ‘%abc%’
</code></pre><p>若要提高效率，可以考虑全文检索。</p>
<p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<pre><code>select id from t where num=@num
</code></pre><p>可以改为强制查询使用索引：</p>
<pre><code>select id from t with (index(索引名)) where num=@num
</code></pre><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<pre><code>select id from t where num/2=100
</code></pre><p>应改为:</p>
<pre><code>select id from t where num=100*2
</code></pre><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<pre><code>select id from t where substring(name,1,3)=’abc’ -–name以abc开头的id
select id from t where datediff(day,createdate,’2015-11-30′)=0 -–‘2015-11-30’ --生成的id
</code></pre><p>应改为:</p>
<pre><code>select id from t where name like&apos;abc%&apos; 
select id from t where createdate&gt;=&apos;2005-11-30&apos; and createdate&lt;&apos;2005-12-1&apos;
</code></pre><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12.不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<pre><code>select col1,col2 into #t from t where1=0
</code></pre><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<pre><code>create table #t(…)
</code></pre><p>13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
<p>14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p>
<p>15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p>
<p>16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
<p>17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>19.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>20.任何地方都不要使用</p>
<pre><code>select * from t 
</code></pre><p>用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>22.避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p>
<p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p>29.尽量避免大事务操作，提高系统并发能力。</p>
<p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句</p>
<p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p>
<p>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p>
<p>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。</p>
<p>所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：</p>
<pre><code>while(1){//每次只做1000条
mysql_query(“delete from logs where log_date &lt;= ’2015-11-01’ limit 1000”);
if(mysql_affected_rows() == 0){//删除完成，退出！break；
}//每次暂停一段时间，释放表让其他进程/线程访问。
usleep(50000)
}
</code></pre><h4 id="8-常用到的动画库"><a href="#8-常用到的动画库" class="headerlink" title="8. 常用到的动画库"></a>8. 常用到的动画库</h4><p>Facebook 开源动画库 Pop 的 GitHub 主页：<a href="https://github.com/facebook/pop" target="_blank" rel="external">facebook/pop · GitHub</a>，介绍：<a href="http://codeplease.io/playing-with-pop-i/" target="_blank" rel="external">Playing with Pop (i)</a></p>
<p>Canvas 项目主页：<a href="http://canvaspod.io/" target="_blank" rel="external">Canvas - Simplify iOS Development</a>，介绍：<a href="https://medium.com/learning-xcode-as-a-designer/20c82a904164" target="_blank" rel="external">Animate in Xcode Without Code</a></p>
<p>拿 Canvas 来和 Pop 比其实不大合适，虽然两者都自称「动画库」，但是「库」这个词的含义有所区别。本质上 Canvas 是一个「动画合集」而 Pop 是一个「动画引擎」。</p>
<p>先说 Canvas。Canvas 的目的是「Animate in Xcode Without Code」。开发者可以通过在 Storyboard 中指定 User Defined Runtime Attributes 来实现一些 Canvas 中预设的动画，也就是他网站上能看到的那些。但是除了更改动画的 delay 和 duration 基本上不能调整其他的参数。</p>
<p>Pop 就不一样了。如果说 Canvas 是对 Core Animation 的封装，Pop 则是对 Core Animation（以及 UIDynamics）的再实现。</p>
<p>Pop 语法上和 Core Animation 相似，效果上则不像 Canvas 那么生硬（时间四等分，振幅硬编码）。这使得对 Core Animation 有了解的程序员可以很轻松地把原来的「静态动画」转换成「动态动画」。</p>
<p>同时 Pop 又往前多走了一步。既然动画的本质是根据时间函数来做插值，那么理论上任何一个对象的任何一个值都可以用来做插值，而不仅仅是 Core Animation 里定死的那一堆大小、位移、旋转、缩放等 animatable properties。</p>
<h4 id="9-Restful架构"><a href="#9-Restful架构" class="headerlink" title="9. Restful架构"></a>9. Restful架构</h4><p>REST是一种架构风格，其核心是面向资源，REST专门针对网络应用设计和开发方式，以降低开发的复杂性，提高系统的可伸缩性。REST提出设计概念和准则为：</p>
<pre><code>1.网络上的所有事物都可以被抽象为资源(resource)
2.每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识
3.所有的操作都是无状态的
</code></pre><p>REST简化开发，其架构遵循CRUD原则，该原则告诉我们对于资源(包括网络资源)只需要四种行为：创建，获取，更新和删除就可以完成相关的操作和处理。您可以通过统一资源标识符（Universal Resource Identifier，URI）来识别和定位资源，并且针对这些资源而执行的操作是通过 HTTP 规范定义的。其核心操作只有GET,PUT,POST,DELETE。</p>
<p>由于REST强制所有的操作都必须是stateless的，这就没有上下文的约束，如果做分布式，集群都不需要考虑上下文和会话保持的问题。极大的提高系统的可伸缩性。</p>
<p>RESTful架构：<br>　　（1）每一个URI代表一种资源；<br>　　（2）客户端和服务器之间，传递这种资源的某种表现层；<br>　　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<h4 id="10-请分析下SDWebImage的原理"><a href="#10-请分析下SDWebImage的原理" class="headerlink" title="10. 请分析下SDWebImage的原理"></a>10. 请分析下SDWebImage的原理</h4><p>这个类库提供一个UIImageView类别以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。</p>
<p><strong>SDWebImage 加载图片的流程</strong><br>1.入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</p>
<p>2.进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.</p>
<p>3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。</p>
<p>4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。</p>
<p>5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。</p>
<p>6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</p>
<p>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</p>
<p>8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。</p>
<p>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</p>
<p>10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。</p>
<p>11.connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。</p>
<p>12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</p>
<p>13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</p>
<p>14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。</p>
<p>15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。</p>
<p>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。</p>
<p>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</p>
<p>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。</p>
<p>19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。</p>
<p>20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</p>
<p><strong>SDWebImage库的作用</strong></p>
<p>通过对UIImageView的类别扩展来实现异步加载替换图片的工作。</p>
<p>主要用到的对象：<br>1、UIImageView (WebCache)类别，入口封装，实现读取图片完成后的回调<br>2、SDWebImageManager，对图片进行管理的中转站，记录那些图片正在读取。<br>向下层读取Cache（调用SDImageCache），或者向网络读取对象（调用SDWebImageDownloader） 。<br>实现SDImageCache和SDWebImageDownloader的回调。<br>3、SDImageCache，根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）<br>实现图片和内存清理工作。<br>4、SDWebImageDownloader，根据URL向网络读取数据（实现部分读取和全部读取后再通知回调两种方式）</p>
<p>其他类：<br>SDWebImageDecoder，异步对图像进行了一次解压⋯⋯</p>
<p><strong>1、SDImageCache是怎么做数据管理的?</strong></p>
<p>SDImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当SDWebImageManager向SDImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。</p>
<p><strong>2、为啥必须做Decoder?</strong><br>由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。<br>这种做法是典型的空间换时间的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-如何追踪app崩溃率，如何解决线上闪退&quot;&gt;&lt;a href=&quot;#1-如何追踪app崩溃率，如何解决线上闪退&quot; class=&quot;headerlink&quot; title=&quot;1.如何追踪app崩溃率，如何解决线上闪退&quot;&gt;&lt;/a&gt;1.如何追踪app崩溃率，如何解决线上闪退&lt;/
    
    </summary>
    
    
      <category term="Interview" scheme="https://dangdangfeng.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>iOS socket all in here</title>
    <link href="https://dangdangfeng.github.io/2014/05/31/iOS-socket-all-in-here/"/>
    <id>https://dangdangfeng.github.io/2014/05/31/iOS-socket-all-in-here/</id>
    <published>2014-05-30T16:49:55.000Z</published>
    <updated>2016-08-30T16:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<p>多个TCP连接或多个应用程序进程可能需要通过同一个TCP协议端口传输数据。为了区别不同的应用程序进程和连接，计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接,UDP连接同理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-6b9392fad31b711d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket使用"></p>
<h4 id="socket使用的库函数"><a href="#socket使用的库函数" class="headerlink" title="socket使用的库函数"></a>socket使用的库函数</h4><p>1.创建套接字</p>
<pre><code>Socket(af,type,protocol)//建立地址和套接字的联系

bind(sockid, local addr, addrlen)//服务器端侦听客户端的请求

listen( Sockid ,quenlen)//建立服务器/客户端的连接 (面向连接TCP）
</code></pre><p>2.客户端请求连接</p>
<pre><code>Connect(sockid, destaddr, addrlen)//服务器端等待从编号为Sockid的Socket上接收客户连接请求

newsockid=accept(Sockid，Clientaddr, paddrlen)//发送/接收数据
</code></pre><p>3.面向连接：</p>
<pre><code>send(sockid, buff, bufflen) 
recv( )
</code></pre><p>4.面向无连接：</p>
<pre><code>sendto(sockid,buff,…,addrlen) 
recvfrom( )
</code></pre><p>5.释放套接字</p>
<pre><code>close(socked)
</code></pre><p>在iOS中以NSStream(流)来发送和接收数据,可以设置流的代理，对流状态的变化做出相应的动作(连接建立，接收到数据，连接关闭）。</p>
<p>NSStream：数据流的父类，用于定义抽象特性，例如：打开、关闭代理，NSStream继承自CFStream(CoreFoundation)<br>NSInputStream：NSStream的子类，用于读取输入<br>NSOutputStream：NSSTream的子类，用于写输出。</p>
<p>服务端先不提，客户端代码大概如下：</p>
<pre><code>//需要导入&lt;arpa/inet.h&gt;，&lt;netdb.h&gt;
- (void)test
{
NSString * host =@&quot;123.33.33.1&quot;;
NSNumber * port = @1233;

// 创建 socket
int socketFileDescriptor = socket(AF_INET, SOCK_STREAM, 0);
if (-1 == socketFileDescriptor) {
    NSLog(@&quot;创建失败&quot;);
    return;
}

// 获取 IP 地址 
struct hostent * remoteHostEnt = gethostbyname([host UTF8String]);
if (NULL == remoteHostEnt) {
    close(socketFileDescriptor);
     NSLog(@&quot;%@&quot;,@&quot;无法解析服务器的主机名&quot;);
    return;
}

struct in_addr * remoteInAddr = (struct in_addr *)remoteHostEnt-&gt;h_addr_list[0];

// 设置 socket 参数
struct sockaddr_in socketParameters;
socketParameters.sin_family = AF_INET;
socketParameters.sin_addr = *remoteInAddr;
socketParameters.sin_port = htons([port intValue]);

// 连接 socket
int ret = connect(socketFileDescriptor, (struct sockaddr *) &amp;socketParameters, sizeof(socketParameters));
if (-1 == ret) {
    close(socketFileDescriptor);
    NSLog(@&quot;连接失败&quot;);
    return;
}

NSLog(@&quot;连接成功&quot;);
}
</code></pre><p>大概就是这样，因为是C语言的，所以看起来不是很方便，一般开发中都会使用比较简单的方法，如下。</p>
<h4 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h4><p>iOS的socket实现是特别简单的，可以使用用github的开源类库<a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="external">cocoaasyncsocket</a>简化开发，cocoaasyncsocket是支持tcp和ump的。代码大概如下：</p>
<pre><code>- (IBAction)connectToServer:(id)sender {
// 1.与服务器通过三次握手建立连接
NSString *host = @&quot;133.33.33.1&quot;;
int port = 1212;

//创建一个socket对象
_socket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)];

//连接
NSError *error = nil;
[_socket connectToHost:host onPort:port error:&amp;error];

if (error) {
    NSLog(@&quot;%@&quot;,error);
}
}


#pragma mark -socket的代理
#pragma mark 连接成功
-(void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port{
NSLog(@&quot;%s&quot;,__func__);
}


#pragma mark 断开连接
-(void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err{
if (err) {
    NSLog(@&quot;连接失败&quot;);
}else{
    NSLog(@&quot;正常断开&quot;);
}
}


#pragma mark 数据发送成功
-(void)socket:(GCDAsyncSocket *)sock didWriteDataWithTag:(long)tag{
NSLog(@&quot;%s&quot;,__func__);

//发送完数据手动读取，-1不设置超时
[sock readDataWithTimeout:-1 tag:tag];
}

#pragma mark 读取数据
-(void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag{
NSString *receiverStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
NSLog(@&quot;%s %@&quot;,__func__,receiverStr);
}
</code></pre><p>下面是原理补充，有兴趣的朋友可以细看。</p>
<hr>
<h4 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h4><p>网络七层协议由下往上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。其中物理层、数据链路层和网络层通常被称作媒体层，是网络工程师所研究的对象；传输层、会话层、表示层和应用层则被称作主机层，是用户所面向和关心的内容。</p>
<p>HTTP协议对应于应用层，TCP协议对应于传输层，IP协议对应于网络层，HTTP协议是基于TCP连接的,三者本质上没有可比性。 TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。<strong>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，是它的一组接口</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-1ceffddc43357839.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络七层协议"></p>
<h4 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h4><p>TCP/IP五层模型的协议分为：应用层、传输层、网络层、数据链路层和物理层。中继器、集线器、还有我们通常说的双绞线也工作在物理层；网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）在数据链路层；路由器、三层交换机在网络层；传输层主要是四层交换机、也有工作在四层的路由器。</p>
<p>TCP/IP协议中的应用层处理七层模型中的第五层、第六层和第七层的功能。TCP/IP协议中的传输层并不能总是保证在传输层可靠地传输数据包，而七层模型可以做到。TCP/IP协议还提供一项名为UDP（用户数据报协议）的选择。UDP不能保证可靠的数据包传输。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-df46648a7fadfa42.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对应关系"></p>
<blockquote>
<p>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。<br>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。<br>TCP是一种流模式的协议，UDP是一种数据报模式的协议。</p>
</blockquote>
<p>在传输数据时，可以只使用传输层（TCP/IP），但是那样的话，由于没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用应用层协议（HTTP、FTP、TELNET等），也可以自己定义应用层协议。</p>
<p>WEB使用HTTP作传输层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发送到网络上。<strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-fe177ff611c71d76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Socket的位置"></p>
<h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>要想明白Socket连接，先要明白TCP连接。手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</p>
<p>建立起一个TCP连接需要经过“三次握手”：<br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>三次握手(Three-way Handshake)即建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换TCP 窗口大小信息。<strong>在socket编程中，客户端执行connect()时,将触发三次握手</strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-a3120a20b9393a94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。</p>
<p>TCP连接的拆除需要发送四个包，因此称为四次握手(four-way handshake)。在socket编程中，任何一方执行close()操作即可产生握手（有地方称为“挥手”）操作。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-26cc9a86da3d9a68.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP连接的拆除"></p>
<p>之所以有“三次握手”和“四次握手”的区别，是因为连接时当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<h4 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h4><p>HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>
<p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p><strong>HTTPS</strong>（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，是HTTP的安全版。 在HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息。</p>
<p>https协议需要到ca申请证书；http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；http的连接很简单，是无状态的，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-0601aab8deb7df8d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS"></p>
<h4 id="Socket连接与HTTP连接的不同"><a href="#Socket连接与HTTP连接的不同" class="headerlink" title="Socket连接与HTTP连接的不同"></a>Socket连接与HTTP连接的不同</h4><p><strong>通常情况下Socket连接就是TCP连接</strong>，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p>
<p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。&lt;/p&gt;
&lt;p&gt;多个TCP连接或多个应用程序进程可能需要通过同
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
  <entry>
    <title>iOS的锁屏和解锁的时间机制</title>
    <link href="https://dangdangfeng.github.io/2014/05/06/iOS%E7%9A%84%E9%94%81%E5%B1%8F%E5%92%8C%E8%A7%A3%E9%94%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%9C%BA%E5%88%B6/"/>
    <id>https://dangdangfeng.github.io/2014/05/06/iOS的锁屏和解锁的时间机制/</id>
    <published>2014-05-06T13:54:20.000Z</published>
    <updated>2016-09-01T13:55:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="idleTimer"><a href="#idleTimer" class="headerlink" title="idleTimer"></a>idleTimer</h4><p>idleTimer 是iOS内置的时间监测机制，当在一段时间内未操作即进入锁屏状态。但有些应用程序是不需要锁住屏幕的，比如游戏，视频这类应用。 可以通过设置UIApplication的idleTimerDisabled属性来指定iOS是否锁屏。 </p>
<pre><code>// 禁用休闲时钟 
[[UIApplication sharedApplication] setIdleTimerDisabled: YES]; 
</code></pre><p>也可以使用这种语法 </p>
<pre><code>[UIApplication sharedApplication].idleTimerDisabled = YES;
</code></pre><p>但是，这个命令只能禁用自动锁屏，如果点击了锁屏按钮，仍然会进入锁屏的。有一点例外的是，AVPlayer不用设置idleTimerDisabled=YES，也能屏幕常亮，播放完成后过一分钟就自动关闭屏幕。有兴趣的可以自己尝试一下。</p>
<h4 id="锁屏和解锁通知"><a href="#锁屏和解锁通知" class="headerlink" title="锁屏和解锁通知"></a>锁屏和解锁通知</h4><p>iPhone的锁屏监测分为两种方式监听：一种是程序在前台，另一种程序在后台。 程序在前台，这种比较简单。直接使用Darwin层的通知就可以了：</p>
<blockquote>
<p>Darwin是由苹果电脑于2000年所释出的一个开放原始码操作系统。Darwin 是MacOSX 操作环境的操作系统成份。苹果电脑于2000年把Darwin 释出给开放原始码社群。现在的Darwin皆可以在苹果电脑的PowerPC 架构和X86 架构下执行，而后者的架构只有有限的驱动程序支援。</p>
</blockquote>
<pre><code>#import &lt;notify.h&gt;
#define NotificationLock CFSTR(&quot;com.apple.springboard.lockcomplete&quot;)
#define NotificationChange CFSTR(&quot;com.apple.springboard.lockstate&quot;)
#define NotificationPwdUI CFSTR(&quot;com.apple.springboard.hasBlankedScreen&quot;)

static void screenLockStateChanged(CFNotificationCenterRef center,void* observer,CFStringRef name,const void* object,CFDictionaryRef userInfo)
{
NSString* lockstate = (__bridge NSString*)name;
if ([lockstate isEqualToString:(__bridge  NSString*)NotificationLock]) {
    NSLog(@&quot;locked.&quot;);
} else {
    NSLog(@&quot;lock state changed.&quot;);
}
}

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, screenLockStateChanged, NotificationLock, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, screenLockStateChanged, NotificationChange, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
return YES;
}
</code></pre><p><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man3/notify_register_check.3.html" target="_blank" rel="external">notify.h</a>的具体内容可以移步开发文档。这种方法，程序在前台是可以拿到的，在后台情况下就无能为力了。</p>
<p>第二种是程序退后台后，这时再锁屏就收不到上面的那个通知了，需要另外一种方式, 以循环的方式一直来检测是否是锁屏状态，会消耗性能并可能被苹果挂起，需要合理设置循环时间。</p>
<pre><code>static void setScreenStateCb()
{
uint64_t locked;

__block int token = 0;
notify_register_dispatch(&quot;com.apple.springboard.lockstate&quot;,&amp;token,dispatch_get_main_queue(),^(int t){
});
notify_get_state(token, &amp;locked);
NSLog(@&quot;%d&quot;,(int)locked);
}

- (void)applicationDidEnterBackground:(UIApplication *)application
{
while (YES) {
    setScreenStateCb();
    sleep(5); // 循环5s
}
}
</code></pre><h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>上面我们使用了UIApplication的IdleTimerDisabled方法，下面就大概了解下UIApplication吧。</p>
<p>UIApplication，每个程序只能有一个，系统使用的是单例模式，用[UIApplication sharedApplication]来得到一个实例。这个单例实例是在系统启动时由main函数里面的UIApplicationMain方法生成，实现的是UIApplicationDelegate的Protocol，也就是AppDelegate的一个实例。每次通过[UIApplication sharedApplication]调用的就是它。UIApplication保存一个UIWindow对象序列，用来快速恢复views。</p>
<p>UIApplication在程序里的作用很多，大致如下所示：</p>
<pre><code>一、远程提醒，就是push notification注册；
二、可以连接到UIUndoManager；在Cocoa中使用NSUndoManager可以很方便的完成撤销操作。NSUndoManager会记录下修改、撤销操作的消息。这个机制使用两个NSInvocation对象栈。当进行操作时，控制器会添加一个该操作的逆操作的invocation到Undo栈中。当进行Undo操作时，Undo操作的逆操作会倍添加到Redo栈中，就这样利用Undo和Redo两个堆栈巧妙的实现撤销操作。需要注意的是，堆栈中存放的都是NSInvocation实例。
三、检查能否打开某个URL，并且打开URL；这个功能可以配合应用的自定义URL功能，来检测是否安装了某个应用。使用的是[[UIApplication sharedApplication] canOpenURL:url]方法。如果返回YES，可执行[[UIApplication sharedApplication] openURL:url]; 
四、注册Local Notification；
五、在后台运行以及从后台转为前台时的操作；
六、防止屏幕睡眠：即上面的[[UIApplication sharedApplication] setIdleTimerDisabled: YES]; 
七、手动调整status bar的位置和状态，如设置为竖屏、横屏等；
八、设置badge number，就是图标右上角的数字；
九、每当应用联网时，在状态栏上会显示联网小菊花。UIApplication可以设置是否出现。
UIApplication *app = [UIApplication sharedApplication]; 
app.networkActivityIndicatorVisible =!app.networkActivityIndicatorVisible;//转动 
app.networkActivityIndicatorVisible = app.networkActivityIndicatorVisible;//不转动
</code></pre><p><strong>UIUndoManager示例</strong></p>
<pre><code>- (void) one
{
position = position + 10;
[[undoManager prepareWithInvocationTarget:self] two];
[self showTheChangesToThePostion];
}

- (void) two
{
position = position - 10;
[[undoManager prepareWithInvocationTarget:self] one];
[self showTheChangesToThePostion];
}
</code></pre><p>prepareWithInvocationTarget:方法记录了target并返回UndoManager，然后UndoManager重载了forwardInvocation方法，也就将two方法的Invocation添加到undo栈中了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1170656-e230b6aa68d11fa4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解锁"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;idleTimer&quot;&gt;&lt;a href=&quot;#idleTimer&quot; class=&quot;headerlink&quot; title=&quot;idleTimer&quot;&gt;&lt;/a&gt;idleTimer&lt;/h4&gt;&lt;p&gt;idleTimer 是iOS内置的时间监测机制，当在一段时间内未操作即进入锁屏状态。
    
    </summary>
    
    
      <category term="技术" scheme="https://dangdangfeng.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>OC攻与伐</title>
    <link href="https://dangdangfeng.github.io/2014/03/31/OC%E6%94%BB%E4%B8%8E%E4%BC%90/"/>
    <id>https://dangdangfeng.github.io/2014/03/31/OC攻与伐/</id>
    <published>2014-03-31T15:18:27.000Z</published>
    <updated>2016-08-31T15:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1170656-e32064a1fdf12f76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Objective-C是非常“实际”的语言。它使用一个用C写成、很小的运行库，只会令应用程序的大小增加很小，和大部分OO（面向对象）系统使用极大的VM（如JVM等）执行取代了整个系统的运作相反。OC写成的程序通常不会比其原始码大很多。 Objective-C的最初版本并不支持垃圾回收。即是鉴于当时的面向对象语言回收时有漫长的“死亡时间”，令整个系统失去功用。Objective-C为避免此问题才不拥有这个功能。Objective-C的内存管理采用引用计数的方式，后期引入ARC（自动引用计数）。</p>
<p>ObjC不包括命名空间机制(namespace mechanism)。取而代之的是必须在其类别名称加上前缀，时常引致冲突。所有Mac OS X类别和函式均有“NS”作为前缀，使用“NS”是由于这些类别的名称在NeXTSTEP开发时定下。虽然Objective-C是C的母集，但它也不视C的基本型别为第一级的对象。 和C++不同，Objective-C不支援运算子多载(它不支持ad-hoc多型)。但和Java相同，Objective-C只容许对象继承一个类别(不设多重继承)。不过可以使用Categories和protocols实现多重继承。</p>
<p>由于Obj-C使用动态运行时类型，而且所有的方法都是函数调用（有时甚至连系统调用（syscalls）也如此），很多常见的编译时性能优化方法都不能应用于Obj-C（例如：内联函数、常数传播、交互式优化、纯量取代与聚集等）。这使得Obj-C性能劣于类似的对象抽象语言（如C++）。Obj-C运行时消耗较大，Obj-C本来就不应应用于C++或Java常见的底层抽象。这也静态处理和动态处理的重要区别。</p>
<h4 id="关于OC弱类型性的一个思考"><a href="#关于OC弱类型性的一个思考" class="headerlink" title="关于OC弱类型性的一个思考"></a>关于OC弱类型性的一个思考</h4><p>我们可以把任何想要的消息发送给代码中类型为“id”的变量，然后Objective-C的动态消息处理就会在运行时让这一调用正确地工作。但在实际情况中，即使方法的查找是发生在运行时期，这也只够确保正确的方法被调用，但却不足以确保参数是有效的。编译器肯定是需要推断出一些与所涉及的方法签名有关的信息的，即使编译器不需要知道id的类型，但它确实需要知道所有参数的字节长度，以及任何返回值的确切类型。这是因为参数的列集（marshal）（压入栈以及从栈中弹出它们）是在编译时配置的。然而通常情况下，我们不需要采取任何步骤来使之发生，参数的信息是通过查看你试图调用的方法的名称来获取的，搜索整个被包含进来的头文件查找与被调用方法的名称吻合的方法，然后从其找到的第一个匹配方法中获取参数的长度。即使你真正指向的确切方法不能被明确分辨出来，匹配方法之间的参数也有可能会是相同的，因为Objective-C中的方法名称通常就暗示了数据的类型。</p>
<p>设想你有一个类MyClass，该类有一个名为currentPoint的实例方法，该方法返回一个int类型的值。你希望调用保存在数组中的对象的currentPoint，于是使用了这样的代码：</p>
<pre><code>int result = [[someArray objectAtIndex:0] currentPoint];
</code></pre><p>运行时调用的方法是正确的，问题是编译器为这一调用列集的参数是不正确的，这导致了数据的返回类型被破坏。[someArray objectAtIndex:0]不能明确的指出得到的一定是类MyClass，解决办法就是强制转换。</p>
<pre><code>int result = [(MyClass *)[someArray objectAtIndex:0] currentPoint];
</code></pre><p>在消息发送之前，编译器需要正确地把参数压入到栈中，然后执行消息发送，使用正确的objc_msgSend来取回返回值，而这就是出现故障的地方。</p>
<p>编译器使用方法签名（通过查看接收者的类型和该接收者的所有有效方法名称来获取的）来准备参数，并试图找出你可能想要调用的方法是哪一个。由于接收者的类型（比如说objectAtIndex:的调用结果）仅为id，这样的话我们就没有显式的类型信息，因此编译器就会查看所有已知方法的一个列表。不幸的是，编译器找到的不是我们的MyClass的方法，其决定匹配NSBezierPath的名为currentPoint的方法，并准备了与该方法的签名相匹配的参数。NSBezierPath的方法返回一个struct类型的NSPoint，而这就导致我们的返回类型被破坏了。</p>
<p>对于实例方法来说，我们是通过强制转换成所需的特定对象类型来修正问题的，但在两个对象都是类方法的情况下，就不可能强制转换所涉及的特定Class了，在Objective-C中，你不能强制转换类方法。如果你不能够改变方法的名称的话，那么唯一的权变之法看起来就像是这个样子：</p>
<pre><code>int result = objc_msgSend([someArray objectAtIndex:0], @selector(currentPoint));
</code></pre><h4 id="一道题的分析"><a href="#一道题的分析" class="headerlink" title="一道题的分析"></a>一道题的分析</h4><pre><code>@implementation Son : Father
- (id)init {
self = [super init];
if (self) {
    NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
    NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
}
return self;
}
@end
</code></pre><p>答案：都输出”Son”</p>
<p>因为oc的方法寻找是在编译期执行的，self表示本类Son，super表示父类Father，NSObject是Son和Father的父类。class方法在NSObject中定义，并且没有被Father和Son覆盖。[self class]的方法寻找方式是：Son,Father,NSObject，[super class]的方法寻找方式是：Father，NSObject，最终执行的都是NSObject里面定义的class方法。要执行的方法找完之后，程序进入运行期，即执行刚才找到的方法。而方法的实际调用者是对象。[super class]和[self class]的实际调用者都是Son对象。因此最后的打印结果应该都是Son。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1170656-e32064a1fdf12f76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
    
      <category term="technology" scheme="https://dangdangfeng.github.io/tags/technology/"/>
    
  </entry>
  
</feed>
